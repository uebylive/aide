/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/clipboard-js/clipboard.js":
/*!****************************************************!*\
  !*** ../../node_modules/clipboard-js/clipboard.js ***!
  \****************************************************/
/***/ ((module) => {

eval("//  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd\n(function (name, definition) {\n  if (true) {\n    module.exports = definition();\n  } else {}\n})(\"clipboard\", function () {\n  if (typeof document === 'undefined' || !document.addEventListener) {\n    return null;\n  }\n\n  var clipboard = {};\n\n  clipboard.copy = function () {\n    var _intercept = false;\n    var _data = null; // Map from data type (e.g. \"text/html\") to value.\n\n    var _bogusSelection = false;\n\n    function cleanup() {\n      _intercept = false;\n      _data = null;\n\n      if (_bogusSelection) {\n        window.getSelection().removeAllRanges();\n      }\n\n      _bogusSelection = false;\n    }\n\n    document.addEventListener(\"copy\", function (e) {\n      if (_intercept) {\n        for (var key in _data) {\n          e.clipboardData.setData(key, _data[key]);\n        }\n\n        e.preventDefault();\n      }\n    }); // Workaround for Safari: https://bugs.webkit.org/show_bug.cgi?id=156529\n\n    function bogusSelect() {\n      var sel = document.getSelection(); // If \"nothing\" is selected...\n\n      if (!document.queryCommandEnabled(\"copy\") && sel.isCollapsed) {\n        // ... temporarily select the entire body.\n        //\n        // We select the entire body because:\n        // - it's guaranteed to exist,\n        // - it works (unlike, say, document.head, or phantom element that is\n        //   not inserted into the DOM),\n        // - it doesn't seem to flicker (due to the synchronous copy event), and\n        // - it avoids modifying the DOM (can trigger mutation observers).\n        //\n        // Because we can't do proper feature detection (we already checked\n        // document.queryCommandEnabled(\"copy\") , which actually gives a false\n        // negative for Blink when nothing is selected) and UA sniffing is not\n        // reliable (a lot of UA strings contain \"Safari\"), this will also\n        // happen for some browsers other than Safari. :-()\n        var range = document.createRange();\n        range.selectNodeContents(document.body);\n        sel.removeAllRanges();\n        sel.addRange(range);\n        _bogusSelection = true;\n      }\n    }\n\n    ;\n    return function (data) {\n      return new Promise(function (resolve, reject) {\n        _intercept = true;\n\n        if (typeof data === \"string\") {\n          _data = {\n            \"text/plain\": data\n          };\n        } else if (data instanceof Node) {\n          _data = {\n            \"text/html\": new XMLSerializer().serializeToString(data)\n          };\n        } else if (data instanceof Object) {\n          _data = data;\n        } else {\n          reject(\"Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings.\");\n        }\n\n        function triggerCopy(tryBogusSelect) {\n          try {\n            if (document.execCommand(\"copy\")) {\n              // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis\n              // So we can call resolve() back here.\n              cleanup();\n              resolve();\n            } else {\n              if (!tryBogusSelect) {\n                bogusSelect();\n                triggerCopy(true);\n              } else {\n                cleanup();\n                throw new Error(\"Unable to copy. Perhaps it's not available in your browser?\");\n              }\n            }\n          } catch (e) {\n            cleanup();\n            reject(e);\n          }\n        }\n\n        triggerCopy(false);\n      });\n    };\n  }();\n\n  clipboard.paste = function () {\n    var _intercept = false;\n\n    var _resolve;\n\n    var _dataType;\n\n    document.addEventListener(\"paste\", function (e) {\n      if (_intercept) {\n        _intercept = false;\n        e.preventDefault();\n        var resolve = _resolve;\n        _resolve = null;\n        resolve(e.clipboardData.getData(_dataType));\n      }\n    });\n    return function (dataType) {\n      return new Promise(function (resolve, reject) {\n        _intercept = true;\n        _resolve = resolve;\n        _dataType = dataType || \"text/plain\";\n\n        try {\n          if (!document.execCommand(\"paste\")) {\n            _intercept = false;\n            reject(new Error(\"Unable to paste. Pasting only works in Internet Explorer at the moment.\"));\n          }\n        } catch (e) {\n          _intercept = false;\n          reject(new Error(e));\n        }\n      });\n    };\n  }(); // Handle IE behaviour.\n\n\n  if (typeof ClipboardEvent === \"undefined\" && typeof window.clipboardData !== \"undefined\" && typeof window.clipboardData.setData !== \"undefined\") {\n    /*! promise-polyfill 2.0.1 */\n    (function (a) {\n      function b(a, b) {\n        return function () {\n          a.apply(b, arguments);\n        };\n      }\n\n      function c(a) {\n        if (\"object\" != typeof this) throw new TypeError(\"Promises must be constructed via new\");\n        if (\"function\" != typeof a) throw new TypeError(\"not a function\");\n        this._state = null, this._value = null, this._deferreds = [], i(a, b(e, this), b(f, this));\n      }\n\n      function d(a) {\n        var b = this;\n        return null === this._state ? void this._deferreds.push(a) : void j(function () {\n          var c = b._state ? a.onFulfilled : a.onRejected;\n          if (null === c) return void (b._state ? a.resolve : a.reject)(b._value);\n          var d;\n\n          try {\n            d = c(b._value);\n          } catch (e) {\n            return void a.reject(e);\n          }\n\n          a.resolve(d);\n        });\n      }\n\n      function e(a) {\n        try {\n          if (a === this) throw new TypeError(\"A promise cannot be resolved with itself.\");\n\n          if (a && (\"object\" == typeof a || \"function\" == typeof a)) {\n            var c = a.then;\n            if (\"function\" == typeof c) return void i(b(c, a), b(e, this), b(f, this));\n          }\n\n          this._state = !0, this._value = a, g.call(this);\n        } catch (d) {\n          f.call(this, d);\n        }\n      }\n\n      function f(a) {\n        this._state = !1, this._value = a, g.call(this);\n      }\n\n      function g() {\n        for (var a = 0, b = this._deferreds.length; b > a; a++) d.call(this, this._deferreds[a]);\n\n        this._deferreds = null;\n      }\n\n      function h(a, b, c, d) {\n        this.onFulfilled = \"function\" == typeof a ? a : null, this.onRejected = \"function\" == typeof b ? b : null, this.resolve = c, this.reject = d;\n      }\n\n      function i(a, b, c) {\n        var d = !1;\n\n        try {\n          a(function (a) {\n            d || (d = !0, b(a));\n          }, function (a) {\n            d || (d = !0, c(a));\n          });\n        } catch (e) {\n          if (d) return;\n          d = !0, c(e);\n        }\n      }\n\n      var j = c.immediateFn || \"function\" == typeof setImmediate && setImmediate || function (a) {\n        setTimeout(a, 1);\n      },\n          k = Array.isArray || function (a) {\n        return \"[object Array]\" === Object.prototype.toString.call(a);\n      };\n\n      c.prototype[\"catch\"] = function (a) {\n        return this.then(null, a);\n      }, c.prototype.then = function (a, b) {\n        var e = this;\n        return new c(function (c, f) {\n          d.call(e, new h(a, b, c, f));\n        });\n      }, c.all = function () {\n        var a = Array.prototype.slice.call(1 === arguments.length && k(arguments[0]) ? arguments[0] : arguments);\n        return new c(function (b, c) {\n          function d(f, g) {\n            try {\n              if (g && (\"object\" == typeof g || \"function\" == typeof g)) {\n                var h = g.then;\n                if (\"function\" == typeof h) return void h.call(g, function (a) {\n                  d(f, a);\n                }, c);\n              }\n\n              a[f] = g, 0 === --e && b(a);\n            } catch (i) {\n              c(i);\n            }\n          }\n\n          if (0 === a.length) return b([]);\n\n          for (var e = a.length, f = 0; f < a.length; f++) d(f, a[f]);\n        });\n      }, c.resolve = function (a) {\n        return a && \"object\" == typeof a && a.constructor === c ? a : new c(function (b) {\n          b(a);\n        });\n      }, c.reject = function (a) {\n        return new c(function (b, c) {\n          c(a);\n        });\n      }, c.race = function (a) {\n        return new c(function (b, c) {\n          for (var d = 0, e = a.length; e > d; d++) a[d].then(b, c);\n        });\n      },  true && module.exports ? module.exports = c : a.Promise || (a.Promise = c);\n    })(this);\n\n    clipboard.copy = function (data) {\n      return new Promise(function (resolve, reject) {\n        // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx\n        // We only support the string type for now.\n        if (typeof data !== \"string\" && !(\"text/plain\" in data)) {\n          throw new Error(\"You must provide a text/plain type.\");\n        }\n\n        var strData = typeof data === \"string\" ? data : data[\"text/plain\"];\n        var copySucceeded = window.clipboardData.setData(\"Text\", strData);\n\n        if (copySucceeded) {\n          resolve();\n        } else {\n          reject(new Error(\"Copying was rejected.\"));\n        }\n      });\n    };\n\n    clipboard.paste = function () {\n      return new Promise(function (resolve, reject) {\n        var strData = window.clipboardData.getData(\"Text\");\n\n        if (strData) {\n          resolve(strData);\n        } else {\n          // The user rejected the paste request.\n          reject(new Error(\"Pasting was rejected.\"));\n        }\n      });\n    };\n  }\n\n  return clipboard;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2NsaXBib2FyZC1qcy9jbGlwYm9hcmQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi8uLi9ub2RlX21vZHVsZXMvY2xpcGJvYXJkLWpzL2NsaXBib2FyZC5qcz9lZDgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICBJbXBvcnQgc3VwcG9ydCBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzY3MzM0Ni9zdXBwb3J0aW5nLWJvdGgtY29tbW9uanMtYW5kLWFtZFxuKGZ1bmN0aW9uKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTsgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gXCJvYmplY3RcIikgeyBkZWZpbmUoZGVmaW5pdGlvbik7IH1cbiAgICBlbHNlIHsgdGhpc1tuYW1lXSA9IGRlZmluaXRpb24oKTsgfVxufShcImNsaXBib2FyZFwiLCBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjbGlwYm9hcmQgPSB7fTtcblxuICBjbGlwYm9hcmQuY29weSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgX2ludGVyY2VwdCA9IGZhbHNlO1xuICAgIHZhciBfZGF0YSA9IG51bGw7IC8vIE1hcCBmcm9tIGRhdGEgdHlwZSAoZS5nLiBcInRleHQvaHRtbFwiKSB0byB2YWx1ZS5cbiAgICB2YXIgX2JvZ3VzU2VsZWN0aW9uID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgX2ludGVyY2VwdCA9IGZhbHNlO1xuICAgICAgX2RhdGEgPSBudWxsO1xuICAgICAgaWYgKF9ib2d1c1NlbGVjdGlvbikge1xuICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgICBfYm9ndXNTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoX2ludGVyY2VwdCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gX2RhdGEpIHtcbiAgICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShrZXksIF9kYXRhW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjUyOVxuICAgIGZ1bmN0aW9uIGJvZ3VzU2VsZWN0KCkge1xuICAgICAgdmFyIHNlbCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgICAgLy8gSWYgXCJub3RoaW5nXCIgaXMgc2VsZWN0ZWQuLi5cbiAgICAgIGlmICghZG9jdW1lbnQucXVlcnlDb21tYW5kRW5hYmxlZChcImNvcHlcIikgJiYgc2VsLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgIC8vIC4uLiB0ZW1wb3JhcmlseSBzZWxlY3QgdGhlIGVudGlyZSBib2R5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBzZWxlY3QgdGhlIGVudGlyZSBib2R5IGJlY2F1c2U6XG4gICAgICAgIC8vIC0gaXQncyBndWFyYW50ZWVkIHRvIGV4aXN0LFxuICAgICAgICAvLyAtIGl0IHdvcmtzICh1bmxpa2UsIHNheSwgZG9jdW1lbnQuaGVhZCwgb3IgcGhhbnRvbSBlbGVtZW50IHRoYXQgaXNcbiAgICAgICAgLy8gICBub3QgaW5zZXJ0ZWQgaW50byB0aGUgRE9NKSxcbiAgICAgICAgLy8gLSBpdCBkb2Vzbid0IHNlZW0gdG8gZmxpY2tlciAoZHVlIHRvIHRoZSBzeW5jaHJvbm91cyBjb3B5IGV2ZW50KSwgYW5kXG4gICAgICAgIC8vIC0gaXQgYXZvaWRzIG1vZGlmeWluZyB0aGUgRE9NIChjYW4gdHJpZ2dlciBtdXRhdGlvbiBvYnNlcnZlcnMpLlxuICAgICAgICAvL1xuICAgICAgICAvLyBCZWNhdXNlIHdlIGNhbid0IGRvIHByb3BlciBmZWF0dXJlIGRldGVjdGlvbiAod2UgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgIC8vIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZEVuYWJsZWQoXCJjb3B5XCIpICwgd2hpY2ggYWN0dWFsbHkgZ2l2ZXMgYSBmYWxzZVxuICAgICAgICAvLyBuZWdhdGl2ZSBmb3IgQmxpbmsgd2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkKSBhbmQgVUEgc25pZmZpbmcgaXMgbm90XG4gICAgICAgIC8vIHJlbGlhYmxlIChhIGxvdCBvZiBVQSBzdHJpbmdzIGNvbnRhaW4gXCJTYWZhcmlcIiksIHRoaXMgd2lsbCBhbHNvXG4gICAgICAgIC8vIGhhcHBlbiBmb3Igc29tZSBicm93c2VycyBvdGhlciB0aGFuIFNhZmFyaS4gOi0oKVxuICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgX2JvZ3VzU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX2ludGVyY2VwdCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIF9kYXRhID0ge1widGV4dC9wbGFpblwiOiBkYXRhfTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIF9kYXRhID0ge1widGV4dC9odG1sXCI6IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoZGF0YSl9O1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBPYmplY3Qpe1xuICAgICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoXCJJbnZhbGlkIGRhdGEgdHlwZS4gTXVzdCBiZSBzdHJpbmcsIERPTSBub2RlLCBvciBhbiBvYmplY3QgbWFwcGluZyBNSU1FIHR5cGVzIHRvIHN0cmluZ3MuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyQ29weSh0cnlCb2d1c1NlbGVjdCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjb3B5XCIpKSB7XG4gICAgICAgICAgICAgIC8vIGRvY3VtZW50LmV4ZWNDb21tYW5kIGlzIHN5bmNocm9ub3VzOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDE1L1dELWNsaXBib2FyZC1hcGlzLTIwMTUwNDIxLyNpbnRlZ3JhdGlvbi13aXRoLXJpY2gtdGV4dC1lZGl0aW5nLWFwaXNcbiAgICAgICAgICAgICAgLy8gU28gd2UgY2FuIGNhbGwgcmVzb2x2ZSgpIGJhY2sgaGVyZS5cbiAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCF0cnlCb2d1c1NlbGVjdCkge1xuICAgICAgICAgICAgICAgIGJvZ3VzU2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckNvcHkodHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb3B5LiBQZXJoYXBzIGl0J3Mgbm90IGF2YWlsYWJsZSBpbiB5b3VyIGJyb3dzZXI/XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyQ29weShmYWxzZSk7XG5cbiAgICAgIH0pO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgY2xpcGJvYXJkLnBhc3RlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBfaW50ZXJjZXB0ID0gZmFsc2U7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIHZhciBfZGF0YVR5cGU7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKF9pbnRlcmNlcHQpIHtcbiAgICAgICAgX2ludGVyY2VwdCA9IGZhbHNlO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgICAgIF9yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShfZGF0YVR5cGUpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbihkYXRhVHlwZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfaW50ZXJjZXB0ID0gdHJ1ZTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBfZGF0YVR5cGUgPSBkYXRhVHlwZSB8fCBcInRleHQvcGxhaW5cIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmV4ZWNDb21tYW5kKFwicGFzdGVcIikpIHtcbiAgICAgICAgICAgIF9pbnRlcmNlcHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFzdGUuIFBhc3Rpbmcgb25seSB3b3JrcyBpbiBJbnRlcm5ldCBFeHBsb3JlciBhdCB0aGUgbW9tZW50LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX2ludGVyY2VwdCA9IGZhbHNlO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8vIEhhbmRsZSBJRSBiZWhhdmlvdXIuXG4gIGlmICh0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgIHR5cGVvZiB3aW5kb3cuY2xpcGJvYXJkRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgdHlwZW9mIHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcblxuICAgIC8qISBwcm9taXNlLXBvbHlmaWxsIDIuMC4xICovXG4gICAgKGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXthLmFwcGx5KGIsYXJndW1lbnRzKX19ZnVuY3Rpb24gYyhhKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdGhpcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3XCIpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIGZ1bmN0aW9uXCIpO3RoaXMuX3N0YXRlPW51bGwsdGhpcy5fdmFsdWU9bnVsbCx0aGlzLl9kZWZlcnJlZHM9W10saShhLGIoZSx0aGlzKSxiKGYsdGhpcykpfWZ1bmN0aW9uIGQoYSl7dmFyIGI9dGhpcztyZXR1cm4gbnVsbD09PXRoaXMuX3N0YXRlP3ZvaWQgdGhpcy5fZGVmZXJyZWRzLnB1c2goYSk6dm9pZCBqKGZ1bmN0aW9uKCl7dmFyIGM9Yi5fc3RhdGU/YS5vbkZ1bGZpbGxlZDphLm9uUmVqZWN0ZWQ7aWYobnVsbD09PWMpcmV0dXJuIHZvaWQoYi5fc3RhdGU/YS5yZXNvbHZlOmEucmVqZWN0KShiLl92YWx1ZSk7dmFyIGQ7dHJ5e2Q9YyhiLl92YWx1ZSl9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgYS5yZWplY3QoZSl9YS5yZXNvbHZlKGQpfSl9ZnVuY3Rpb24gZShhKXt0cnl7aWYoYT09PXRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuXCIpO2lmKGEmJihcIm9iamVjdFwiPT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT10eXBlb2YgYSkpe3ZhciBjPWEudGhlbjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBjKXJldHVybiB2b2lkIGkoYihjLGEpLGIoZSx0aGlzKSxiKGYsdGhpcykpfXRoaXMuX3N0YXRlPSEwLHRoaXMuX3ZhbHVlPWEsZy5jYWxsKHRoaXMpfWNhdGNoKGQpe2YuY2FsbCh0aGlzLGQpfX1mdW5jdGlvbiBmKGEpe3RoaXMuX3N0YXRlPSExLHRoaXMuX3ZhbHVlPWEsZy5jYWxsKHRoaXMpfWZ1bmN0aW9uIGcoKXtmb3IodmFyIGE9MCxiPXRoaXMuX2RlZmVycmVkcy5sZW5ndGg7Yj5hO2ErKylkLmNhbGwodGhpcyx0aGlzLl9kZWZlcnJlZHNbYV0pO3RoaXMuX2RlZmVycmVkcz1udWxsfWZ1bmN0aW9uIGgoYSxiLGMsZCl7dGhpcy5vbkZ1bGZpbGxlZD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2E6bnVsbCx0aGlzLm9uUmVqZWN0ZWQ9XCJmdW5jdGlvblwiPT10eXBlb2YgYj9iOm51bGwsdGhpcy5yZXNvbHZlPWMsdGhpcy5yZWplY3Q9ZH1mdW5jdGlvbiBpKGEsYixjKXt2YXIgZD0hMTt0cnl7YShmdW5jdGlvbihhKXtkfHwoZD0hMCxiKGEpKX0sZnVuY3Rpb24oYSl7ZHx8KGQ9ITAsYyhhKSl9KX1jYXRjaChlKXtpZihkKXJldHVybjtkPSEwLGMoZSl9fXZhciBqPWMuaW1tZWRpYXRlRm58fFwiZnVuY3Rpb25cIj09dHlwZW9mIHNldEltbWVkaWF0ZSYmc2V0SW1tZWRpYXRlfHxmdW5jdGlvbihhKXtzZXRUaW1lb3V0KGEsMSl9LGs9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfTtjLnByb3RvdHlwZVtcImNhdGNoXCJdPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnRoZW4obnVsbCxhKX0sYy5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihhLGIpe3ZhciBlPXRoaXM7cmV0dXJuIG5ldyBjKGZ1bmN0aW9uKGMsZil7ZC5jYWxsKGUsbmV3IGgoYSxiLGMsZikpfSl9LGMuYWxsPWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmsoYXJndW1lbnRzWzBdKT9hcmd1bWVudHNbMF06YXJndW1lbnRzKTtyZXR1cm4gbmV3IGMoZnVuY3Rpb24oYixjKXtmdW5jdGlvbiBkKGYsZyl7dHJ5e2lmKGcmJihcIm9iamVjdFwiPT10eXBlb2YgZ3x8XCJmdW5jdGlvblwiPT10eXBlb2YgZykpe3ZhciBoPWcudGhlbjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBoKXJldHVybiB2b2lkIGguY2FsbChnLGZ1bmN0aW9uKGEpe2QoZixhKX0sYyl9YVtmXT1nLDA9PT0tLWUmJmIoYSl9Y2F0Y2goaSl7YyhpKX19aWYoMD09PWEubGVuZ3RoKXJldHVybiBiKFtdKTtmb3IodmFyIGU9YS5sZW5ndGgsZj0wO2Y8YS5sZW5ndGg7ZisrKWQoZixhW2ZdKX0pfSxjLnJlc29sdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJlwib2JqZWN0XCI9PXR5cGVvZiBhJiZhLmNvbnN0cnVjdG9yPT09Yz9hOm5ldyBjKGZ1bmN0aW9uKGIpe2IoYSl9KX0sYy5yZWplY3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGZ1bmN0aW9uKGIsYyl7YyhhKX0pfSxjLnJhY2U9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkPTAsZT1hLmxlbmd0aDtlPmQ7ZCsrKWFbZF0udGhlbihiLGMpfSl9LFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWM6YS5Qcm9taXNlfHwoYS5Qcm9taXNlPWMpfSkodGhpcyk7XG5cbiAgICBjbGlwYm9hcmQuY29weSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gSUUgc3VwcG9ydHMgc3RyaW5nIGFuZCBVUkwgdHlwZXM6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY3NDQodj12cy44NSkuYXNweFxuICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdGhlIHN0cmluZyB0eXBlIGZvciBub3cuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiAmJiAhKFwidGV4dC9wbGFpblwiIGluIGRhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhIHRleHQvcGxhaW4gdHlwZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyRGF0YSA9ICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBkYXRhW1widGV4dC9wbGFpblwiXSk7XG4gICAgICAgIHZhciBjb3B5U3VjY2VlZGVkID0gd2luZG93LmNsaXBib2FyZERhdGEuc2V0RGF0YShcIlRleHRcIiwgc3RyRGF0YSk7XG4gICAgICAgIGlmIChjb3B5U3VjY2VlZGVkKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3B5aW5nIHdhcyByZWplY3RlZC5cIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY2xpcGJvYXJkLnBhc3RlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBzdHJEYXRhID0gd2luZG93LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgIGlmIChzdHJEYXRhKSB7XG4gICAgICAgICAgcmVzb2x2ZShzdHJEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgdXNlciByZWplY3RlZCB0aGUgcGFzdGUgcmVxdWVzdC5cbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUGFzdGluZyB3YXMgcmVqZWN0ZWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBjbGlwYm9hcmQ7XG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/clipboard-js/clipboard.js\n");

/***/ }),

/***/ "../../node_modules/compare-versions/lib/esm/index.js":
/*!************************************************************!*\
  !*** ../../node_modules/compare-versions/lib/esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compare\": () => (/* binding */ compare),\n/* harmony export */   \"compareVersions\": () => (/* binding */ compareVersions),\n/* harmony export */   \"satisfies\": () => (/* binding */ satisfies),\n/* harmony export */   \"validate\": () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nconst compareVersions = (v1, v2) => {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2); // pop off the patch\n\n  const p1 = n1.pop();\n  const p2 = n2.pop(); // validate numbers\n\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r; // validate pre-release\n\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n};\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\n\nconst validate = version => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\n\nconst compare = (v1, v2, operator) => {\n  // validate input operator\n  assertValidOperator(operator); // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n\n  const res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\n\nconst satisfies = (version, range) => {\n  // if no range operator then \"=\"\n  const m = range.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '='; // if gt/lt/eq then operator compare\n\n  if (op !== '^' && op !== '~') return compare(version, range, op); // else range of either \"~\" or \"^\" is assumed\n\n  const [v1, v2, v3,, vp] = validateAndParse(version);\n  const [r1, r2, r3,, rp] = validateAndParse(range);\n  const v = [v1, v2, v3];\n  const r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x']; // validate pre-release\n\n  if (rp) {\n    if (!vp) return false;\n    if (compareSegments(v, r) !== 0) return false;\n    if (compareSegments(vp.split('.'), rp.split('.')) === -1) return false;\n  } // first non-zero number\n\n\n  const nonZero = r.findIndex(v => v !== '0') + 1; // pointer to where segments can be >=\n\n  const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1; // before pointer must be equal\n\n  if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0) return false; // after pointer must be >=\n\n  if (compareSegments(v.slice(i), r.slice(i)) === -1) return false;\n  return true;\n};\nconst semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nconst validateAndParse = version => {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n\n  const match = version.match(semver);\n\n  if (!match) {\n    throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n  }\n\n  match.shift();\n  return match;\n};\n\nconst isWildcard = s => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = v => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a, b) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nconst compareSegments = (a, b) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n\n  return 0;\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = op => {\n  if (typeof op !== 'string') {\n    throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n  }\n\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBhcmUtdmVyc2lvbnMvbGliL2VzbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUdBOztBQUdBOztBQUdBO0FBRUE7QUFDQTtBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7O0FBRUE7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL3NyYy9pbmRleC50cz8wZTNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29tcGFyZSBbc2VtdmVyXShodHRwczovL3NlbXZlci5vcmcvKSB2ZXJzaW9uIHN0cmluZ3MgdG8gZmluZCBncmVhdGVyLCBlcXVhbCBvciBsZXNzZXIuXG4gKiBUaGlzIGxpYnJhcnkgc3VwcG9ydHMgdGhlIGZ1bGwgc2VtdmVyIHNwZWNpZmljYXRpb24sIGluY2x1ZGluZyBjb21wYXJpbmcgdmVyc2lvbnMgd2l0aCBkaWZmZXJlbnQgbnVtYmVyIG9mIGRpZ2l0cyBsaWtlIGAxLjAuMGAsIGAxLjBgLCBgMWAsIGFuZCBwcmUtcmVsZWFzZSB2ZXJzaW9ucyBsaWtlIGAxLjAuMC1hbHBoYWAuXG4gKiBAcGFyYW0gdjEgLSBGaXJzdCB2ZXJzaW9uIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB2MiAtIFNlY29uZCB2ZXJzaW9uIHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIE51bWVyaWMgdmFsdWUgY29tcGF0aWJsZSB3aXRoIHRoZSBbQXJyYXkuc29ydChmbikgaW50ZXJmYWNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1BhcmFtZXRlcnMpLlxuICovXG5leHBvcnQgY29uc3QgY29tcGFyZVZlcnNpb25zID0gKHYxLCB2MikgPT4ge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0IGFuZCBzcGxpdCBpbnRvIHNlZ21lbnRzXG4gICAgY29uc3QgbjEgPSB2YWxpZGF0ZUFuZFBhcnNlKHYxKTtcbiAgICBjb25zdCBuMiA9IHZhbGlkYXRlQW5kUGFyc2UodjIpO1xuICAgIC8vIHBvcCBvZmYgdGhlIHBhdGNoXG4gICAgY29uc3QgcDEgPSBuMS5wb3AoKTtcbiAgICBjb25zdCBwMiA9IG4yLnBvcCgpO1xuICAgIC8vIHZhbGlkYXRlIG51bWJlcnNcbiAgICBjb25zdCByID0gY29tcGFyZVNlZ21lbnRzKG4xLCBuMik7XG4gICAgaWYgKHIgIT09IDApXG4gICAgICAgIHJldHVybiByO1xuICAgIC8vIHZhbGlkYXRlIHByZS1yZWxlYXNlXG4gICAgaWYgKHAxICYmIHAyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlU2VnbWVudHMocDEuc3BsaXQoJy4nKSwgcDIuc3BsaXQoJy4nKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHAxIHx8IHAyKSB7XG4gICAgICAgIHJldHVybiBwMSA/IC0xIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZSBbc2VtdmVyXShodHRwczovL3NlbXZlci5vcmcvKSB2ZXJzaW9uIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiBudW1iZXIgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVyc2lvbiBudW1iZXIgaXMgYSB2YWxpZCBzZW12ZXIgdmVyc2lvbiBudW1iZXIsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIHZhbGlkYXRlKCcxLjAuMC1yYy4xJyk7IC8vIHJldHVybiB0cnVlXG4gKiB2YWxpZGF0ZSgnMS4wLXJjLjEnKTsgLy8gcmV0dXJuIGZhbHNlXG4gKiB2YWxpZGF0ZSgnZm9vJyk7IC8vIHJldHVybiBmYWxzZVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZSA9ICh2ZXJzaW9uKSA9PiB0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycgJiYgL15bdlxcZF0vLnRlc3QodmVyc2lvbikgJiYgc2VtdmVyLnRlc3QodmVyc2lvbik7XG4vKipcbiAqIENvbXBhcmUgW3NlbXZlcl0oaHR0cHM6Ly9zZW12ZXIub3JnLykgdmVyc2lvbiBzdHJpbmdzIHVzaW5nIHRoZSBzcGVjaWZpZWQgb3BlcmF0b3IuXG4gKlxuICogQHBhcmFtIHYxIEZpcnN0IHZlcnNpb24gdG8gY29tcGFyZVxuICogQHBhcmFtIHYyIFNlY29uZCB2ZXJzaW9uIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBvcGVyYXRvciBBbGxvd2VkIGFyaXRobWV0aWMgb3BlcmF0b3IgdG8gdXNlXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbXBhcmlzb24gYmV0d2VlbiB0aGUgZmlyc3RWZXJzaW9uIGFuZCB0aGUgc2Vjb25kVmVyc2lvbiBzYXRpc2ZpZXMgdGhlIG9wZXJhdG9yLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb21wYXJlKCcxMC4xLjgnLCAnMTAuMC40JywgJz4nKTsgLy8gcmV0dXJuIHRydWVcbiAqIGNvbXBhcmUoJzEwLjAuMScsICcxMC4wLjEnLCAnPScpOyAvLyByZXR1cm4gdHJ1ZVxuICogY29tcGFyZSgnMTAuMS4xJywgJzEwLjIuMicsICc8Jyk7IC8vIHJldHVybiB0cnVlXG4gKiBjb21wYXJlKCcxMC4xLjEnLCAnMTAuMi4yJywgJzw9Jyk7IC8vIHJldHVybiB0cnVlXG4gKiBjb21wYXJlKCcxMC4xLjEnLCAnMTAuMi4yJywgJz49Jyk7IC8vIHJldHVybiBmYWxzZVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wYXJlID0gKHYxLCB2Miwgb3BlcmF0b3IpID0+IHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dCBvcGVyYXRvclxuICAgIGFzc2VydFZhbGlkT3BlcmF0b3Iob3BlcmF0b3IpO1xuICAgIC8vIHNpbmNlIHJlc3VsdCBvZiBjb21wYXJlVmVyc2lvbnMgY2FuIG9ubHkgYmUgLTEgb3IgMCBvciAxXG4gICAgLy8gYSBzaW1wbGUgbWFwIGNhbiBiZSB1c2VkIHRvIHJlcGxhY2Ugc3dpdGNoXG4gICAgY29uc3QgcmVzID0gY29tcGFyZVZlcnNpb25zKHYxLCB2Mik7XG4gICAgcmV0dXJuIG9wZXJhdG9yUmVzTWFwW29wZXJhdG9yXS5pbmNsdWRlcyhyZXMpO1xufTtcbi8qKlxuICogTWF0Y2ggW25wbSBzZW12ZXJdKGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vY2xpL3Y2L3VzaW5nLW5wbS9zZW12ZXIpIHZlcnNpb24gcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gVmVyc2lvbiBudW1iZXIgdG8gbWF0Y2hcbiAqIEBwYXJhbSByYW5nZSBSYW5nZSBwYXR0ZXJuIGZvciB2ZXJzaW9uXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gbnVtYmVyIGlzIHdpdGhpbiB0aGUgcmFuZ2UsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIHNhdGlzZmllcygnMS4xLjAnLCAnXjEuMC4wJyk7IC8vIHJldHVybiB0cnVlXG4gKiBzYXRpc2ZpZXMoJzEuMS4wJywgJ34xLjAuMCcpOyAvLyByZXR1cm4gZmFsc2VcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlKSA9PiB7XG4gICAgLy8gaWYgbm8gcmFuZ2Ugb3BlcmF0b3IgdGhlbiBcIj1cIlxuICAgIGNvbnN0IG0gPSByYW5nZS5tYXRjaCgvXihbPD49fl5dKykvKTtcbiAgICBjb25zdCBvcCA9IG0gPyBtWzFdIDogJz0nO1xuICAgIC8vIGlmIGd0L2x0L2VxIHRoZW4gb3BlcmF0b3IgY29tcGFyZVxuICAgIGlmIChvcCAhPT0gJ14nICYmIG9wICE9PSAnficpXG4gICAgICAgIHJldHVybiBjb21wYXJlKHZlcnNpb24sIHJhbmdlLCBvcCk7XG4gICAgLy8gZWxzZSByYW5nZSBvZiBlaXRoZXIgXCJ+XCIgb3IgXCJeXCIgaXMgYXNzdW1lZFxuICAgIGNvbnN0IFt2MSwgdjIsIHYzLCAsIHZwXSA9IHZhbGlkYXRlQW5kUGFyc2UodmVyc2lvbik7XG4gICAgY29uc3QgW3IxLCByMiwgcjMsICwgcnBdID0gdmFsaWRhdGVBbmRQYXJzZShyYW5nZSk7XG4gICAgY29uc3QgdiA9IFt2MSwgdjIsIHYzXTtcbiAgICBjb25zdCByID0gW3IxLCByMiAhPT0gbnVsbCAmJiByMiAhPT0gdm9pZCAwID8gcjIgOiAneCcsIHIzICE9PSBudWxsICYmIHIzICE9PSB2b2lkIDAgPyByMyA6ICd4J107XG4gICAgLy8gdmFsaWRhdGUgcHJlLXJlbGVhc2VcbiAgICBpZiAocnApIHtcbiAgICAgICAgaWYgKCF2cClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNvbXBhcmVTZWdtZW50cyh2LCByKSAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNvbXBhcmVTZWdtZW50cyh2cC5zcGxpdCgnLicpLCBycC5zcGxpdCgnLicpKSA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGZpcnN0IG5vbi16ZXJvIG51bWJlclxuICAgIGNvbnN0IG5vblplcm8gPSByLmZpbmRJbmRleCgodikgPT4gdiAhPT0gJzAnKSArIDE7XG4gICAgLy8gcG9pbnRlciB0byB3aGVyZSBzZWdtZW50cyBjYW4gYmUgPj1cbiAgICBjb25zdCBpID0gb3AgPT09ICd+JyA/IDIgOiBub25aZXJvID4gMSA/IG5vblplcm8gOiAxO1xuICAgIC8vIGJlZm9yZSBwb2ludGVyIG11c3QgYmUgZXF1YWxcbiAgICBpZiAoY29tcGFyZVNlZ21lbnRzKHYuc2xpY2UoMCwgaSksIHIuc2xpY2UoMCwgaSkpICE9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWZ0ZXIgcG9pbnRlciBtdXN0IGJlID49XG4gICAgaWYgKGNvbXBhcmVTZWdtZW50cyh2LnNsaWNlKGkpLCByLnNsaWNlKGkpKSA9PT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBzZW12ZXIgPSAvXlt2Xn48Pj1dKj8oXFxkKykoPzpcXC4oW3gqXXxcXGQrKSg/OlxcLihbeCpdfFxcZCspKD86XFwuKFt4Kl18XFxkKykpPyg/Oi0oW1xcZGEtelxcLV0rKD86XFwuW1xcZGEtelxcLV0rKSopKT8oPzpcXCtbXFxkYS16XFwtXSsoPzpcXC5bXFxkYS16XFwtXSspKik/KT8pPyQvaTtcbmNvbnN0IHZhbGlkYXRlQW5kUGFyc2UgPSAodmVyc2lvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudCBleHBlY3RlZCBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHNlbXZlcik7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJndW1lbnQgbm90IHZhbGlkIHNlbXZlciAoJyR7dmVyc2lvbn0nIHJlY2VpdmVkKWApO1xuICAgIH1cbiAgICBtYXRjaC5zaGlmdCgpO1xuICAgIHJldHVybiBtYXRjaDtcbn07XG5jb25zdCBpc1dpbGRjYXJkID0gKHMpID0+IHMgPT09ICcqJyB8fCBzID09PSAneCcgfHwgcyA9PT0gJ1gnO1xuY29uc3QgdHJ5UGFyc2UgPSAodikgPT4ge1xuICAgIGNvbnN0IG4gPSBwYXJzZUludCh2LCAxMCk7XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdiA6IG47XG59O1xuY29uc3QgZm9yY2VUeXBlID0gKGEsIGIpID0+IHR5cGVvZiBhICE9PSB0eXBlb2YgYiA/IFtTdHJpbmcoYSksIFN0cmluZyhiKV0gOiBbYSwgYl07XG5jb25zdCBjb21wYXJlU3RyaW5ncyA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGlzV2lsZGNhcmQoYSkgfHwgaXNXaWxkY2FyZChiKSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgW2FwLCBicF0gPSBmb3JjZVR5cGUodHJ5UGFyc2UoYSksIHRyeVBhcnNlKGIpKTtcbiAgICBpZiAoYXAgPiBicClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGFwIDwgYnApXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBjb21wYXJlU2VnbWVudHMgPSAoYSwgYikgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHIgPSBjb21wYXJlU3RyaW5ncyhhW2ldIHx8ICcwJywgYltpXSB8fCAnMCcpO1xuICAgICAgICBpZiAociAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5jb25zdCBvcGVyYXRvclJlc01hcCA9IHtcbiAgICAnPic6IFsxXSxcbiAgICAnPj0nOiBbMCwgMV0sXG4gICAgJz0nOiBbMF0sXG4gICAgJzw9JzogWy0xLCAwXSxcbiAgICAnPCc6IFstMV0sXG59O1xuY29uc3QgYWxsb3dlZE9wZXJhdG9ycyA9IE9iamVjdC5rZXlzKG9wZXJhdG9yUmVzTWFwKTtcbmNvbnN0IGFzc2VydFZhbGlkT3BlcmF0b3IgPSAob3ApID0+IHtcbiAgICBpZiAodHlwZW9mIG9wICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yIHR5cGUsIGV4cGVjdGVkIHN0cmluZyBidXQgZ290ICR7dHlwZW9mIG9wfWApO1xuICAgIH1cbiAgICBpZiAoYWxsb3dlZE9wZXJhdG9ycy5pbmRleE9mKG9wKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9wZXJhdG9yLCBleHBlY3RlZCBvbmUgb2YgJHthbGxvd2VkT3BlcmF0b3JzLmpvaW4oJ3wnKX1gKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/compare-versions/lib/esm/index.js\n");

/***/ }),

/***/ "../../node_modules/jsc-safe-url/index.js":
/*!************************************************!*\
  !*** ../../node_modules/jsc-safe-url/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * These functions are for handling of query-string free URLs, necessitated\n * by query string stripping of URLs in JavaScriptCore stack traces\n * introduced in iOS 16.4.\n *\n * See https://github.com/facebook/react-native/issues/36794 for context.\n *\n * \n */\n// We use regex-based URL parsing as defined in RFC3986 because it's easier to\n// determine whether the input is a complete URI, a path-absolute or a\n// path-rootless (as defined in the spec), and be as faithful to the input as\n// possible. This will match any string, and does not imply validity.\n//\n// https://www.rfc-editor.org/rfc/rfc3986#appendix-B\nconst URI_REGEX = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\nfunction _rfc3986Parse(url\n/*:string */\n) {\n  const match = url.match(URI_REGEX);\n\n  if (match == null) {\n    throw new Error(\"Unexpected error - failed to regex-match URL\");\n  }\n\n  return {\n    schemeAndAuthority: (match[1] || \"\") + (match[3] || \"\"),\n    path: match[5] || \"\",\n    hasQueryPart: match[6] != null,\n    queryWithoutQuestionMark: match[7] || \"\",\n    fragmentWithHash: match[8] || \"\"\n  };\n}\n\nfunction isJscSafeUrl(url\n/*:string */\n)\n/*:boolean*/\n{\n  const parsedUrl = _rfc3986Parse(url);\n\n  return !parsedUrl.hasQueryPart;\n}\n/**\n * @param {string} urlToNormalize\n * @returns string\n */\n\n\nfunction toNormalUrl(urlToNormalize\n/*:string */\n)\n/*:string */\n{\n  const parsedUrl = _rfc3986Parse(urlToNormalize);\n\n  if (parsedUrl.path.indexOf(\"//&\") === -1) {\n    return urlToNormalize;\n  }\n\n  return parsedUrl.schemeAndAuthority + parsedUrl.path.replace(\"//&\", \"?\") + ( // We don't expect JSC urls to also have query strings, but interpret\n  // liberally and append them.\n  parsedUrl.queryWithoutQuestionMark.length > 0 ? \"&\" + parsedUrl.queryWithoutQuestionMark : \"\") + // Likewise, JSC URLs will usually have their fragments stripped, but\n  // preserve if we find one.\n  parsedUrl.fragmentWithHash;\n}\n/**\n * @param {string} urlToConvert\n * @returns string\n */\n\n\nfunction toJscSafeUrl(urlToConvert\n/*:string */\n)\n/*:string */\n{\n  if (!_rfc3986Parse(urlToConvert).hasQueryPart) {\n    return urlToConvert;\n  }\n\n  const parsedUrl = _rfc3986Parse(toNormalUrl(urlToConvert));\n\n  if (parsedUrl.queryWithoutQuestionMark.length > 0 && (parsedUrl.path === \"\" || parsedUrl.path === \"/\")) {\n    throw new Error(`The given URL \"${urlToConvert}\" has an empty path and cannot be converted to a JSC-safe format.`);\n  }\n\n  return parsedUrl.schemeAndAuthority + parsedUrl.path + (parsedUrl.queryWithoutQuestionMark.length > 0 ? \"//&\" + // Query strings may contain '?' (e.g. in key or value names) - these\n  // must be percent-encoded to form a valid path, and not be stripped.\n  parsedUrl.queryWithoutQuestionMark.replace(/\\?/g, \"%3F\") : \"\") + // We expect JSC to strip this - we don't handle fragments for now.\n  parsedUrl.fragmentWithHash;\n}\n\nmodule.exports = {\n  isJscSafeUrl,\n  toNormalUrl,\n  toJscSafeUrl\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy9qc2Mtc2FmZS11cmwvaW5kZXguanM/NjhkMiJdLCJuYW1lcyI6WyJVUklfUkVHRVgiLCJfcmZjMzk4NlBhcnNlIiwidXJsIiwibWF0Y2giLCJFcnJvciIsInNjaGVtZUFuZEF1dGhvcml0eSIsInBhdGgiLCJoYXNRdWVyeVBhcnQiLCJxdWVyeVdpdGhvdXRRdWVzdGlvbk1hcmsiLCJmcmFnbWVudFdpdGhIYXNoIiwiaXNKc2NTYWZlVXJsIiwicGFyc2VkVXJsIiwidG9Ob3JtYWxVcmwiLCJ1cmxUb05vcm1hbGl6ZSIsImluZGV4T2YiLCJyZXBsYWNlIiwibGVuZ3RoIiwidG9Kc2NTYWZlVXJsIiwidXJsVG9Db252ZXJ0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1BLFNBQVMsR0FBRyw2REFBbEI7O0FBRUEsU0FBU0MsYUFBVCxDQUF1QkM7QUFBSTtBQUEzQixFQUF5QztBQUN2QyxRQUFNQyxLQUFLLEdBQUdELEdBQUcsQ0FBQ0MsS0FBSixDQUFVSCxTQUFWLENBQWQ7O0FBQ0EsTUFBSUcsS0FBSyxJQUFJLElBQWIsRUFBbUI7QUFDakIsVUFBTSxJQUFJQyxLQUFKLENBQVUsOENBQVYsQ0FBTjtBQUNEOztBQUNELFNBQU87QUFDTEMsSUFBQUEsa0JBQWtCLEVBQUUsQ0FBQ0YsS0FBSyxDQUFDLENBQUQsQ0FBTCxJQUFZLEVBQWIsS0FBb0JBLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWSxFQUFoQyxDQURmO0FBRUxHLElBQUFBLElBQUksRUFBRUgsS0FBSyxDQUFDLENBQUQsQ0FBTCxJQUFZLEVBRmI7QUFHTEksSUFBQUEsWUFBWSxFQUFFSixLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVksSUFIckI7QUFJTEssSUFBQUEsd0JBQXdCLEVBQUVMLEtBQUssQ0FBQyxDQUFELENBQUwsSUFBWSxFQUpqQztBQUtMTSxJQUFBQSxnQkFBZ0IsRUFBRU4sS0FBSyxDQUFDLENBQUQsQ0FBTCxJQUFZO0FBTHpCLEdBQVA7QUFPRDs7QUFFRCxTQUFTTyxZQUFULENBQXNCUjtBQUFJO0FBQTFCO0FBQXdDO0FBQWE7QUFDbkQsUUFBTVMsU0FBUyxHQUFHVixhQUFhLENBQUNDLEdBQUQsQ0FBL0I7O0FBQ0EsU0FBTyxDQUFDUyxTQUFTLENBQUNKLFlBQWxCO0FBQ0Q7QUFFRDs7Ozs7O0FBSUEsU0FBU0ssV0FBVCxDQUFxQkM7QUFBZTtBQUFwQztBQUFrRDtBQUFhO0FBQzdELFFBQU1GLFNBQVMsR0FBR1YsYUFBYSxDQUFDWSxjQUFELENBQS9COztBQUNBLE1BQUlGLFNBQVMsQ0FBQ0wsSUFBVixDQUFlUSxPQUFmLENBQXVCLEtBQXZCLE1BQWtDLENBQUMsQ0FBdkMsRUFBMEM7QUFDeEMsV0FBT0QsY0FBUDtBQUNEOztBQUNELFNBQ0VGLFNBQVMsQ0FBQ04sa0JBQVYsR0FDQU0sU0FBUyxDQUFDTCxJQUFWLENBQWVTLE9BQWYsQ0FBdUIsS0FBdkIsRUFBOEIsR0FBOUIsQ0FEQSxLQUVBO0FBQ0E7QUFDQ0osRUFBQUEsU0FBUyxDQUFDSCx3QkFBVixDQUFtQ1EsTUFBbkMsR0FBNEMsQ0FBNUMsR0FDRyxNQUFNTCxTQUFTLENBQUNILHdCQURuQixHQUVHLEVBTkosSUFPQTtBQUNBO0FBQ0FHLEVBQUFBLFNBQVMsQ0FBQ0YsZ0JBVlo7QUFZRDtBQUVEOzs7Ozs7QUFJQSxTQUFTUSxZQUFULENBQXNCQztBQUFhO0FBQW5DO0FBQWlEO0FBQWE7QUFDNUQsTUFBSSxDQUFDakIsYUFBYSxDQUFDaUIsWUFBRCxDQUFiLENBQTRCWCxZQUFqQyxFQUErQztBQUM3QyxXQUFPVyxZQUFQO0FBQ0Q7O0FBQ0QsUUFBTVAsU0FBUyxHQUFHVixhQUFhLENBQUNXLFdBQVcsQ0FBQ00sWUFBRCxDQUFaLENBQS9COztBQUNBLE1BQ0VQLFNBQVMsQ0FBQ0gsd0JBQVYsQ0FBbUNRLE1BQW5DLEdBQTRDLENBQTVDLEtBQ0NMLFNBQVMsQ0FBQ0wsSUFBVixLQUFtQixFQUFuQixJQUF5QkssU0FBUyxDQUFDTCxJQUFWLEtBQW1CLEdBRDdDLENBREYsRUFHRTtBQUNBLFVBQU0sSUFBSUYsS0FBSixDQUNILGtCQUFpQmMsWUFBYSxtRUFEM0IsQ0FBTjtBQUdEOztBQUNELFNBQ0VQLFNBQVMsQ0FBQ04sa0JBQVYsR0FDQU0sU0FBUyxDQUFDTCxJQURWLElBRUNLLFNBQVMsQ0FBQ0gsd0JBQVYsQ0FBbUNRLE1BQW5DLEdBQTRDLENBQTVDLEdBQ0csUUFDQTtBQUNBO0FBQ0FMLEVBQUFBLFNBQVMsQ0FBQ0gsd0JBQVYsQ0FBbUNPLE9BQW5DLENBQTJDLEtBQTNDLEVBQWtELEtBQWxELENBSkgsR0FLRyxFQVBKLElBUUE7QUFDQUosRUFBQUEsU0FBUyxDQUFDRixnQkFWWjtBQVlEOztBQUVEVSxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDZlYsRUFBQUEsWUFEZTtBQUVmRSxFQUFBQSxXQUZlO0FBR2ZLLEVBQUFBO0FBSGUsQ0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgZm9yIGhhbmRsaW5nIG9mIHF1ZXJ5LXN0cmluZyBmcmVlIFVSTHMsIG5lY2Vzc2l0YXRlZFxuICogYnkgcXVlcnkgc3RyaW5nIHN0cmlwcGluZyBvZiBVUkxzIGluIEphdmFTY3JpcHRDb3JlIHN0YWNrIHRyYWNlc1xuICogaW50cm9kdWNlZCBpbiBpT1MgMTYuNC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9pc3N1ZXMvMzY3OTQgZm9yIGNvbnRleHQuXG4gKlxuICogQGZsb3cgc3RyaWN0XG4gKi9cblxuLy8gV2UgdXNlIHJlZ2V4LWJhc2VkIFVSTCBwYXJzaW5nIGFzIGRlZmluZWQgaW4gUkZDMzk4NiBiZWNhdXNlIGl0J3MgZWFzaWVyIHRvXG4vLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBjb21wbGV0ZSBVUkksIGEgcGF0aC1hYnNvbHV0ZSBvciBhXG4vLyBwYXRoLXJvb3RsZXNzIChhcyBkZWZpbmVkIGluIHRoZSBzcGVjKSwgYW5kIGJlIGFzIGZhaXRoZnVsIHRvIHRoZSBpbnB1dCBhc1xuLy8gcG9zc2libGUuIFRoaXMgd2lsbCBtYXRjaCBhbnkgc3RyaW5nLCBhbmQgZG9lcyBub3QgaW1wbHkgdmFsaWRpdHkuXG4vL1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzM5ODYjYXBwZW5kaXgtQlxuY29uc3QgVVJJX1JFR0VYID0gL14oKFteOi8/I10rKTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LztcblxuZnVuY3Rpb24gX3JmYzM5ODZQYXJzZSh1cmwgLyo6c3RyaW5nICovKSB7XG4gIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKFVSSV9SRUdFWCk7XG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlcnJvciAtIGZhaWxlZCB0byByZWdleC1tYXRjaCBVUkxcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWVBbmRBdXRob3JpdHk6IChtYXRjaFsxXSB8fCBcIlwiKSArIChtYXRjaFszXSB8fCBcIlwiKSxcbiAgICBwYXRoOiBtYXRjaFs1XSB8fCBcIlwiLFxuICAgIGhhc1F1ZXJ5UGFydDogbWF0Y2hbNl0gIT0gbnVsbCxcbiAgICBxdWVyeVdpdGhvdXRRdWVzdGlvbk1hcms6IG1hdGNoWzddIHx8IFwiXCIsXG4gICAgZnJhZ21lbnRXaXRoSGFzaDogbWF0Y2hbOF0gfHwgXCJcIixcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNKc2NTYWZlVXJsKHVybCAvKjpzdHJpbmcgKi8pIC8qOmJvb2xlYW4qLyB7XG4gIGNvbnN0IHBhcnNlZFVybCA9IF9yZmMzOTg2UGFyc2UodXJsKTtcbiAgcmV0dXJuICFwYXJzZWRVcmwuaGFzUXVlcnlQYXJ0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxUb05vcm1hbGl6ZVxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHRvTm9ybWFsVXJsKHVybFRvTm9ybWFsaXplIC8qOnN0cmluZyAqLykgLyo6c3RyaW5nICovIHtcbiAgY29uc3QgcGFyc2VkVXJsID0gX3JmYzM5ODZQYXJzZSh1cmxUb05vcm1hbGl6ZSk7XG4gIGlmIChwYXJzZWRVcmwucGF0aC5pbmRleE9mKFwiLy8mXCIpID09PSAtMSkge1xuICAgIHJldHVybiB1cmxUb05vcm1hbGl6ZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHBhcnNlZFVybC5zY2hlbWVBbmRBdXRob3JpdHkgK1xuICAgIHBhcnNlZFVybC5wYXRoLnJlcGxhY2UoXCIvLyZcIiwgXCI/XCIpICtcbiAgICAvLyBXZSBkb24ndCBleHBlY3QgSlNDIHVybHMgdG8gYWxzbyBoYXZlIHF1ZXJ5IHN0cmluZ3MsIGJ1dCBpbnRlcnByZXRcbiAgICAvLyBsaWJlcmFsbHkgYW5kIGFwcGVuZCB0aGVtLlxuICAgIChwYXJzZWRVcmwucXVlcnlXaXRob3V0UXVlc3Rpb25NYXJrLmxlbmd0aCA+IDBcbiAgICAgID8gXCImXCIgKyBwYXJzZWRVcmwucXVlcnlXaXRob3V0UXVlc3Rpb25NYXJrXG4gICAgICA6IFwiXCIpICtcbiAgICAvLyBMaWtld2lzZSwgSlNDIFVSTHMgd2lsbCB1c3VhbGx5IGhhdmUgdGhlaXIgZnJhZ21lbnRzIHN0cmlwcGVkLCBidXRcbiAgICAvLyBwcmVzZXJ2ZSBpZiB3ZSBmaW5kIG9uZS5cbiAgICBwYXJzZWRVcmwuZnJhZ21lbnRXaXRoSGFzaFxuICApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxUb0NvbnZlcnRcbiAqIEByZXR1cm5zIHN0cmluZ1xuICovXG5mdW5jdGlvbiB0b0pzY1NhZmVVcmwodXJsVG9Db252ZXJ0IC8qOnN0cmluZyAqLykgLyo6c3RyaW5nICovIHtcbiAgaWYgKCFfcmZjMzk4NlBhcnNlKHVybFRvQ29udmVydCkuaGFzUXVlcnlQYXJ0KSB7XG4gICAgcmV0dXJuIHVybFRvQ29udmVydDtcbiAgfVxuICBjb25zdCBwYXJzZWRVcmwgPSBfcmZjMzk4NlBhcnNlKHRvTm9ybWFsVXJsKHVybFRvQ29udmVydCkpO1xuICBpZiAoXG4gICAgcGFyc2VkVXJsLnF1ZXJ5V2l0aG91dFF1ZXN0aW9uTWFyay5sZW5ndGggPiAwICYmXG4gICAgKHBhcnNlZFVybC5wYXRoID09PSBcIlwiIHx8IHBhcnNlZFVybC5wYXRoID09PSBcIi9cIilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBnaXZlbiBVUkwgXCIke3VybFRvQ29udmVydH1cIiBoYXMgYW4gZW1wdHkgcGF0aCBhbmQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIEpTQy1zYWZlIGZvcm1hdC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHBhcnNlZFVybC5zY2hlbWVBbmRBdXRob3JpdHkgK1xuICAgIHBhcnNlZFVybC5wYXRoICtcbiAgICAocGFyc2VkVXJsLnF1ZXJ5V2l0aG91dFF1ZXN0aW9uTWFyay5sZW5ndGggPiAwXG4gICAgICA/IFwiLy8mXCIgK1xuICAgICAgICAvLyBRdWVyeSBzdHJpbmdzIG1heSBjb250YWluICc/JyAoZS5nLiBpbiBrZXkgb3IgdmFsdWUgbmFtZXMpIC0gdGhlc2VcbiAgICAgICAgLy8gbXVzdCBiZSBwZXJjZW50LWVuY29kZWQgdG8gZm9ybSBhIHZhbGlkIHBhdGgsIGFuZCBub3QgYmUgc3RyaXBwZWQuXG4gICAgICAgIHBhcnNlZFVybC5xdWVyeVdpdGhvdXRRdWVzdGlvbk1hcmsucmVwbGFjZSgvXFw/L2csIFwiJTNGXCIpXG4gICAgICA6IFwiXCIpICtcbiAgICAvLyBXZSBleHBlY3QgSlNDIHRvIHN0cmlwIHRoaXMgLSB3ZSBkb24ndCBoYW5kbGUgZnJhZ21lbnRzIGZvciBub3cuXG4gICAgcGFyc2VkVXJsLmZyYWdtZW50V2l0aEhhc2hcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzSnNjU2FmZVVybCxcbiAgdG9Ob3JtYWxVcmwsXG4gIHRvSnNjU2FmZVVybCxcbn07XG4iXSwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9qc2Mtc2FmZS11cmwvaW5kZXguanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/jsc-safe-url/index.js\n");

/***/ }),

/***/ "../../node_modules/lru-cache/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/lru-cache/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\n\n\nmodule.exports = LRUCache; // This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\n\nvar Map = __webpack_require__(/*! pseudomap */ \"../../node_modules/pseudomap/map.js\");\n\nvar util = __webpack_require__(/*! util */ \"util\"); // A linked list to keep track of recently-used-ness\n\n\nvar Yallist = __webpack_require__(/*! yallist */ \"../../node_modules/yallist/yallist.js\"); // use symbols if possible, otherwise just _props\n\n\nvar hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1';\nvar makeSymbol;\n\nif (hasSymbol) {\n  makeSymbol = function (key) {\n    return Symbol(key);\n  };\n} else {\n  makeSymbol = function (key) {\n    return '_' + key;\n  };\n}\n\nvar MAX = makeSymbol('max');\nvar LENGTH = makeSymbol('length');\nvar LENGTH_CALCULATOR = makeSymbol('lengthCalculator');\nvar ALLOW_STALE = makeSymbol('allowStale');\nvar MAX_AGE = makeSymbol('maxAge');\nvar DISPOSE = makeSymbol('dispose');\nvar NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet');\nvar LRU_LIST = makeSymbol('lruList');\nvar CACHE = makeSymbol('cache');\n\nfunction naiveLength() {\n  return 1;\n} // lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\n\n\nfunction LRUCache(options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options);\n  }\n\n  if (typeof options === 'number') {\n    options = {\n      max: options\n    };\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  var max = this[MAX] = options.max; // Kind of weird to have a default max of Infinity, but oh well.\n\n  if (!max || !(typeof max === 'number') || max <= 0) {\n    this[MAX] = Infinity;\n  }\n\n  var lc = options.length || naiveLength;\n\n  if (typeof lc !== 'function') {\n    lc = naiveLength;\n  }\n\n  this[LENGTH_CALCULATOR] = lc;\n  this[ALLOW_STALE] = options.stale || false;\n  this[MAX_AGE] = options.maxAge || 0;\n  this[DISPOSE] = options.dispose;\n  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n  this.reset();\n} // resize the cache when the max changes.\n\n\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function (mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity;\n    }\n\n    this[MAX] = mL;\n    trim(this);\n  },\n  get: function () {\n    return this[MAX];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function (allowStale) {\n    this[ALLOW_STALE] = !!allowStale;\n  },\n  get: function () {\n    return this[ALLOW_STALE];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function (mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0;\n    }\n\n    this[MAX_AGE] = mA;\n    trim(this);\n  },\n  get: function () {\n    return this[MAX_AGE];\n  },\n  enumerable: true\n}); // resize the cache when the lengthCalculator changes.\n\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function (lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength;\n    }\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC;\n      this[LENGTH] = 0;\n      this[LRU_LIST].forEach(function (hit) {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n        this[LENGTH] += hit.length;\n      }, this);\n    }\n\n    trim(this);\n  },\n  get: function () {\n    return this[LENGTH_CALCULATOR];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function () {\n    return this[LENGTH];\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function () {\n    return this[LRU_LIST].length;\n  },\n  enumerable: true\n});\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this[LRU_LIST].tail; walker !== null;) {\n    var prev = walker.prev;\n    forEachStep(this, fn, walker, thisp);\n    walker = prev;\n  }\n};\n\nfunction forEachStep(self, fn, node, thisp) {\n  var hit = node.value;\n\n  if (isStale(self, hit)) {\n    del(self, node);\n\n    if (!self[ALLOW_STALE]) {\n      hit = undefined;\n    }\n  }\n\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self);\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this[LRU_LIST].head; walker !== null;) {\n    var next = walker.next;\n    forEachStep(this, fn, walker, thisp);\n    walker = next;\n  }\n};\n\nLRUCache.prototype.keys = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.key;\n  }, this);\n};\n\nLRUCache.prototype.values = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.value;\n  }, this);\n};\n\nLRUCache.prototype.reset = function () {\n  if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n    this[LRU_LIST].forEach(function (hit) {\n      this[DISPOSE](hit.key, hit.value);\n    }, this);\n  }\n\n  this[CACHE] = new Map(); // hash of items by key\n\n  this[LRU_LIST] = new Yallist(); // list of items in order of use recency\n\n  this[LENGTH] = 0; // length of items in the list\n};\n\nLRUCache.prototype.dump = function () {\n  return this[LRU_LIST].map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      };\n    }\n  }, this).toArray().filter(function (h) {\n    return h;\n  });\n};\n\nLRUCache.prototype.dumpLru = function () {\n  return this[LRU_LIST];\n};\n/* istanbul ignore next */\n\n\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {';\n  var extras = false;\n  var as = this[ALLOW_STALE];\n\n  if (as) {\n    str += '\\n  allowStale: true';\n    extras = true;\n  }\n\n  var max = this[MAX];\n\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  max: ' + util.inspect(max, opts);\n    extras = true;\n  }\n\n  var maxAge = this[MAX_AGE];\n\n  if (maxAge) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts);\n    extras = true;\n  }\n\n  var lc = this[LENGTH_CALCULATOR];\n\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ',';\n    }\n\n    str += '\\n  length: ' + util.inspect(this[LENGTH], opts);\n    extras = true;\n  }\n\n  var didFirst = false;\n  this[LRU_LIST].forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  ';\n    } else {\n      if (extras) {\n        str += ',\\n';\n      }\n\n      didFirst = true;\n      str += '\\n  ';\n    }\n\n    var key = util.inspect(item.key).split('\\n').join('\\n  ');\n    var val = {\n      value: item.value\n    };\n\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge;\n    }\n\n    if (lc !== naiveLength) {\n      val.length = item.length;\n    }\n\n    if (isStale(this, item)) {\n      val.stale = true;\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ');\n    str += key + ' => ' + val;\n  });\n\n  if (didFirst || extras) {\n    str += '\\n';\n  }\n\n  str += '}';\n  return str;\n};\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this[MAX_AGE];\n  var now = maxAge ? Date.now() : 0;\n  var len = this[LENGTH_CALCULATOR](value, key);\n\n  if (this[CACHE].has(key)) {\n    if (len > this[MAX]) {\n      del(this, this[CACHE].get(key));\n      return false;\n    }\n\n    var node = this[CACHE].get(key);\n    var item = node.value; // dispose of the old one before overwriting\n    // split out into 2 ifs for better coverage tracking\n\n    if (this[DISPOSE]) {\n      if (!this[NO_DISPOSE_ON_SET]) {\n        this[DISPOSE](key, item.value);\n      }\n    }\n\n    item.now = now;\n    item.maxAge = maxAge;\n    item.value = value;\n    this[LENGTH] += len - item.length;\n    item.length = len;\n    this.get(key);\n    trim(this);\n    return true;\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.\n\n  if (hit.length > this[MAX]) {\n    if (this[DISPOSE]) {\n      this[DISPOSE](key, value);\n    }\n\n    return false;\n  }\n\n  this[LENGTH] += hit.length;\n  this[LRU_LIST].unshift(hit);\n  this[CACHE].set(key, this[LRU_LIST].head);\n  trim(this);\n  return true;\n};\n\nLRUCache.prototype.has = function (key) {\n  if (!this[CACHE].has(key)) return false;\n  var hit = this[CACHE].get(key).value;\n\n  if (isStale(this, hit)) {\n    return false;\n  }\n\n  return true;\n};\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true);\n};\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false);\n};\n\nLRUCache.prototype.pop = function () {\n  var node = this[LRU_LIST].tail;\n  if (!node) return null;\n  del(this, node);\n  return node.value;\n};\n\nLRUCache.prototype.del = function (key) {\n  del(this, this[CACHE].get(key));\n};\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset();\n  var now = Date.now(); // A previous serialized cache has the most recent items first\n\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l];\n    var expiresAt = hit.e || 0;\n\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v);\n    } else {\n      var maxAge = expiresAt - now; // dont add already expired items\n\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge);\n      }\n    }\n  }\n};\n\nLRUCache.prototype.prune = function () {\n  var self = this;\n  this[CACHE].forEach(function (value, key) {\n    get(self, key, false);\n  });\n};\n\nfunction get(self, key, doUse) {\n  var node = self[CACHE].get(key);\n\n  if (node) {\n    var hit = node.value;\n\n    if (isStale(self, hit)) {\n      del(self, node);\n      if (!self[ALLOW_STALE]) hit = undefined;\n    } else {\n      if (doUse) {\n        self[LRU_LIST].unshiftNode(node);\n      }\n    }\n\n    if (hit) hit = hit.value;\n  }\n\n  return hit;\n}\n\nfunction isStale(self, hit) {\n  if (!hit || !hit.maxAge && !self[MAX_AGE]) {\n    return false;\n  }\n\n  var stale = false;\n  var diff = Date.now() - hit.now;\n\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge;\n  } else {\n    stale = self[MAX_AGE] && diff > self[MAX_AGE];\n  }\n\n  return stale;\n}\n\nfunction trim(self) {\n  if (self[LENGTH] > self[MAX]) {\n    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev;\n      del(self, walker);\n      walker = prev;\n    }\n  }\n}\n\nfunction del(self, node) {\n  if (node) {\n    var hit = node.value;\n\n    if (self[DISPOSE]) {\n      self[DISPOSE](hit.key, hit.value);\n    }\n\n    self[LENGTH] -= hit.length;\n    self[CACHE].delete(hit.key);\n    self[LRU_LIST].removeNode(node);\n  }\n} // classy, since V8 prefers predictable objects.\n\n\nfunction Entry(key, value, length, now, maxAge) {\n  this.key = key;\n  this.value = value;\n  this.length = length;\n  this.now = now;\n  this.maxAge = maxAge || 0;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7QUFHQTs7QUFDQTs7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFHQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBOztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFoQkE7QUFtQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUZBOztBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanM/OTA4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuXG4vLyBUaGlzIHdpbGwgYmUgYSBwcm9wZXIgaXRlcmFibGUgJ01hcCcgaW4gZW5naW5lcyB0aGF0IHN1cHBvcnQgaXQsXG4vLyBvciBhIGZha2V5LWZha2UgUHNldWRvTWFwIGluIG9sZGVyIHZlcnNpb25zLlxudmFyIE1hcCA9IHJlcXVpcmUoJ3BzZXVkb21hcCcpXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG52YXIgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuXG4vLyB1c2Ugc3ltYm9scyBpZiBwb3NzaWJsZSwgb3RoZXJ3aXNlIGp1c3QgX3Byb3BzXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9jZXNzLmVudi5fbm9kZUxSVUNhY2hlRm9yY2VOb1N5bWJvbCAhPT0gJzEnXG52YXIgbWFrZVN5bWJvbFxuaWYgKGhhc1N5bWJvbCkge1xuICBtYWtlU3ltYm9sID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBTeW1ib2woa2V5KVxuICB9XG59IGVsc2Uge1xuICBtYWtlU3ltYm9sID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAnXycgKyBrZXlcbiAgfVxufVxuXG52YXIgTUFYID0gbWFrZVN5bWJvbCgnbWF4JylcbnZhciBMRU5HVEggPSBtYWtlU3ltYm9sKCdsZW5ndGgnKVxudmFyIExFTkdUSF9DQUxDVUxBVE9SID0gbWFrZVN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpXG52YXIgQUxMT1dfU1RBTEUgPSBtYWtlU3ltYm9sKCdhbGxvd1N0YWxlJylcbnZhciBNQVhfQUdFID0gbWFrZVN5bWJvbCgnbWF4QWdlJylcbnZhciBESVNQT1NFID0gbWFrZVN5bWJvbCgnZGlzcG9zZScpXG52YXIgTk9fRElTUE9TRV9PTl9TRVQgPSBtYWtlU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG52YXIgTFJVX0xJU1QgPSBtYWtlU3ltYm9sKCdscnVMaXN0JylcbnZhciBDQUNIRSA9IG1ha2VTeW1ib2woJ2NhY2hlJylcblxuZnVuY3Rpb24gbmFpdmVMZW5ndGggKCkgeyByZXR1cm4gMSB9XG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuZnVuY3Rpb24gTFJVQ2FjaGUgKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExSVUNhY2hlKSkge1xuICAgIHJldHVybiBuZXcgTFJVQ2FjaGUob3B0aW9ucylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB2YXIgbWF4ID0gdGhpc1tNQVhdID0gb3B0aW9ucy5tYXhcbiAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICBpZiAoIW1heCB8fFxuICAgICAgISh0eXBlb2YgbWF4ID09PSAnbnVtYmVyJykgfHxcbiAgICAgIG1heCA8PSAwKSB7XG4gICAgdGhpc1tNQVhdID0gSW5maW5pdHlcbiAgfVxuXG4gIHZhciBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gIGlmICh0eXBlb2YgbGMgIT09ICdmdW5jdGlvbicpIHtcbiAgICBsYyA9IG5haXZlTGVuZ3RoXG4gIH1cbiAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsY1xuXG4gIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlXG4gIHRoaXNbTk9fRElTUE9TRV9PTl9TRVRdID0gb3B0aW9ucy5ub0Rpc3Bvc2VPblNldCB8fCBmYWxzZVxuICB0aGlzLnJlc2V0KClcbn1cblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdtYXgnLCB7XG4gIHNldDogZnVuY3Rpb24gKG1MKSB7XG4gICAgaWYgKCFtTCB8fCAhKHR5cGVvZiBtTCA9PT0gJ251bWJlcicpIHx8IG1MIDw9IDApIHtcbiAgICAgIG1MID0gSW5maW5pdHlcbiAgICB9XG4gICAgdGhpc1tNQVhdID0gbUxcbiAgICB0cmltKHRoaXMpXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ2FsbG93U3RhbGUnLCB7XG4gIHNldDogZnVuY3Rpb24gKGFsbG93U3RhbGUpIHtcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9ICEhYWxsb3dTdGFsZVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV1cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ21heEFnZScsIHtcbiAgc2V0OiBmdW5jdGlvbiAobUEpIHtcbiAgICBpZiAoIW1BIHx8ICEodHlwZW9mIG1BID09PSAnbnVtYmVyJykgfHwgbUEgPCAwKSB7XG4gICAgICBtQSA9IDBcbiAgICB9XG4gICAgdGhpc1tNQVhfQUdFXSA9IG1BXG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG4vLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIGxlbmd0aENhbGN1bGF0b3IgY2hhbmdlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdsZW5ndGhDYWxjdWxhdG9yJywge1xuICBzZXQ6IGZ1bmN0aW9uIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxDID0gbmFpdmVMZW5ndGhcbiAgICB9XG4gICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSBsQ1xuICAgICAgdGhpc1tMRU5HVEhdID0gMFxuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChmdW5jdGlvbiAoaGl0KSB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9LCB0aGlzKVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF0gfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ2l0ZW1Db3VudCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuTFJVQ2FjaGUucHJvdG90eXBlLnJmb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0udGFpbDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICB3YWxrZXIgPSBwcmV2XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaFN0ZXAgKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkge1xuICB2YXIgaGl0ID0gbm9kZS52YWx1ZVxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSkge1xuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG4gIGlmIChoaXQpIHtcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgdmFyIG5leHQgPSB3YWxrZXIubmV4dFxuICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgIHdhbGtlciA9IG5leHRcbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gay5rZXlcbiAgfSwgdGhpcylcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gay52YWx1ZVxuICB9LCB0aGlzKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICB0aGlzW0xSVV9MSVNUXSAmJlxuICAgICAgdGhpc1tMUlVfTElTVF0ubGVuZ3RoKSB7XG4gICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChmdW5jdGlvbiAoaGl0KSB7XG4gICAgICB0aGlzW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgdGhpc1tDQUNIRV0gPSBuZXcgTWFwKCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgdGhpc1tMRU5HVEhdID0gMCAvLyBsZW5ndGggb2YgaXRlbXMgaW4gdGhlIGxpc3Rcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS5tYXAoZnVuY3Rpb24gKGhpdCkge1xuICAgIGlmICghaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcykudG9BcnJheSgpLmZpbHRlcihmdW5jdGlvbiAoaCkge1xuICAgIHJldHVybiBoXG4gIH0pXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wTHJ1ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKG4sIG9wdHMpIHtcbiAgdmFyIHN0ciA9ICdMUlVDYWNoZSB7J1xuICB2YXIgZXh0cmFzID0gZmFsc2VcblxuICB2YXIgYXMgPSB0aGlzW0FMTE9XX1NUQUxFXVxuICBpZiAoYXMpIHtcbiAgICBzdHIgKz0gJ1xcbiAgYWxsb3dTdGFsZTogdHJ1ZSdcbiAgICBleHRyYXMgPSB0cnVlXG4gIH1cblxuICB2YXIgbWF4ID0gdGhpc1tNQVhdXG4gIGlmIChtYXggJiYgbWF4ICE9PSBJbmZpbml0eSkge1xuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIHN0ciArPSAnLCdcbiAgICB9XG4gICAgc3RyICs9ICdcXG4gIG1heDogJyArIHV0aWwuaW5zcGVjdChtYXgsIG9wdHMpXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIG1heEFnZSA9IHRoaXNbTUFYX0FHRV1cbiAgaWYgKG1heEFnZSkge1xuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIHN0ciArPSAnLCdcbiAgICB9XG4gICAgc3RyICs9ICdcXG4gIG1heEFnZTogJyArIHV0aWwuaW5zcGVjdChtYXhBZ2UsIG9wdHMpXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGxjID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl1cbiAgaWYgKGxjICYmIGxjICE9PSBuYWl2ZUxlbmd0aCkge1xuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIHN0ciArPSAnLCdcbiAgICB9XG4gICAgc3RyICs9ICdcXG4gIGxlbmd0aDogJyArIHV0aWwuaW5zcGVjdCh0aGlzW0xFTkdUSF0sIG9wdHMpXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGRpZEZpcnN0ID0gZmFsc2VcbiAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChkaWRGaXJzdCkge1xuICAgICAgc3RyICs9ICcsXFxuICAnXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChleHRyYXMpIHtcbiAgICAgICAgc3RyICs9ICcsXFxuJ1xuICAgICAgfVxuICAgICAgZGlkRmlyc3QgPSB0cnVlXG4gICAgICBzdHIgKz0gJ1xcbiAgJ1xuICAgIH1cbiAgICB2YXIga2V5ID0gdXRpbC5pbnNwZWN0KGl0ZW0ua2V5KS5zcGxpdCgnXFxuJykuam9pbignXFxuICAnKVxuICAgIHZhciB2YWwgPSB7IHZhbHVlOiBpdGVtLnZhbHVlIH1cbiAgICBpZiAoaXRlbS5tYXhBZ2UgIT09IG1heEFnZSkge1xuICAgICAgdmFsLm1heEFnZSA9IGl0ZW0ubWF4QWdlXG4gICAgfVxuICAgIGlmIChsYyAhPT0gbmFpdmVMZW5ndGgpIHtcbiAgICAgIHZhbC5sZW5ndGggPSBpdGVtLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoaXNTdGFsZSh0aGlzLCBpdGVtKSkge1xuICAgICAgdmFsLnN0YWxlID0gdHJ1ZVxuICAgIH1cblxuICAgIHZhbCA9IHV0aWwuaW5zcGVjdCh2YWwsIG9wdHMpLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4gICcpXG4gICAgc3RyICs9IGtleSArICcgPT4gJyArIHZhbFxuICB9KVxuXG4gIGlmIChkaWRGaXJzdCB8fCBleHRyYXMpIHtcbiAgICBzdHIgKz0gJ1xcbidcbiAgfVxuICBzdHIgKz0gJ30nXG5cbiAgcmV0dXJuIHN0clxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpc1tNQVhfQUdFXVxuXG4gIHZhciBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICB2YXIgbGVuID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0odmFsdWUsIGtleSlcblxuICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICBpZiAobGVuID4gdGhpc1tNQVhdKSB7XG4gICAgICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgdmFyIGl0ZW0gPSBub2RlLnZhbHVlXG5cbiAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgIC8vIHNwbGl0IG91dCBpbnRvIDIgaWZzIGZvciBiZXR0ZXIgY292ZXJhZ2UgdHJhY2tpbmdcbiAgICBpZiAodGhpc1tESVNQT1NFXSkge1xuICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSkge1xuICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpdGVtLm5vdyA9IG5vd1xuICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgaXRlbS52YWx1ZSA9IHZhbHVlXG4gICAgdGhpc1tMRU5HVEhdICs9IGxlbiAtIGl0ZW0ubGVuZ3RoXG4gICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICB0aGlzLmdldChrZXkpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgaWYgKGhpdC5sZW5ndGggPiB0aGlzW01BWF0pIHtcbiAgICBpZiAodGhpc1tESVNQT1NFXSkge1xuICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICB0aGlzW0NBQ0hFXS5zZXQoa2V5LCB0aGlzW0xSVV9MSVNUXS5oZWFkKVxuICB0cmltKHRoaXMpXG4gIHJldHVybiB0cnVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICB2YXIgaGl0ID0gdGhpc1tDQUNIRV0uZ2V0KGtleSkudmFsdWVcbiAgaWYgKGlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBnZXQodGhpcywga2V5LCB0cnVlKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGdldCh0aGlzLCBrZXksIGZhbHNlKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IHRoaXNbTFJVX0xJU1RdLnRhaWxcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbFxuICBkZWwodGhpcywgbm9kZSlcbiAgcmV0dXJuIG5vZGUudmFsdWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgLy8gcmVzZXQgdGhlIGNhY2hlXG4gIHRoaXMucmVzZXQoKVxuXG4gIHZhciBub3cgPSBEYXRlLm5vdygpXG4gIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gIGZvciAodmFyIGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICB2YXIgaGl0ID0gYXJyW2xdXG4gICAgdmFyIGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICBpZiAoZXhwaXJlc0F0ID09PSAwKSB7XG4gICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucHJ1bmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzW0NBQ0hFXS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgZ2V0KHNlbGYsIGtleSwgZmFsc2UpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldCAoc2VsZiwga2V5LCBkb1VzZSkge1xuICB2YXIgbm9kZSA9IHNlbGZbQ0FDSEVdLmdldChrZXkpXG4gIGlmIChub2RlKSB7XG4gICAgdmFyIGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pIGhpdCA9IHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHtcbiAgICAgICAgc2VsZltMUlVfTElTVF0udW5zaGlmdE5vZGUobm9kZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhpdCkgaGl0ID0gaGl0LnZhbHVlXG4gIH1cbiAgcmV0dXJuIGhpdFxufVxuXG5mdW5jdGlvbiBpc1N0YWxlIChzZWxmLCBoaXQpIHtcbiAgaWYgKCFoaXQgfHwgKCFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBzdGFsZSA9IGZhbHNlXG4gIHZhciBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3dcbiAgaWYgKGhpdC5tYXhBZ2UpIHtcbiAgICBzdGFsZSA9IGRpZmYgPiBoaXQubWF4QWdlXG4gIH0gZWxzZSB7XG4gICAgc3RhbGUgPSBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbiAgfVxuICByZXR1cm4gc3RhbGVcbn1cblxuZnVuY3Rpb24gdHJpbSAoc2VsZikge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yICh2YXIgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGRlbChzZWxmLCB3YWxrZXIpXG4gICAgICB3YWxrZXIgPSBwcmV2XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlbCAoc2VsZiwgbm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pIHtcbiAgICAgIHNlbGZbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKVxuICAgIH1cbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aFxuICAgIHNlbGZbQ0FDSEVdLmRlbGV0ZShoaXQua2V5KVxuICAgIHNlbGZbTFJVX0xJU1RdLnJlbW92ZU5vZGUobm9kZSlcbiAgfVxufVxuXG4vLyBjbGFzc3ksIHNpbmNlIFY4IHByZWZlcnMgcHJlZGljdGFibGUgb2JqZWN0cy5cbmZ1bmN0aW9uIEVudHJ5IChrZXksIHZhbHVlLCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gIHRoaXMua2V5ID0ga2V5XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICB0aGlzLm5vdyA9IG5vd1xuICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/lru-cache/index.js\n");

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!*********************************************!*\
  !*** ../../node_modules/process/browser.js ***!
  \*********************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanM/MTdhZCJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImFyZ3VtZW50cyIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsIm5hbWUiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJQSxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixFQUEvQixDLENBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUMsZ0JBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtBQUN4QixRQUFNLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0FBQ0g7O0FBQ0QsU0FBU0MsbUJBQVQsR0FBZ0M7QUFDNUIsUUFBTSxJQUFJRCxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNIOztBQUNBLGFBQVk7QUFDVCxNQUFJO0FBQ0EsUUFBSSxPQUFPRSxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ2xDTCxNQUFBQSxnQkFBZ0IsR0FBR0ssVUFBbkI7QUFDSCxLQUZELE1BRU87QUFDSEwsTUFBQUEsZ0JBQWdCLEdBQUdFLGdCQUFuQjtBQUNIO0FBQ0osR0FORCxDQU1FLE9BQU9JLENBQVAsRUFBVTtBQUNSTixJQUFBQSxnQkFBZ0IsR0FBR0UsZ0JBQW5CO0FBQ0g7O0FBQ0QsTUFBSTtBQUNBLFFBQUksT0FBT0ssWUFBUCxLQUF3QixVQUE1QixFQUF3QztBQUNwQ04sTUFBQUEsa0JBQWtCLEdBQUdNLFlBQXJCO0FBQ0gsS0FGRCxNQUVPO0FBQ0hOLE1BQUFBLGtCQUFrQixHQUFHRyxtQkFBckI7QUFDSDtBQUNKLEdBTkQsQ0FNRSxPQUFPRSxDQUFQLEVBQVU7QUFDUkwsSUFBQUEsa0JBQWtCLEdBQUdHLG1CQUFyQjtBQUNIO0FBQ0osQ0FuQkEsR0FBRDs7QUFvQkEsU0FBU0ksVUFBVCxDQUFvQkMsR0FBcEIsRUFBeUI7QUFDckIsTUFBSVQsZ0JBQWdCLEtBQUtLLFVBQXpCLEVBQXFDO0FBQ2pDO0FBQ0EsV0FBT0EsVUFBVSxDQUFDSSxHQUFELEVBQU0sQ0FBTixDQUFqQjtBQUNILEdBSm9CLENBS3JCOzs7QUFDQSxNQUFJLENBQUNULGdCQUFnQixLQUFLRSxnQkFBckIsSUFBeUMsQ0FBQ0YsZ0JBQTNDLEtBQWdFSyxVQUFwRSxFQUFnRjtBQUM1RUwsSUFBQUEsZ0JBQWdCLEdBQUdLLFVBQW5CO0FBQ0EsV0FBT0EsVUFBVSxDQUFDSSxHQUFELEVBQU0sQ0FBTixDQUFqQjtBQUNIOztBQUNELE1BQUk7QUFDQTtBQUNBLFdBQU9ULGdCQUFnQixDQUFDUyxHQUFELEVBQU0sQ0FBTixDQUF2QjtBQUNILEdBSEQsQ0FHRSxPQUFNSCxDQUFOLEVBQVE7QUFDTixRQUFJO0FBQ0E7QUFDQSxhQUFPTixnQkFBZ0IsQ0FBQ1UsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEJELEdBQTVCLEVBQWlDLENBQWpDLENBQVA7QUFDSCxLQUhELENBR0UsT0FBTUgsQ0FBTixFQUFRO0FBQ047QUFDQSxhQUFPTixnQkFBZ0IsQ0FBQ1UsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEJELEdBQTVCLEVBQWlDLENBQWpDLENBQVA7QUFDSDtBQUNKO0FBR0o7O0FBQ0QsU0FBU0UsZUFBVCxDQUF5QkMsTUFBekIsRUFBaUM7QUFDN0IsTUFBSVgsa0JBQWtCLEtBQUtNLFlBQTNCLEVBQXlDO0FBQ3JDO0FBQ0EsV0FBT0EsWUFBWSxDQUFDSyxNQUFELENBQW5CO0FBQ0gsR0FKNEIsQ0FLN0I7OztBQUNBLE1BQUksQ0FBQ1gsa0JBQWtCLEtBQUtHLG1CQUF2QixJQUE4QyxDQUFDSCxrQkFBaEQsS0FBdUVNLFlBQTNFLEVBQXlGO0FBQ3JGTixJQUFBQSxrQkFBa0IsR0FBR00sWUFBckI7QUFDQSxXQUFPQSxZQUFZLENBQUNLLE1BQUQsQ0FBbkI7QUFDSDs7QUFDRCxNQUFJO0FBQ0E7QUFDQSxXQUFPWCxrQkFBa0IsQ0FBQ1csTUFBRCxDQUF6QjtBQUNILEdBSEQsQ0FHRSxPQUFPTixDQUFQLEVBQVM7QUFDUCxRQUFJO0FBQ0E7QUFDQSxhQUFPTCxrQkFBa0IsQ0FBQ1MsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJFLE1BQTlCLENBQVA7QUFDSCxLQUhELENBR0UsT0FBT04sQ0FBUCxFQUFTO0FBQ1A7QUFDQTtBQUNBLGFBQU9MLGtCQUFrQixDQUFDUyxJQUFuQixDQUF3QixJQUF4QixFQUE4QkUsTUFBOUIsQ0FBUDtBQUNIO0FBQ0o7QUFJSjs7QUFDRCxJQUFJQyxLQUFLLEdBQUcsRUFBWjtBQUNBLElBQUlDLFFBQVEsR0FBRyxLQUFmO0FBQ0EsSUFBSUMsWUFBSjtBQUNBLElBQUlDLFVBQVUsR0FBRyxDQUFDLENBQWxCOztBQUVBLFNBQVNDLGVBQVQsR0FBMkI7QUFDdkIsTUFBSSxDQUFDSCxRQUFELElBQWEsQ0FBQ0MsWUFBbEIsRUFBZ0M7QUFDNUI7QUFDSDs7QUFDREQsRUFBQUEsUUFBUSxHQUFHLEtBQVg7O0FBQ0EsTUFBSUMsWUFBWSxDQUFDRyxNQUFqQixFQUF5QjtBQUNyQkwsSUFBQUEsS0FBSyxHQUFHRSxZQUFZLENBQUNJLE1BQWIsQ0FBb0JOLEtBQXBCLENBQVI7QUFDSCxHQUZELE1BRU87QUFDSEcsSUFBQUEsVUFBVSxHQUFHLENBQUMsQ0FBZDtBQUNIOztBQUNELE1BQUlILEtBQUssQ0FBQ0ssTUFBVixFQUFrQjtBQUNkRSxJQUFBQSxVQUFVO0FBQ2I7QUFDSjs7QUFFRCxTQUFTQSxVQUFULEdBQXNCO0FBQ2xCLE1BQUlOLFFBQUosRUFBYztBQUNWO0FBQ0g7O0FBQ0QsTUFBSU8sT0FBTyxHQUFHYixVQUFVLENBQUNTLGVBQUQsQ0FBeEI7QUFDQUgsRUFBQUEsUUFBUSxHQUFHLElBQVg7QUFFQSxNQUFJUSxHQUFHLEdBQUdULEtBQUssQ0FBQ0ssTUFBaEI7O0FBQ0EsU0FBTUksR0FBTixFQUFXO0FBQ1BQLElBQUFBLFlBQVksR0FBR0YsS0FBZjtBQUNBQSxJQUFBQSxLQUFLLEdBQUcsRUFBUjs7QUFDQSxXQUFPLEVBQUVHLFVBQUYsR0FBZU0sR0FBdEIsRUFBMkI7QUFDdkIsVUFBSVAsWUFBSixFQUFrQjtBQUNkQSxRQUFBQSxZQUFZLENBQUNDLFVBQUQsQ0FBWixDQUF5Qk8sR0FBekI7QUFDSDtBQUNKOztBQUNEUCxJQUFBQSxVQUFVLEdBQUcsQ0FBQyxDQUFkO0FBQ0FNLElBQUFBLEdBQUcsR0FBR1QsS0FBSyxDQUFDSyxNQUFaO0FBQ0g7O0FBQ0RILEVBQUFBLFlBQVksR0FBRyxJQUFmO0FBQ0FELEVBQUFBLFFBQVEsR0FBRyxLQUFYO0FBQ0FILEVBQUFBLGVBQWUsQ0FBQ1UsT0FBRCxDQUFmO0FBQ0g7O0FBRUR4QixPQUFPLENBQUMyQixRQUFSLEdBQW1CLFVBQVVmLEdBQVYsRUFBZTtBQUM5QixNQUFJZ0IsSUFBSSxHQUFHLElBQUlDLEtBQUosQ0FBVUMsU0FBUyxDQUFDVCxNQUFWLEdBQW1CLENBQTdCLENBQVg7O0FBQ0EsTUFBSVMsU0FBUyxDQUFDVCxNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3RCLFNBQUssSUFBSVUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsU0FBUyxDQUFDVCxNQUE5QixFQUFzQ1UsQ0FBQyxFQUF2QyxFQUEyQztBQUN2Q0gsTUFBQUEsSUFBSSxDQUFDRyxDQUFDLEdBQUcsQ0FBTCxDQUFKLEdBQWNELFNBQVMsQ0FBQ0MsQ0FBRCxDQUF2QjtBQUNIO0FBQ0o7O0FBQ0RmLEVBQUFBLEtBQUssQ0FBQ2dCLElBQU4sQ0FBVyxJQUFJQyxJQUFKLENBQVNyQixHQUFULEVBQWNnQixJQUFkLENBQVg7O0FBQ0EsTUFBSVosS0FBSyxDQUFDSyxNQUFOLEtBQWlCLENBQWpCLElBQXNCLENBQUNKLFFBQTNCLEVBQXFDO0FBQ2pDTixJQUFBQSxVQUFVLENBQUNZLFVBQUQsQ0FBVjtBQUNIO0FBQ0osQ0FYRCxDLENBYUE7OztBQUNBLFNBQVNVLElBQVQsQ0FBY3JCLEdBQWQsRUFBbUJzQixLQUFuQixFQUEwQjtBQUN0QixPQUFLdEIsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsT0FBS3NCLEtBQUwsR0FBYUEsS0FBYjtBQUNIOztBQUNERCxJQUFJLENBQUNFLFNBQUwsQ0FBZVQsR0FBZixHQUFxQixZQUFZO0FBQzdCLE9BQUtkLEdBQUwsQ0FBU3dCLEtBQVQsQ0FBZSxJQUFmLEVBQXFCLEtBQUtGLEtBQTFCO0FBQ0gsQ0FGRDs7QUFHQWxDLE9BQU8sQ0FBQ3FDLEtBQVIsR0FBZ0IsU0FBaEI7QUFDQXJDLE9BQU8sQ0FBQ3NDLE9BQVIsR0FBa0IsSUFBbEI7QUFDQXRDLE9BQU8sQ0FBQ3VDLEdBQVIsR0FBYyxFQUFkO0FBQ0F2QyxPQUFPLENBQUN3QyxJQUFSLEdBQWUsRUFBZjtBQUNBeEMsT0FBTyxDQUFDeUMsT0FBUixHQUFrQixFQUFsQixDLENBQXNCOztBQUN0QnpDLE9BQU8sQ0FBQzBDLFFBQVIsR0FBbUIsRUFBbkI7O0FBRUEsU0FBU0MsSUFBVCxHQUFnQixDQUFFOztBQUVsQjNDLE9BQU8sQ0FBQzRDLEVBQVIsR0FBYUQsSUFBYjtBQUNBM0MsT0FBTyxDQUFDNkMsV0FBUixHQUFzQkYsSUFBdEI7QUFDQTNDLE9BQU8sQ0FBQzhDLElBQVIsR0FBZUgsSUFBZjtBQUNBM0MsT0FBTyxDQUFDK0MsR0FBUixHQUFjSixJQUFkO0FBQ0EzQyxPQUFPLENBQUNnRCxjQUFSLEdBQXlCTCxJQUF6QjtBQUNBM0MsT0FBTyxDQUFDaUQsa0JBQVIsR0FBNkJOLElBQTdCO0FBQ0EzQyxPQUFPLENBQUNrRCxJQUFSLEdBQWVQLElBQWY7QUFDQTNDLE9BQU8sQ0FBQ21ELGVBQVIsR0FBMEJSLElBQTFCO0FBQ0EzQyxPQUFPLENBQUNvRCxtQkFBUixHQUE4QlQsSUFBOUI7O0FBRUEzQyxPQUFPLENBQUNxRCxTQUFSLEdBQW9CLFVBQVVDLElBQVYsRUFBZ0I7QUFBRSxTQUFPLEVBQVA7QUFBVyxDQUFqRDs7QUFFQXRELE9BQU8sQ0FBQ3VELE9BQVIsR0FBa0IsVUFBVUQsSUFBVixFQUFnQjtBQUM5QixRQUFNLElBQUloRCxLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUNILENBRkQ7O0FBSUFOLE9BQU8sQ0FBQ3dELEdBQVIsR0FBYyxZQUFZO0FBQUUsU0FBTyxHQUFQO0FBQVksQ0FBeEM7O0FBQ0F4RCxPQUFPLENBQUN5RCxLQUFSLEdBQWdCLFVBQVVDLEdBQVYsRUFBZTtBQUMzQixRQUFNLElBQUlwRCxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILENBRkQ7O0FBR0FOLE9BQU8sQ0FBQzJELEtBQVIsR0FBZ0IsWUFBVztBQUFFLFNBQU8sQ0FBUDtBQUFXLENBQXhDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/process/browser.js\n");

/***/ }),

/***/ "../../node_modules/pseudomap/map.js":
/*!*******************************************!*\
  !*** ../../node_modules/pseudomap/map.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\nif (process.env.npm_package_name === 'pseudomap' && process.env.npm_lifecycle_script === 'test') process.env.TEST_PSEUDOMAP = 'true';\n\nif (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {\n  module.exports = Map;\n} else {\n  module.exports = __webpack_require__(/*! ./pseudomap */ \"../../node_modules/pseudomap/pseudomap.js\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3BzZXVkb21hcC9tYXAuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy9wc2V1ZG9tYXAvbWFwLmpzPzcwM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKHByb2Nlc3MuZW52Lm5wbV9wYWNrYWdlX25hbWUgPT09ICdwc2V1ZG9tYXAnICYmXG4gICAgcHJvY2Vzcy5lbnYubnBtX2xpZmVjeWNsZV9zY3JpcHQgPT09ICd0ZXN0JylcbiAgcHJvY2Vzcy5lbnYuVEVTVF9QU0VVRE9NQVAgPSAndHJ1ZSdcblxuaWYgKHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgIXByb2Nlc3MuZW52LlRFU1RfUFNFVURPTUFQKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTWFwXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcHNldWRvbWFwJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/pseudomap/map.js\n");

/***/ }),

/***/ "../../node_modules/pseudomap/pseudomap.js":
/*!*************************************************!*\
  !*** ../../node_modules/pseudomap/pseudomap.js ***!
  \*************************************************/
/***/ ((module) => {

eval("var hasOwnProperty = Object.prototype.hasOwnProperty;\nmodule.exports = PseudoMap;\n\nfunction PseudoMap(set) {\n  if (!(this instanceof PseudoMap)) // whyyyyyyy\n    throw new TypeError(\"Constructor PseudoMap requires 'new'\");\n  this.clear();\n\n  if (set) {\n    if (set instanceof PseudoMap || typeof Map === 'function' && set instanceof Map) set.forEach(function (value, key) {\n      this.set(key, value);\n    }, this);else if (Array.isArray(set)) set.forEach(function (kv) {\n      this.set(kv[0], kv[1]);\n    }, this);else throw new TypeError('invalid argument');\n  }\n}\n\nPseudoMap.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n  Object.keys(this._data).forEach(function (k) {\n    if (k !== 'size') fn.call(thisp, this._data[k].value, this._data[k].key);\n  }, this);\n};\n\nPseudoMap.prototype.has = function (k) {\n  return !!find(this._data, k);\n};\n\nPseudoMap.prototype.get = function (k) {\n  var res = find(this._data, k);\n  return res && res.value;\n};\n\nPseudoMap.prototype.set = function (k, v) {\n  set(this._data, k, v);\n};\n\nPseudoMap.prototype.delete = function (k) {\n  var res = find(this._data, k);\n\n  if (res) {\n    delete this._data[res._index];\n    this._data.size--;\n  }\n};\n\nPseudoMap.prototype.clear = function () {\n  var data = Object.create(null);\n  data.size = 0;\n  Object.defineProperty(this, '_data', {\n    value: data,\n    enumerable: false,\n    configurable: true,\n    writable: false\n  });\n};\n\nObject.defineProperty(PseudoMap.prototype, 'size', {\n  get: function () {\n    return this._data.size;\n  },\n  set: function (n) {},\n  enumerable: true,\n  configurable: true\n});\n\nPseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function () {\n  throw new Error('iterators are not implemented in this version');\n}; // Either identical, or both NaN\n\n\nfunction same(a, b) {\n  return a === b || a !== a && b !== b;\n}\n\nfunction Entry(k, v, i) {\n  this.key = k;\n  this.value = v;\n  this._index = i;\n}\n\nfunction find(data, k) {\n  for (var i = 0, s = '_' + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {\n    if (same(data[key].key, k)) return data[key];\n  }\n}\n\nfunction set(data, k, v) {\n  for (var i = 0, s = '_' + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {\n    if (same(data[key].key, k)) {\n      data[key].value = v;\n      return;\n    }\n  }\n\n  data.size++;\n  data[key] = new Entry(k, v, key);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy9wc2V1ZG9tYXAvcHNldWRvbWFwLmpzP2E5MGIiXSwibmFtZXMiOlsiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiUHNldWRvTWFwIiwic2V0IiwiVHlwZUVycm9yIiwiY2xlYXIiLCJNYXAiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJrdiIsImZuIiwidGhpc3AiLCJrZXlzIiwiX2RhdGEiLCJrIiwiY2FsbCIsImhhcyIsImZpbmQiLCJnZXQiLCJyZXMiLCJ2IiwiZGVsZXRlIiwiX2luZGV4Iiwic2l6ZSIsImRhdGEiLCJjcmVhdGUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm4iLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiRXJyb3IiLCJzYW1lIiwiYSIsImIiLCJFbnRyeSIsImkiLCJzIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxjQUFjLEdBQUdDLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkYsY0FBdEM7QUFFQUcsTUFBTSxDQUFDQyxPQUFQLEdBQWlCQyxTQUFqQjs7QUFFQSxTQUFTQSxTQUFULENBQW9CQyxHQUFwQixFQUF5QjtBQUN2QixNQUFJLEVBQUUsZ0JBQWdCRCxTQUFsQixDQUFKLEVBQWtDO0FBQ2hDLFVBQU0sSUFBSUUsU0FBSixDQUFjLHNDQUFkLENBQU47QUFFRixPQUFLQyxLQUFMOztBQUVBLE1BQUlGLEdBQUosRUFBUztBQUNQLFFBQUtBLEdBQUcsWUFBWUQsU0FBaEIsSUFDQyxPQUFPSSxHQUFQLEtBQWUsVUFBZixJQUE2QkgsR0FBRyxZQUFZRyxHQURqRCxFQUVFSCxHQUFHLENBQUNJLE9BQUosQ0FBWSxVQUFVQyxLQUFWLEVBQWlCQyxHQUFqQixFQUFzQjtBQUNoQyxXQUFLTixHQUFMLENBQVNNLEdBQVQsRUFBY0QsS0FBZDtBQUNELEtBRkQsRUFFRyxJQUZILEVBRkYsS0FLSyxJQUFJRSxLQUFLLENBQUNDLE9BQU4sQ0FBY1IsR0FBZCxDQUFKLEVBQ0hBLEdBQUcsQ0FBQ0ksT0FBSixDQUFZLFVBQVVLLEVBQVYsRUFBYztBQUN4QixXQUFLVCxHQUFMLENBQVNTLEVBQUUsQ0FBQyxDQUFELENBQVgsRUFBZ0JBLEVBQUUsQ0FBQyxDQUFELENBQWxCO0FBQ0QsS0FGRCxFQUVHLElBRkgsRUFERyxLQUtILE1BQU0sSUFBSVIsU0FBSixDQUFjLGtCQUFkLENBQU47QUFDSDtBQUNGOztBQUVERixTQUFTLENBQUNILFNBQVYsQ0FBb0JRLE9BQXBCLEdBQThCLFVBQVVNLEVBQVYsRUFBY0MsS0FBZCxFQUFxQjtBQUNqREEsRUFBQUEsS0FBSyxHQUFHQSxLQUFLLElBQUksSUFBakI7QUFDQWhCLEVBQUFBLE1BQU0sQ0FBQ2lCLElBQVAsQ0FBWSxLQUFLQyxLQUFqQixFQUF3QlQsT0FBeEIsQ0FBZ0MsVUFBVVUsQ0FBVixFQUFhO0FBQzNDLFFBQUlBLENBQUMsS0FBSyxNQUFWLEVBQ0VKLEVBQUUsQ0FBQ0ssSUFBSCxDQUFRSixLQUFSLEVBQWUsS0FBS0UsS0FBTCxDQUFXQyxDQUFYLEVBQWNULEtBQTdCLEVBQW9DLEtBQUtRLEtBQUwsQ0FBV0MsQ0FBWCxFQUFjUixHQUFsRDtBQUNILEdBSEQsRUFHRyxJQUhIO0FBSUQsQ0FORDs7QUFRQVAsU0FBUyxDQUFDSCxTQUFWLENBQW9Cb0IsR0FBcEIsR0FBMEIsVUFBVUYsQ0FBVixFQUFhO0FBQ3JDLFNBQU8sQ0FBQyxDQUFDRyxJQUFJLENBQUMsS0FBS0osS0FBTixFQUFhQyxDQUFiLENBQWI7QUFDRCxDQUZEOztBQUlBZixTQUFTLENBQUNILFNBQVYsQ0FBb0JzQixHQUFwQixHQUEwQixVQUFVSixDQUFWLEVBQWE7QUFDckMsTUFBSUssR0FBRyxHQUFHRixJQUFJLENBQUMsS0FBS0osS0FBTixFQUFhQyxDQUFiLENBQWQ7QUFDQSxTQUFPSyxHQUFHLElBQUlBLEdBQUcsQ0FBQ2QsS0FBbEI7QUFDRCxDQUhEOztBQUtBTixTQUFTLENBQUNILFNBQVYsQ0FBb0JJLEdBQXBCLEdBQTBCLFVBQVVjLENBQVYsRUFBYU0sQ0FBYixFQUFnQjtBQUN4Q3BCLEVBQUFBLEdBQUcsQ0FBQyxLQUFLYSxLQUFOLEVBQWFDLENBQWIsRUFBZ0JNLENBQWhCLENBQUg7QUFDRCxDQUZEOztBQUlBckIsU0FBUyxDQUFDSCxTQUFWLENBQW9CeUIsTUFBcEIsR0FBNkIsVUFBVVAsQ0FBVixFQUFhO0FBQ3hDLE1BQUlLLEdBQUcsR0FBR0YsSUFBSSxDQUFDLEtBQUtKLEtBQU4sRUFBYUMsQ0FBYixDQUFkOztBQUNBLE1BQUlLLEdBQUosRUFBUztBQUNQLFdBQU8sS0FBS04sS0FBTCxDQUFXTSxHQUFHLENBQUNHLE1BQWYsQ0FBUDtBQUNBLFNBQUtULEtBQUwsQ0FBV1UsSUFBWDtBQUNEO0FBQ0YsQ0FORDs7QUFRQXhCLFNBQVMsQ0FBQ0gsU0FBVixDQUFvQk0sS0FBcEIsR0FBNEIsWUFBWTtBQUN0QyxNQUFJc0IsSUFBSSxHQUFHN0IsTUFBTSxDQUFDOEIsTUFBUCxDQUFjLElBQWQsQ0FBWDtBQUNBRCxFQUFBQSxJQUFJLENBQUNELElBQUwsR0FBWSxDQUFaO0FBRUE1QixFQUFBQSxNQUFNLENBQUMrQixjQUFQLENBQXNCLElBQXRCLEVBQTRCLE9BQTVCLEVBQXFDO0FBQ25DckIsSUFBQUEsS0FBSyxFQUFFbUIsSUFENEI7QUFFbkNHLElBQUFBLFVBQVUsRUFBRSxLQUZ1QjtBQUduQ0MsSUFBQUEsWUFBWSxFQUFFLElBSHFCO0FBSW5DQyxJQUFBQSxRQUFRLEVBQUU7QUFKeUIsR0FBckM7QUFNRCxDQVZEOztBQVlBbEMsTUFBTSxDQUFDK0IsY0FBUCxDQUFzQjNCLFNBQVMsQ0FBQ0gsU0FBaEMsRUFBMkMsTUFBM0MsRUFBbUQ7QUFDakRzQixFQUFBQSxHQUFHLEVBQUUsWUFBWTtBQUNmLFdBQU8sS0FBS0wsS0FBTCxDQUFXVSxJQUFsQjtBQUNELEdBSGdEO0FBSWpEdkIsRUFBQUEsR0FBRyxFQUFFLFVBQVU4QixDQUFWLEVBQWEsQ0FBRSxDQUo2QjtBQUtqREgsRUFBQUEsVUFBVSxFQUFFLElBTHFDO0FBTWpEQyxFQUFBQSxZQUFZLEVBQUU7QUFObUMsQ0FBbkQ7O0FBU0E3QixTQUFTLENBQUNILFNBQVYsQ0FBb0JtQyxNQUFwQixHQUNBaEMsU0FBUyxDQUFDSCxTQUFWLENBQW9CZ0IsSUFBcEIsR0FDQWIsU0FBUyxDQUFDSCxTQUFWLENBQW9Cb0MsT0FBcEIsR0FBOEIsWUFBWTtBQUN4QyxRQUFNLElBQUlDLEtBQUosQ0FBVSwrQ0FBVixDQUFOO0FBQ0QsQ0FKRCxDLENBTUE7OztBQUNBLFNBQVNDLElBQVQsQ0FBZUMsQ0FBZixFQUFrQkMsQ0FBbEIsRUFBcUI7QUFDbkIsU0FBT0QsQ0FBQyxLQUFLQyxDQUFOLElBQVdELENBQUMsS0FBS0EsQ0FBTixJQUFXQyxDQUFDLEtBQUtBLENBQW5DO0FBQ0Q7O0FBRUQsU0FBU0MsS0FBVCxDQUFnQnZCLENBQWhCLEVBQW1CTSxDQUFuQixFQUFzQmtCLENBQXRCLEVBQXlCO0FBQ3ZCLE9BQUtoQyxHQUFMLEdBQVdRLENBQVg7QUFDQSxPQUFLVCxLQUFMLEdBQWFlLENBQWI7QUFDQSxPQUFLRSxNQUFMLEdBQWNnQixDQUFkO0FBQ0Q7O0FBRUQsU0FBU3JCLElBQVQsQ0FBZU8sSUFBZixFQUFxQlYsQ0FBckIsRUFBd0I7QUFDdEIsT0FBSyxJQUFJd0IsQ0FBQyxHQUFHLENBQVIsRUFBV0MsQ0FBQyxHQUFHLE1BQU16QixDQUFyQixFQUF3QlIsR0FBRyxHQUFHaUMsQ0FBbkMsRUFDSzdDLGNBQWMsQ0FBQ3FCLElBQWYsQ0FBb0JTLElBQXBCLEVBQTBCbEIsR0FBMUIsQ0FETCxFQUVLQSxHQUFHLEdBQUdpQyxDQUFDLEdBQUdELENBQUMsRUFGaEIsRUFFb0I7QUFDbEIsUUFBSUosSUFBSSxDQUFDVixJQUFJLENBQUNsQixHQUFELENBQUosQ0FBVUEsR0FBWCxFQUFnQlEsQ0FBaEIsQ0FBUixFQUNFLE9BQU9VLElBQUksQ0FBQ2xCLEdBQUQsQ0FBWDtBQUNIO0FBQ0Y7O0FBRUQsU0FBU04sR0FBVCxDQUFjd0IsSUFBZCxFQUFvQlYsQ0FBcEIsRUFBdUJNLENBQXZCLEVBQTBCO0FBQ3hCLE9BQUssSUFBSWtCLENBQUMsR0FBRyxDQUFSLEVBQVdDLENBQUMsR0FBRyxNQUFNekIsQ0FBckIsRUFBd0JSLEdBQUcsR0FBR2lDLENBQW5DLEVBQ0s3QyxjQUFjLENBQUNxQixJQUFmLENBQW9CUyxJQUFwQixFQUEwQmxCLEdBQTFCLENBREwsRUFFS0EsR0FBRyxHQUFHaUMsQ0FBQyxHQUFHRCxDQUFDLEVBRmhCLEVBRW9CO0FBQ2xCLFFBQUlKLElBQUksQ0FBQ1YsSUFBSSxDQUFDbEIsR0FBRCxDQUFKLENBQVVBLEdBQVgsRUFBZ0JRLENBQWhCLENBQVIsRUFBNEI7QUFDMUJVLE1BQUFBLElBQUksQ0FBQ2xCLEdBQUQsQ0FBSixDQUFVRCxLQUFWLEdBQWtCZSxDQUFsQjtBQUNBO0FBQ0Q7QUFDRjs7QUFDREksRUFBQUEsSUFBSSxDQUFDRCxJQUFMO0FBQ0FDLEVBQUFBLElBQUksQ0FBQ2xCLEdBQUQsQ0FBSixHQUFZLElBQUkrQixLQUFKLENBQVV2QixDQUFWLEVBQWFNLENBQWIsRUFBZ0JkLEdBQWhCLENBQVo7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbInZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBQc2V1ZG9NYXBcblxuZnVuY3Rpb24gUHNldWRvTWFwIChzZXQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBzZXVkb01hcCkpIC8vIHdoeXl5eXl5eVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvciBQc2V1ZG9NYXAgcmVxdWlyZXMgJ25ldydcIilcblxuICB0aGlzLmNsZWFyKClcblxuICBpZiAoc2V0KSB7XG4gICAgaWYgKChzZXQgaW5zdGFuY2VvZiBQc2V1ZG9NYXApIHx8XG4gICAgICAgICh0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIHNldCBpbnN0YW5jZW9mIE1hcCkpXG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKVxuICAgICAgfSwgdGhpcylcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNldCkpXG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAoa3YpIHtcbiAgICAgICAgdGhpcy5zZXQoa3ZbMF0sIGt2WzFdKVxuICAgICAgfSwgdGhpcylcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50JylcbiAgfVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBPYmplY3Qua2V5cyh0aGlzLl9kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgIT09ICdzaXplJylcbiAgICAgIGZuLmNhbGwodGhpc3AsIHRoaXMuX2RhdGFba10udmFsdWUsIHRoaXMuX2RhdGFba10ua2V5KVxuICB9LCB0aGlzKVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrKSB7XG4gIHJldHVybiAhIWZpbmQodGhpcy5fZGF0YSwgaylcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaykge1xuICB2YXIgcmVzID0gZmluZCh0aGlzLl9kYXRhLCBrKVxuICByZXR1cm4gcmVzICYmIHJlcy52YWx1ZVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrLCB2KSB7XG4gIHNldCh0aGlzLl9kYXRhLCBrLCB2KVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrKSB7XG4gIHZhciByZXMgPSBmaW5kKHRoaXMuX2RhdGEsIGspXG4gIGlmIChyZXMpIHtcbiAgICBkZWxldGUgdGhpcy5fZGF0YVtyZXMuX2luZGV4XVxuICAgIHRoaXMuX2RhdGEuc2l6ZS0tXG4gIH1cbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIGRhdGEuc2l6ZSA9IDBcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19kYXRhJywge1xuICAgIHZhbHVlOiBkYXRhLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBzZXVkb01hcC5wcm90b3R5cGUsICdzaXplJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zaXplXG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKG4pIHt9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pXG5cblBzZXVkb01hcC5wcm90b3R5cGUudmFsdWVzID1cblBzZXVkb01hcC5wcm90b3R5cGUua2V5cyA9XG5Qc2V1ZG9NYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3JzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyB2ZXJzaW9uJylcbn1cblxuLy8gRWl0aGVyIGlkZW50aWNhbCwgb3IgYm90aCBOYU5cbmZ1bmN0aW9uIHNhbWUgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSAhPT0gYSAmJiBiICE9PSBiXG59XG5cbmZ1bmN0aW9uIEVudHJ5IChrLCB2LCBpKSB7XG4gIHRoaXMua2V5ID0ga1xuICB0aGlzLnZhbHVlID0gdlxuICB0aGlzLl9pbmRleCA9IGlcbn1cblxuZnVuY3Rpb24gZmluZCAoZGF0YSwgaykge1xuICBmb3IgKHZhciBpID0gMCwgcyA9ICdfJyArIGssIGtleSA9IHM7XG4gICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgICAgIGtleSA9IHMgKyBpKyspIHtcbiAgICBpZiAoc2FtZShkYXRhW2tleV0ua2V5LCBrKSlcbiAgICAgIHJldHVybiBkYXRhW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQgKGRhdGEsIGssIHYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIHMgPSAnXycgKyBrLCBrZXkgPSBzO1xuICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICAgICBrZXkgPSBzICsgaSsrKSB7XG4gICAgaWYgKHNhbWUoZGF0YVtrZXldLmtleSwgaykpIHtcbiAgICAgIGRhdGFba2V5XS52YWx1ZSA9IHZcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBkYXRhLnNpemUrK1xuICBkYXRhW2tleV0gPSBuZXcgRW50cnkoaywgdiwga2V5KVxufVxuIl0sImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL3BzZXVkb21hcC5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/pseudomap/pseudomap.js\n");

/***/ }),

/***/ "../../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"encode\": () => (/* binding */ encode)\n/* harmony export */ });\nvar charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfor (var i = 0; i < chars.length; i++) {\n  charToInteger[chars.charCodeAt(i)] = i;\n}\n\nfunction decode(mappings) {\n  var decoded = [];\n  var line = [];\n  var segment = [0, 0, 0, 0, 0];\n  var j = 0;\n\n  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n    var c = mappings.charCodeAt(i);\n\n    if (c === 44) {\n      // \",\"\n      segmentify(line, segment, j);\n      j = 0;\n    } else if (c === 59) {\n      // \";\"\n      segmentify(line, segment, j);\n      j = 0;\n      decoded.push(line);\n      line = [];\n      segment[0] = 0;\n    } else {\n      var integer = charToInteger[c];\n\n      if (integer === undefined) {\n        throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n      }\n\n      var hasContinuationBit = integer & 32;\n      integer &= 31;\n      value += integer << shift;\n\n      if (hasContinuationBit) {\n        shift += 5;\n      } else {\n        var shouldNegate = value & 1;\n        value >>>= 1;\n\n        if (shouldNegate) {\n          value = value === 0 ? -0x80000000 : -value;\n        }\n\n        segment[j] += value;\n        j++;\n        value = shift = 0; // reset\n      }\n    }\n  }\n\n  segmentify(line, segment, j);\n  decoded.push(line);\n  return decoded;\n}\n\nfunction segmentify(line, segment, j) {\n  // This looks ugly, but we're creating specialized arrays with a specific\n  // length. This is much faster than creating a new array (which v8 expands to\n  // a capacity of 17 after pushing the first item), or slicing out a subarray\n  // (which is slow). Length 4 is assumed to be the most frequent, followed by\n  // length 5 (since not everything will have an associated name), followed by\n  // length 1 (it's probably rare for a source substring to not have an\n  // associated segment data).\n  if (j === 4) line.push([segment[0], segment[1], segment[2], segment[3]]);else if (j === 5) line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);else if (j === 1) line.push([segment[0]]);\n}\n\nfunction encode(decoded) {\n  var sourceFileIndex = 0; // second field\n\n  var sourceCodeLine = 0; // third field\n\n  var sourceCodeColumn = 0; // fourth field\n\n  var nameIndex = 0; // fifth field\n\n  var mappings = '';\n\n  for (var i = 0; i < decoded.length; i++) {\n    var line = decoded[i];\n    if (i > 0) mappings += ';';\n    if (line.length === 0) continue;\n    var generatedCodeColumn = 0; // first field\n\n    var lineMappings = [];\n\n    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n      var segment = line_1[_i];\n      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n      generatedCodeColumn = segment[0];\n\n      if (segment.length > 1) {\n        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);\n        sourceFileIndex = segment[1];\n        sourceCodeLine = segment[2];\n        sourceCodeColumn = segment[3];\n      }\n\n      if (segment.length === 5) {\n        segmentMappings += encodeInteger(segment[4] - nameIndex);\n        nameIndex = segment[4];\n      }\n\n      lineMappings.push(segmentMappings);\n    }\n\n    mappings += lineMappings.join(',');\n  }\n\n  return mappings;\n}\n\nfunction encodeInteger(num) {\n  var result = '';\n  num = num < 0 ? -num << 1 | 1 : num << 1;\n\n  do {\n    var clamped = num & 31;\n    num >>>= 5;\n\n    if (num > 0) {\n      clamped |= 32;\n    }\n\n    result += chars[clamped];\n  } while (num > 0);\n\n  return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3NvdXJjZW1hcC1jb2RlYy9kaXN0L3NvdXJjZW1hcC1jb2RlYy5lcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUdBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9zcmMvc291cmNlbWFwLWNvZGVjLnRzP2QzZWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgU291cmNlTWFwU2VnbWVudCA9XG5cdHwgW251bWJlcl1cblx0fCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuXHR8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5leHBvcnQgdHlwZSBTb3VyY2VNYXBMaW5lID0gU291cmNlTWFwU2VnbWVudFtdO1xuZXhwb3J0IHR5cGUgU291cmNlTWFwTWFwcGluZ3MgPSBTb3VyY2VNYXBMaW5lW107XG5cbmNvbnN0IGNoYXJUb0ludGVnZXI6IHsgW2NoYXJDb2RlOiBudW1iZXJdOiBudW1iZXIgfSA9IHt9O1xuY29uc3QgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG5cdGNoYXJUb0ludGVnZXJbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKG1hcHBpbmdzOiBzdHJpbmcpOiBTb3VyY2VNYXBNYXBwaW5ncyB7XG5cdGNvbnN0IGRlY29kZWQ6IFNvdXJjZU1hcE1hcHBpbmdzID0gW107XG5cdGxldCBsaW5lOiBTb3VyY2VNYXBMaW5lID0gW107XG5cdGNvbnN0IHNlZ21lbnQ6IFNvdXJjZU1hcFNlZ21lbnQgPSBbXG5cdFx0MCwgLy8gZ2VuZXJhdGVkIGNvZGUgY29sdW1uXG5cdFx0MCwgLy8gc291cmNlIGZpbGUgaW5kZXhcblx0XHQwLCAvLyBzb3VyY2UgY29kZSBsaW5lXG5cdFx0MCwgLy8gc291cmNlIGNvZGUgY29sdW1uXG5cdFx0MCwgLy8gbmFtZSBpbmRleFxuXHRdO1xuXG5cdGxldCBqID0gMDtcblx0Zm9yIChsZXQgaSA9IDAsIHNoaWZ0ID0gMCwgdmFsdWUgPSAwOyBpIDwgbWFwcGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBjID0gbWFwcGluZ3MuY2hhckNvZGVBdChpKTtcblxuXHRcdGlmIChjID09PSA0NCkgeyAvLyBcIixcIlxuXHRcdFx0c2VnbWVudGlmeShsaW5lLCBzZWdtZW50LCBqKTtcblx0XHRcdGogPSAwO1xuXG5cdFx0fSBlbHNlIGlmIChjID09PSA1OSkgeyAvLyBcIjtcIlxuXHRcdFx0c2VnbWVudGlmeShsaW5lLCBzZWdtZW50LCBqKTtcblx0XHRcdGogPSAwO1xuXHRcdFx0ZGVjb2RlZC5wdXNoKGxpbmUpO1xuXHRcdFx0bGluZSA9IFtdO1xuXHRcdFx0c2VnbWVudFswXSA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGludGVnZXIgPSBjaGFyVG9JbnRlZ2VyW2NdO1xuXHRcdFx0aWYgKGludGVnZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyICgnICsgU3RyaW5nLmZyb21DaGFyQ29kZShjKSArICcpJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGhhc0NvbnRpbnVhdGlvbkJpdCA9IGludGVnZXIgJiAzMjtcblxuXHRcdFx0aW50ZWdlciAmPSAzMTtcblx0XHRcdHZhbHVlICs9IGludGVnZXIgPDwgc2hpZnQ7XG5cblx0XHRcdGlmIChoYXNDb250aW51YXRpb25CaXQpIHtcblx0XHRcdFx0c2hpZnQgKz0gNTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHNob3VsZE5lZ2F0ZSA9IHZhbHVlICYgMTtcblx0XHRcdFx0dmFsdWUgPj4+PSAxO1xuXG5cdFx0XHRcdGlmIChzaG91bGROZWdhdGUpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlID09PSAwID8gLTB4ODAwMDAwMDAgOiAtdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZWdtZW50W2pdICs9IHZhbHVlO1xuXHRcdFx0XHRqKys7XG5cdFx0XHRcdHZhbHVlID0gc2hpZnQgPSAwOyAvLyByZXNldFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHNlZ21lbnRpZnkobGluZSwgc2VnbWVudCwgaik7XG5cdGRlY29kZWQucHVzaChsaW5lKTtcblxuXHRyZXR1cm4gZGVjb2RlZDtcbn1cblxuZnVuY3Rpb24gc2VnbWVudGlmeShsaW5lOiBTb3VyY2VNYXBTZWdtZW50W10sIHNlZ21lbnQ6IFNvdXJjZU1hcFNlZ21lbnQsIGo6IG51bWJlcikge1xuXHQvLyBUaGlzIGxvb2tzIHVnbHksIGJ1dCB3ZSdyZSBjcmVhdGluZyBzcGVjaWFsaXplZCBhcnJheXMgd2l0aCBhIHNwZWNpZmljXG5cdC8vIGxlbmd0aC4gVGhpcyBpcyBtdWNoIGZhc3RlciB0aGFuIGNyZWF0aW5nIGEgbmV3IGFycmF5ICh3aGljaCB2OCBleHBhbmRzIHRvXG5cdC8vIGEgY2FwYWNpdHkgb2YgMTcgYWZ0ZXIgcHVzaGluZyB0aGUgZmlyc3QgaXRlbSksIG9yIHNsaWNpbmcgb3V0IGEgc3ViYXJyYXlcblx0Ly8gKHdoaWNoIGlzIHNsb3cpLiBMZW5ndGggNCBpcyBhc3N1bWVkIHRvIGJlIHRoZSBtb3N0IGZyZXF1ZW50LCBmb2xsb3dlZCBieVxuXHQvLyBsZW5ndGggNSAoc2luY2Ugbm90IGV2ZXJ5dGhpbmcgd2lsbCBoYXZlIGFuIGFzc29jaWF0ZWQgbmFtZSksIGZvbGxvd2VkIGJ5XG5cdC8vIGxlbmd0aCAxIChpdCdzIHByb2JhYmx5IHJhcmUgZm9yIGEgc291cmNlIHN1YnN0cmluZyB0byBub3QgaGF2ZSBhblxuXHQvLyBhc3NvY2lhdGVkIHNlZ21lbnQgZGF0YSkuXG5cdGlmIChqID09PSA0KSBsaW5lLnB1c2goW3NlZ21lbnRbMF0sIHNlZ21lbnRbMV0sIHNlZ21lbnRbMl0sIHNlZ21lbnRbM11dKTtcblx0ZWxzZSBpZiAoaiA9PT0gNSkgbGluZS5wdXNoKFtzZWdtZW50WzBdLCBzZWdtZW50WzFdLCBzZWdtZW50WzJdLCBzZWdtZW50WzNdLCBzZWdtZW50WzRdXSk7XG5cdGVsc2UgaWYgKGogPT09IDEpIGxpbmUucHVzaChbc2VnbWVudFswXV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRlY29kZWQ6IFNvdXJjZU1hcE1hcHBpbmdzKTogc3RyaW5nIHtcblx0bGV0IHNvdXJjZUZpbGVJbmRleCA9IDA7ICAvLyBzZWNvbmQgZmllbGRcblx0bGV0IHNvdXJjZUNvZGVMaW5lID0gMDsgICAvLyB0aGlyZCBmaWVsZFxuXHRsZXQgc291cmNlQ29kZUNvbHVtbiA9IDA7IC8vIGZvdXJ0aCBmaWVsZFxuXHRsZXQgbmFtZUluZGV4ID0gMDsgICAgICAgIC8vIGZpZnRoIGZpZWxkXG5cdGxldCBtYXBwaW5ncyA9ICcnO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuXHRcdGlmIChpID4gMCkgbWFwcGluZ3MgKz0gJzsnO1xuXHRcdGlmIChsaW5lLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cblx0XHRsZXQgZ2VuZXJhdGVkQ29kZUNvbHVtbiA9IDA7IC8vIGZpcnN0IGZpZWxkXG5cblx0XHRjb25zdCBsaW5lTWFwcGluZ3M6IHN0cmluZ1tdID0gW107XG5cblx0XHRmb3IgKGNvbnN0IHNlZ21lbnQgb2YgbGluZSkge1xuXHRcdFx0bGV0IHNlZ21lbnRNYXBwaW5ncyA9IGVuY29kZUludGVnZXIoc2VnbWVudFswXSAtIGdlbmVyYXRlZENvZGVDb2x1bW4pO1xuXHRcdFx0Z2VuZXJhdGVkQ29kZUNvbHVtbiA9IHNlZ21lbnRbMF07XG5cblx0XHRcdGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0c2VnbWVudE1hcHBpbmdzICs9XG5cdFx0XHRcdFx0ZW5jb2RlSW50ZWdlcihzZWdtZW50WzFdIC0gc291cmNlRmlsZUluZGV4KSArXG5cdFx0XHRcdFx0ZW5jb2RlSW50ZWdlcihzZWdtZW50WzJdIC0gc291cmNlQ29kZUxpbmUpICtcblx0XHRcdFx0XHRlbmNvZGVJbnRlZ2VyKHNlZ21lbnRbM10gLSBzb3VyY2VDb2RlQ29sdW1uKTtcblxuXHRcdFx0XHRzb3VyY2VGaWxlSW5kZXggPSBzZWdtZW50WzFdO1xuXHRcdFx0XHRzb3VyY2VDb2RlTGluZSA9IHNlZ21lbnRbMl07XG5cdFx0XHRcdHNvdXJjZUNvZGVDb2x1bW4gPSBzZWdtZW50WzNdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc2VnbWVudC5sZW5ndGggPT09IDUpIHtcblx0XHRcdFx0c2VnbWVudE1hcHBpbmdzICs9IGVuY29kZUludGVnZXIoc2VnbWVudFs0XSAtIG5hbWVJbmRleCk7XG5cdFx0XHRcdG5hbWVJbmRleCA9IHNlZ21lbnRbNF07XG5cdFx0XHR9XG5cblx0XHRcdGxpbmVNYXBwaW5ncy5wdXNoKHNlZ21lbnRNYXBwaW5ncyk7XG5cdFx0fVxuXG5cdFx0bWFwcGluZ3MgKz0gbGluZU1hcHBpbmdzLmpvaW4oJywnKTtcblx0fVxuXG5cdHJldHVybiBtYXBwaW5ncztcbn1cblxuZnVuY3Rpb24gZW5jb2RlSW50ZWdlcihudW06IG51bWJlcik6IHN0cmluZyB7XG5cdHZhciByZXN1bHQgPSAnJztcblx0bnVtID0gbnVtIDwgMCA/ICgtbnVtIDw8IDEpIHwgMSA6IG51bSA8PCAxO1xuXHRkbyB7XG5cdFx0dmFyIGNsYW1wZWQgPSBudW0gJiAzMTtcblx0XHRudW0gPj4+PSA1O1xuXHRcdGlmIChudW0gPiAwKSB7XG5cdFx0XHRjbGFtcGVkIHw9IDMyO1xuXHRcdH1cblx0XHRyZXN1bHQgKz0gY2hhcnNbY2xhbXBlZF07XG5cdH0gd2hpbGUgKG51bSA+IDApO1xuXG5cdHJldHVybiByZXN1bHQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js\n");

/***/ }),

/***/ "../../node_modules/ws/index.js":
/*!**************************************!*\
  !*** ../../node_modules/ws/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst WebSocket = __webpack_require__(/*! ./lib/websocket */ \"../../node_modules/ws/lib/websocket.js\");\n\nWebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ \"../../node_modules/ws/lib/stream.js\");\nWebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ \"../../node_modules/ws/lib/websocket-server.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ \"../../node_modules/ws/lib/receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/sender */ \"../../node_modules/ws/lib/sender.js\");\nmodule.exports = WebSocket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcz81MzM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7XG5cbldlYlNvY2tldC5jcmVhdGVXZWJTb2NrZXRTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9zdHJlYW0nKTtcbldlYlNvY2tldC5TZXJ2ZXIgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQtc2VydmVyJyk7XG5XZWJTb2NrZXQuUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9yZWNlaXZlcicpO1xuV2ViU29ja2V0LlNlbmRlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/index.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/buffer-util.js":
/*!************************************************!*\
  !*** ../../node_modules/ws/lib/buffer-util.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  EMPTY_BUFFER\n} = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\n\n\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n  return target;\n}\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\n\n\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\n\n\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n\n  for (let i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\n\n\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\n\n\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = __webpack_require__(/*! bufferutil */ \"bufferutil\");\n\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n  module.exports = {\n    concat,\n\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);else bu.mask(source, mask, output, offset, length);\n    },\n\n    toArrayBuffer,\n    toBuffer,\n\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);else bu.unmask(buffer, mask);\n    }\n\n  };\n} catch (e)\n/* istanbul ignore next */\n{\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUFBO0FBQUE7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFYQTtBQWFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanM/ODFhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkgcmV0dXJuIHRhcmdldC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIC8vIFJlcXVpcmVkIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvOTAwNiBpcyByZXNvbHZlZC5cbiAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGJ1ZmZlcltpXSBePSBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGFuIGBBcnJheUJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBDb252ZXJ0ZWQgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmKSB7XG4gIGlmIChidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gIH1cblxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBCdWZmZXIuZnJvbShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG50cnkge1xuICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuICBjb25zdCBidSA9IGJ1ZmZlclV0aWwuQnVmZmVyVXRpbCB8fCBidWZmZXJVdGlsO1xuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvbmNhdCxcbiAgICBtYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDQ4KSBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZWxzZSBidS5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfSxcbiAgICB0b0FycmF5QnVmZmVyLFxuICAgIHRvQnVmZmVyLFxuICAgIHVubWFzayhidWZmZXIsIG1hc2spIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICAgIGVsc2UgYnUudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfVxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzazogX21hc2ssXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2s6IF91bm1hc2tcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/constants.js":
/*!**********************************************!*\
  !*** ../../node_modules/ws/lib/constants.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  EMPTY_BUFFER: Buffer.alloc(0),\n  NOOP: () => {}\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanM/Y2RjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVM6IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/event-target.js":
/*!*************************************************!*\
  !*** ../../node_modules/ws/lib/event-target.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n/**\n * Class representing an event.\n *\n * @private\n */\n\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was\n   *     dispatched\n   */\n  constructor(type, target) {\n    this.target = target;\n    this.type = type;\n  }\n\n}\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\n\n\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was\n   *     dispatched\n   */\n  constructor(data, target) {\n    super('message', target);\n    this.data = data;\n  }\n\n}\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\n\n\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being\n   *     closed\n   * @param {String} reason A human-readable string explaining why the\n   *     connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was\n   *     dispatched\n   */\n  constructor(code, reason, target) {\n    super('close', target);\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n\n}\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\n\n\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was\n   *     dispatched\n   */\n  constructor(target) {\n    super('open', target);\n  }\n\n}\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */\n\n\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was\n   *     dispatched\n   */\n  constructor(error, target) {\n    super('error', target);\n    this.message = error.message;\n    this.error = error;\n  }\n\n}\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\n\n\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean`` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(error) {\n      listener.call(this, new ErrorEvent(error, this));\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    const method = options && options.once ? 'once' : 'on';\n\n    if (type === 'message') {\n      onMessage._listener = listener;\n      this[method](type, onMessage);\n    } else if (type === 'close') {\n      onClose._listener = listener;\n      this[method](type, onClose);\n    } else if (type === 'error') {\n      onError._listener = listener;\n      this[method](type, onError);\n    } else if (type === 'open') {\n      onOpen._listener = listener;\n      this[method](type, onOpen);\n    } else {\n      this[method](type, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener(type, listener) {\n    const listeners = this.listeners(type);\n\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(type, listeners[i]);\n      }\n    }\n  }\n\n};\nmodule.exports = EventTarget;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7O0FBS0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBY0E7Ozs7Ozs7O0FBTUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBOztBQVpBO0FBZUE7Ozs7Ozs7O0FBTUE7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFqQkE7QUFvQkE7Ozs7Ozs7O0FBTUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOztBQVRBO0FBWUE7Ozs7Ozs7O0FBTUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBYkE7QUFnQkE7Ozs7Ozs7O0FBTUE7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsRUE7QUFxRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzPzk5MGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzXG4gICAqICAgICBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgcmVjZWl2ZWQgZGF0YVxuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhc1xuICAgKiAgICAgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSwgdGFyZ2V0KSB7XG4gICAgc3VwZXIoJ21lc3NhZ2UnLCB0YXJnZXQpO1xuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBDbG9zZUV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGJlaW5nXG4gICAqICAgICBjbG9zZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvbiBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcGFyYW0ge1dlYlNvY2tldH0gdGFyZ2V0IEEgcmVmZXJlbmNlIHRvIHRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGV2ZW50IHdhc1xuICAgKiAgICAgZGlzcGF0Y2hlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgcmVhc29uLCB0YXJnZXQpIHtcbiAgICBzdXBlcignY2xvc2UnLCB0YXJnZXQpO1xuXG4gICAgdGhpcy53YXNDbGVhbiA9IHRhcmdldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRhcmdldC5fY2xvc2VGcmFtZVNlbnQ7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBvcGVuIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBPcGVuRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE9wZW5FdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViU29ja2V0fSB0YXJnZXQgQSByZWZlcmVuY2UgdG8gdGhlIHRhcmdldCB0byB3aGljaCB0aGUgZXZlbnQgd2FzXG4gICAqICAgICBkaXNwYXRjaGVkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICBzdXBlcignb3BlbicsIHRhcmdldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXJyb3IgVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtXZWJTb2NrZXR9IHRhcmdldCBBIHJlZmVyZW5jZSB0byB0aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSBldmVudCB3YXNcbiAgICogICAgIGRpc3BhdGNoZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVycm9yLCB0YXJnZXQpIHtcbiAgICBzdXBlcignZXJyb3InLCB0YXJnZXQpO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW4gb3B0aW9ucyBvYmplY3Qgc3BlY2lmaWVzIGNoYXJhY3RlcmlzdGljcyBhYm91dFxuICAgKiAgICAgdGhlIGV2ZW50IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub25jZT1mYWxzZV0gQSBgQm9vbGVhbmBgIGluZGljYXRpbmcgdGhhdCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBuZXcgTWVzc2FnZUV2ZW50KGRhdGEsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNsb3NlKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IENsb3NlRXZlbnQoY29kZSwgbWVzc2FnZSwgdGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgbmV3IEVycm9yRXZlbnQoZXJyb3IsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk9wZW4oKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIG5ldyBPcGVuRXZlbnQodGhpcykpO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vbmNlID8gJ29uY2UnIDogJ29uJztcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIG9uTWVzc2FnZS5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbk1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgb25DbG9zZS5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbkNsb3NlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIG9uRXJyb3IuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICB0aGlzW21ldGhvZF0odHlwZSwgb25FcnJvcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb3BlbicpIHtcbiAgICAgIG9uT3Blbi5fbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgIHRoaXNbbWV0aG9kXSh0eXBlLCBvbk9wZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW21ldGhvZF0odHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzKHR5cGUpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/extension.js":
/*!**********************************************!*\
  !*** ../../node_modules/ws/lib/extension.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval(" //\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\n\nconst tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\n\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);\n}\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\n\n\nfunction parse(header) {\n  const offers = Object.create(null);\n  if (header === undefined || header === '') return offers;\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20\n      /* ' ' */\n      || code === 0x09\n      /* '\\t' */\n      ) {\n          if (end === -1 && start !== -1) end = i;\n        } else if (code === 0x3b\n      /* ';' */\n      || code === 0x2c\n      /* ',' */\n      ) {\n          if (start === -1) {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n          }\n\n          if (end === -1) end = i;\n          const name = header.slice(start, end);\n\n          if (code === 0x2c) {\n            push(offers, name, params);\n            params = Object.create(null);\n          } else {\n            extensionName = name;\n          }\n\n          start = end = -1;\n        } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d\n      /* '=' */\n      && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22\n        /* '\"' */\n        && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c\n        /* '\\' */\n        ) {\n            isEscaping = true;\n          } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n\n        push(params, paramName, value);\n\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\n\n\nfunction format(extensions) {\n  return Object.keys(extensions).map(extension => {\n    let configurations = extensions[extension];\n    if (!Array.isArray(configurations)) configurations = [configurations];\n    return configurations.map(params => {\n      return [extension].concat(Object.keys(params).map(k => {\n        let values = params[k];\n        if (!Array.isArray(values)) values = [values];\n        return values.map(v => v === true ? k : `${k}=${v}`).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\n\nmodule.exports = {\n  format,\n  parse\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVdBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBRUE7QUFFQTs7QUFFQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanM/NmM3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIEFkZHMgYW4gb2ZmZXIgdG8gdGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIGEgcGFyYW1ldGVyIHRvIHRoZSBtYXAgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3QgVGhlIG1hcCBvZiBleHRlbnNpb24gb2ZmZXJzIG9yIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBleHRlbnNpb24gb3IgcGFyYW1ldGVyIG5hbWVcbiAqIEBwYXJhbSB7KE9iamVjdHxCb29sZWFufFN0cmluZyl9IGVsZW0gVGhlIGV4dGVuc2lvbiBwYXJhbWV0ZXJzIG9yIHRoZVxuICogICAgIHBhcmFtZXRlciB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVzaChkZXN0LCBuYW1lLCBlbGVtKSB7XG4gIGlmIChkZXN0W25hbWVdID09PSB1bmRlZmluZWQpIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2UgZGVzdFtuYW1lXS5wdXNoKGVsZW0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHBhcnNlZCBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IG9mZmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgaWYgKGhlYWRlciA9PT0gdW5kZWZpbmVkIHx8IGhlYWRlciA9PT0gJycpIHJldHVybiBvZmZlcnM7XG5cbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSAvKiAnXFx0JyAqLykge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgLyogJzsnICovIHx8IGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBjb25zdCBuYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBuYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgcHVzaChwYXJhbXMsIGhlYWRlci5zbGljZShzdGFydCwgZW5kKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzZCAvKiAnPScgKi8gJiYgc3RhcnQgIT09IC0xICYmIGVuZCA9PT0gLTEpIHtcbiAgICAgICAgcGFyYW1OYW1lID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL1xuICAgICAgLy8gVGhlIHZhbHVlIG9mIGEgcXVvdGVkLXN0cmluZyBhZnRlciB1bmVzY2FwaW5nIG11c3QgY29uZm9ybSB0byB0aGVcbiAgICAgIC8vIHRva2VuIEFCTkYsIHNvIG9ubHkgdG9rZW4gY2hhcmFjdGVycyBhcmUgdmFsaWQuXG4gICAgICAvLyBSZWY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG4gICAgICAvL1xuICAgICAgaWYgKGlzRXNjYXBpbmcpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKCFtdXN0VW5lc2NhcGUpIG11c3RVbmVzY2FwZSA9IHRydWU7XG4gICAgICAgIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZXMpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAvKiAnXCInICovICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgIGluUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVjIC8qICdcXCcgKi8pIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICYmIGhlYWRlci5jaGFyQ29kZUF0KGkgLSAxKSA9PT0gMHgzZCkge1xuICAgICAgICBpblF1b3RlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSAtMSAmJiAoY29kZSA9PT0gMHgyMCB8fCBjb2RlID09PSAweDA5KSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgzYiB8fCBjb2RlID09PSAweDJjKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuICAgICAgICBsZXQgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgICAgIG11c3RVbmVzY2FwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGluUXVvdGVzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gIGNvbnN0IHRva2VuID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHVzaChvZmZlcnMsIHRva2VuLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwYXJhbU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcHVzaChwYXJhbXMsIHRva2VuLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKG11c3RVbmVzY2FwZSkge1xuICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdG9rZW4ucmVwbGFjZSgvXFxcXC9nLCAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIG9mZmVycztcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgIGhlYWRlciBmaWVsZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9ucyBUaGUgbWFwIG9mIGV4dGVuc2lvbnMgYW5kIHBhcmFtZXRlcnMgdG8gZm9ybWF0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gb2JqZWN0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdChleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKVxuICAgIC5tYXAoKGV4dGVuc2lvbikgPT4ge1xuICAgICAgbGV0IGNvbmZpZ3VyYXRpb25zID0gZXh0ZW5zaW9uc1tleHRlbnNpb25dO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3VyYXRpb25zKSkgY29uZmlndXJhdGlvbnMgPSBbY29uZmlndXJhdGlvbnNdO1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIC5tYXAoKHBhcmFtcykgPT4ge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uXVxuICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgICAgICAgICAgICAgICAubWFwKCh2KSA9PiAodiA9PT0gdHJ1ZSA/IGsgOiBgJHtrfT0ke3Z9YCkpXG4gICAgICAgICAgICAgICAgICAuam9pbignOyAnKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB9KVxuICAgIC5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZm9ybWF0LCBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/limiter.js":
/*!********************************************!*\
  !*** ../../node_modules/ws/lib/limiter.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\n\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n\n\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n\n\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n\n}\n\nmodule.exports = Limiter;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQTFDQTs7QUE2Q0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcz9hYmEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qga0RvbmUgPSBTeW1ib2woJ2tEb25lJyk7XG5jb25zdCBrUnVuID0gU3ltYm9sKCdrUnVuJyk7XG5cbi8qKlxuICogQSB2ZXJ5IHNpbXBsZSBqb2IgcXVldWUgd2l0aCBhZGp1c3RhYmxlIGNvbmN1cnJlbmN5LiBBZGFwdGVkIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TVFJNTC9hc3luYy1saW1pdGVyXG4gKi9cbmNsYXNzIExpbWl0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgTGltaXRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIFRoZSBtYXhpbXVtIG51bWJlciBvZiBqb2JzIGFsbG93ZWRcbiAgICogICAgIHRvIHJ1biBjb25jdXJyZW50bHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmN1cnJlbmN5KSB7XG4gICAgdGhpc1trRG9uZV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmctLTtcbiAgICAgIHRoaXNba1J1bl0oKTtcbiAgICB9O1xuICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCBJbmZpbml0eTtcbiAgICB0aGlzLmpvYnMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmcgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgVGhlIGpvYiB0byBydW5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkKGpvYikge1xuICAgIHRoaXMuam9icy5wdXNoKGpvYik7XG4gICAgdGhpc1trUnVuXSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBqb2IgZnJvbSB0aGUgcXVldWUgYW5kIHJ1bnMgaXQgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBba1J1bl0oKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZyA9PT0gdGhpcy5jb25jdXJyZW5jeSkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuam9icy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9icy5zaGlmdCgpO1xuXG4gICAgICB0aGlzLnBlbmRpbmcrKztcbiAgICAgIGpvYih0aGlzW2tEb25lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGltaXRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/permessage-deflate.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ws/lib/permessage-deflate.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"../../node_modules/ws/lib/buffer-util.js\");\n\nconst Limiter = __webpack_require__(/*! ./limiter */ \"../../node_modules/ws/lib/limiter.js\");\n\nconst {\n  kStatusCode,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error'); //\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\n\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */\n\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n  /**\n   * @type {String}\n   */\n\n\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n\n\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n\n\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n\n\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n\n      this._deflate = null;\n\n      if (callback) {\n        callback(new Error('The deflate stream was closed while data was being processed'));\n      }\n    }\n  }\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n\n\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find(params => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n\n\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    }\n\n    return params;\n  }\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n\n\n  normalizeParams(configurations) {\n    configurations.forEach(params => {\n      Object.keys(params).forEach(key => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n            }\n\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n\n          value = num;\n        } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {\n          if (value !== true) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n\n\n  decompress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n\n\n  compress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n\n\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({ ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n\n      this._inflate.on('error', inflateOnError);\n\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n\n\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({ ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = []; //\n      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n      // `zlib.DeflateRaw` instance is closed while data is being processed.\n      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n      // time due to an abnormal WebSocket closure.\n      //\n\n      this._deflate.on('error', NOOP);\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) data = data.slice(0, data.length - 4); //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n\n}\n\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\n\n\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7Ozs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUZBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQXBiQTs7QUF1YkE7QUFFQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzP2ZlMjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgTGltaXRlciA9IHJlcXVpcmUoJy4vbGltaXRlcicpO1xuY29uc3QgeyBrU3RhdHVzQ29kZSwgTk9PUCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzXSBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBpbmZsYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAyNF0gU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoXG4gICAqICAgICBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGNvbXByZXNzZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yXG4gICAqICAgICBjbGllbnQgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIC8vXG4gICAgICAvLyBBbiBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCwgb25seSBvbiBOb2RlLmpzIDwgMTAuMC4wLCBpZiB0aGVcbiAgICAgIC8vIGB6bGliLkRlZmxhdGVSYXdgIGluc3RhbmNlIGlzIGNsb3NlZCB3aGlsZSBkYXRhIGlzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYCBpcyBjYWxsZWQgYXQgdGhlIHdyb25nXG4gICAgICAvLyB0aW1lIGR1ZSB0byBhbiBhYm5vcm1hbCBXZWJTb2NrZXQgY2xvc3VyZS5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdlcnJvcicsIE5PT1ApO1xuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4pIGRhdGEgPSBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gNCk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJNZXNzYWdlRGVmbGF0ZTtcblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcbiAgdGhpc1trRXJyb3JdLmNvZGUgPSAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJztcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG4gIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/receiver.js":
/*!*********************************************!*\
  !*** ../../node_modules/ws/lib/receiver.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  Writable\n} = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../node_modules/ws/lib/permessage-deflate.js\");\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n\nconst {\n  concat,\n  toArrayBuffer,\n  unmask\n} = __webpack_require__(/*! ./buffer-util */ \"../../node_modules/ws/lib/buffer-util.js\");\n\nconst {\n  isValidStatusCode,\n  isValidUTF8\n} = __webpack_require__(/*! ./validation */ \"../../node_modules/ws/lib/validation.js\");\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\n\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} [binaryType=nodebuffer] The type for binary data\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Boolean} [isServer=false] Specifies whether to operate in client or\n   *     server mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(binaryType, extensions, isServer, maxPayload) {\n    super();\n    this._binaryType = binaryType || BINARY_TYPES[0];\n    this[kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._isServer = !!isServer;\n    this._maxPayload = maxPayload | 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n    this._bufferedBytes += chunk.length;\n\n    this._buffers.push(chunk);\n\n    this.startLoop(cb);\n  }\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n\n\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n\n        case GET_MASK:\n          this.getMask();\n          break;\n\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, 'WS_ERR_INVALID_OPCODE');\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0); //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n\n\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n\n\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'));\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n      this.startLoop(cb);\n    });\n  }\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n\n\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n\n\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n\n}\n\nmodule.exports = Receiver;\n/**\n * Builds an error object.\n *\n * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @param {String} errorCode The exposed error code\n * @return {(Error|RangeError)} The error\n * @private\n */\n\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode] = statusCode;\n  return err;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFPQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBT0E7O0FBRUE7QUFHQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBOztBQUVBO0FBRUE7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQVNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFPQTs7QUFFQTs7QUFFQTtBQUNBO0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQTFpQkE7O0FBNmlCQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanM/NmRkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBrU3RhdHVzQ29kZSxcbiAga1dlYlNvY2tldFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGNvbmNhdCwgdG9BcnJheUJ1ZmZlciwgdW5tYXNrIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlLCBpc1ZhbGlkVVRGOCB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IEdFVF9JTkZPID0gMDtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF8xNiA9IDE7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfNjQgPSAyO1xuY29uc3QgR0VUX01BU0sgPSAzO1xuY29uc3QgR0VUX0RBVEEgPSA0O1xuY29uc3QgSU5GTEFUSU5HID0gNTtcblxuLyoqXG4gKiBIeUJpIFJlY2VpdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIFdyaXRhYmxlXG4gKi9cbmNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2JpbmFyeVR5cGU9bm9kZWJ1ZmZlcl0gVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdG8gb3BlcmF0ZSBpbiBjbGllbnQgb3JcbiAgICogICAgIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihiaW5hcnlUeXBlLCBleHRlbnNpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fYnVmZmVycyA9IFtdO1xuXG4gICAgdGhpcy5fY29tcHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21hc2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgdGhpcy5fbWFza2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZmluID0gZmFsc2U7XG4gICAgdGhpcy5fb3Bjb2RlID0gMDtcblxuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGBXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgVGhlIGNodW5rIG9mIGRhdGEgdG8gd3JpdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2YgYGNodW5rYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3N0YXRlID09IEdFVF9JTkZPKSByZXR1cm4gY2IoKTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGBuYCBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnN1bWVcbiAgICogQHJldHVybiB7QnVmZmVyfSBUaGUgY29uc3VtZWQgYnl0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN1bWUobikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gbjtcblxuICAgIGlmIChuID09PSB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTtcblxuICAgIGlmIChuIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICB0aGlzLl9idWZmZXJzWzBdID0gYnVmLnNsaWNlKG4pO1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcblxuICAgIHJldHVybiBkc3Q7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBwYXJzaW5nIGxvb3AuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydExvb3AoY2IpIHtcbiAgICBsZXQgZXJyO1xuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0SW5mbygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGgxNigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGg2NCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gYElORkxBVElOR2BcbiAgICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMuX2xvb3ApO1xuXG4gICAgY2IoZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAoYnVmWzBdICYgMHg0MCkgPT09IDB4NDA7XG5cbiAgICBpZiAoY29tcHJlc3NlZCAmJiAhdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMHg4MCkgPT09IDB4ODA7XG4gICAgdGhpcy5fb3Bjb2RlID0gYnVmWzBdICYgMHgwZjtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gYnVmWzFdICYgMHg3ZjtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDApIHtcbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3ICYmIHRoaXMuX29wY29kZSA8IDB4MGIpIHtcbiAgICAgIGlmICghdGhpcy5fZmluKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ0ZJTiBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfRklOJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID4gMHg3ZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9maW4gJiYgIXRoaXMuX2ZyYWdtZW50ZWQpIHRoaXMuX2ZyYWdtZW50ZWQgPSB0aGlzLl9vcGNvZGU7XG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xuXG4gICAgaWYgKHRoaXMuX2lzU2VydmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX21hc2tlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNQVNLIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9NQVNLJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdNQVNLIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfTUFTSydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNikgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XG4gICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF82NDtcbiAgICBlbHNlIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDE2KCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSB0aGlzLmNvbnN1bWUoMikucmVhZFVJbnQxNkJFKDApO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzY0KS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDY0KCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSg4KTtcbiAgICBjb25zdCBudW0gPSBidWYucmVhZFVJbnQzMkJFKDApO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMS4gQW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAgICAvLyBpZiBwYXlsb2FkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBudW1iZXIuXG4gICAgLy9cbiAgICBpZiAobnVtID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdVbnN1cHBvcnRlZCBXZWJTb2NrZXQgZnJhbWU6IHBheWxvYWQgbGVuZ3RoID4gMl41MyAtIDEnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgMTAwOSxcbiAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9EQVRBX1BBWUxPQURfTEVOR1RIJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gbnVtICogTWF0aC5wb3coMiwgMzIpICsgYnVmLnJlYWRVSW50MzJCRSg0KTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogUGF5bG9hZCBsZW5ndGggaGFzIGJlZW4gcmVhZC5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGF2ZUxlbmd0aCgpIHtcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCAmJiB0aGlzLl9vcGNvZGUgPCAweDA4KSB7XG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggKz0gdGhpcy5fcGF5bG9hZExlbmd0aDtcbiAgICAgIGlmICh0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIDEwMDksXG4gICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBtYXNrIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWFzaygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgZGF0YSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcbiAgICAgIGlmICh0aGlzLl9tYXNrZWQpIHVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykgcmV0dXJuIHRoaXMuY29udHJvbE1lc3NhZ2UoZGF0YSk7XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ2h0IGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3NlcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5kZWNvbXByZXNzKGRhdGEsIHRoaXMuX2ZpbiwgKGVyciwgYnVmKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgaWYgKGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZUxlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gY2IoXG4gICAgICAgICAgICBlcnJvcihcbiAgICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goYnVmKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXIgPSB0aGlzLmRhdGFNZXNzYWdlKCk7XG4gICAgICBpZiAoZXIpIHJldHVybiBjYihlcik7XG5cbiAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2Zpbikge1xuICAgICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XG4gICAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG5cbiAgICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdub2RlYnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgZGF0YSA9IHRvQXJyYXlCdWZmZXIoY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1Zi50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgMTAwNSwgJycpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAxJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA5KSB7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgcmV0dXJuIGVycjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/sender.js":
/*!*******************************************!*\
  !*** ../../node_modules/ws/lib/sender.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n\nconst net = __webpack_require__(/*! net */ \"net\");\n\nconst tls = __webpack_require__(/*! tls */ \"tls\");\n\nconst {\n  randomFillSync\n} = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../node_modules/ws/lib/permessage-deflate.js\");\n\nconst {\n  EMPTY_BUFFER\n} = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n\nconst {\n  isValidStatusCode\n} = __webpack_require__(/*! ./validation */ \"../../node_modules/ws/lib/validation.js\");\n\nconst {\n  mask: applyMask,\n  toBuffer\n} = __webpack_require__(/*! ./buffer-util */ \"../../node_modules/ws/lib/buffer-util.js\");\n\nconst mask = Buffer.alloc(4);\n/**\n * HyBi Sender implementation.\n */\n\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n\n\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n    randomFillSync(mask, 0, 4);\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {String} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doClose(data, mask, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x08,\n      mask,\n      readOnly: false\n    }), cb);\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask,\n      readOnly\n    }), cb);\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x0a,\n      mask,\n      readOnly\n    }), cb);\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(buf, {\n        fin: options.fin,\n        rsv1: false,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      }), cb);\n    }\n  }\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    this._bufferedBytes += data.length;\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error('The socket was closed while data was being compressed');\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const callback = this._queue[i][4];\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= data.length;\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n\n\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n\n\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n\n      this._socket.write(list[0]);\n\n      this._socket.write(list[1], cb);\n\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n\n}\n\nmodule.exports = Sender;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBRUE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUVBOzs7O0FBR0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFTQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBU0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbllBOztBQXNZQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanM/ZDcxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5uZXR8dGxzJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tRmlsbFN5bmMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IG1hc2sgPSBCdWZmZXIuYWxsb2MoNCk7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEByZXR1cm4ge0J1ZmZlcltdfSBUaGUgZnJhbWVkIGRhdGEgYXMgYSBsaXN0IG9mIGBCdWZmZXJgIGluc3RhbmNlc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHk7XG4gICAgbGV0IG9mZnNldCA9IG9wdGlvbnMubWFzayA/IDYgOiAyO1xuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YS5sZW5ndGggKyBvZmZzZXQgOiBvZmZzZXQpO1xuXG4gICAgdGFyZ2V0WzBdID0gb3B0aW9ucy5maW4gPyBvcHRpb25zLm9wY29kZSB8IDB4ODAgOiBvcHRpb25zLm9wY29kZTtcbiAgICBpZiAob3B0aW9ucy5yc3YxKSB0YXJnZXRbMF0gfD0gMHg0MDtcblxuICAgIHRhcmdldFsxXSA9IHBheWxvYWRMZW5ndGg7XG5cbiAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MTZCRShkYXRhLmxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQzMkJFKDAsIDIpO1xuICAgICAgdGFyZ2V0LndyaXRlVUludDMyQkUoZGF0YS5sZW5ndGgsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICByYW5kb21GaWxsU3luYyhtYXNrLCAwLCA0KTtcblxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgZGF0YSA9PT0gJycpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9DbG9zZSwgYnVmLCBtYXNrLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvQ2xvc2UoYnVmLCBtYXNrLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBjbG9zZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb0Nsb3NlKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IHRydWUsXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICAgIG1hc2ssXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZVxuICAgICAgfSksXG4gICAgICBjYlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBjb25zdCBidWYgPSB0b0J1ZmZlcihkYXRhKTtcblxuICAgIGlmIChidWYubGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRvUGluZywgYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb1BpbmcoYnVmLCBtYXNrLCB0b0J1ZmZlci5yZWFkT25seSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYW5kIHNlbmRzIGEgcGluZyBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZSBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkb1BpbmcoZGF0YSwgbWFzaywgcmVhZE9ubHksIGNiKSB7XG4gICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICBmaW46IHRydWUsXG4gICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICBvcGNvZGU6IDB4MDksXG4gICAgICAgIG1hc2ssXG4gICAgICAgIHJlYWRPbmx5XG4gICAgICB9KSxcbiAgICAgIGNiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9Qb25nLCBidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUG9uZyhidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBwb25nIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUG9uZyhkYXRhLCBtYXNrLCByZWFkT25seSwgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwYSxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZGF0YSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGNvbXByZXNzIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeVxuICAgKiAgICAgb3IgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgICBpZiAodGhpcy5fZmlyc3RGcmFnbWVudCkge1xuICAgICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IGZhbHNlO1xuICAgICAgaWYgKHJzdjEgJiYgcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgcnN2MSA9IGJ1Zi5sZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgaWYgKHBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICByc3YxLFxuICAgICAgICBvcGNvZGUsXG4gICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgcmVhZE9ubHk6IHRvQnVmZmVyLnJlYWRPbmx5XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goYnVmLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgICAgU2VuZGVyLmZyYW1lKGJ1Ziwge1xuICAgICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgICAgb3Bjb2RlLFxuICAgICAgICAgIG1hc2s6IG9wdGlvbnMubWFzayxcbiAgICAgICAgICByZWFkT25seTogdG9CdWZmZXIucmVhZE9ubHlcbiAgICAgICAgfSksXG4gICAgICAgIGNiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gdHJ1ZTtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX3F1ZXVlW2ldWzRdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBkYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICghdGhpcy5fZGVmbGF0aW5nICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZEZyYW1lKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0pO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/stream.js":
/*!*******************************************!*\
  !*** ../../node_modules/ws/lib/stream.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\n\n\nconst {\n  Duplex\n} = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\n\n\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\n\n\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\n\n\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\n\n\nfunction createWebSocketStream(ws, options) {\n  let resumeOnReceiverDrain = true;\n  let terminateOnDestroy = true;\n\n  function receiverOnDrain() {\n    if (resumeOnReceiverDrain) ws._socket.resume();\n  }\n\n  if (ws.readyState === ws.CONNECTING) {\n    ws.once('open', function open() {\n      ws._receiver.removeAllListeners('drain');\n\n      ws._receiver.on('drain', receiverOnDrain);\n    });\n  } else {\n    ws._receiver.removeAllListeners('drain');\n\n    ws._receiver.on('drain', receiverOnDrain);\n  }\n\n  const duplex = new Duplex({ ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on('message', function message(msg) {\n    if (!duplex.push(msg)) {\n      resumeOnReceiverDrain = false;\n\n      ws._socket.pause();\n    }\n  });\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return; // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    } // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n\n\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {\n      resumeOnReceiverDrain = true;\n      if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n    }\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcz80YTlkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0R1cGxleH0gVGhlIGR1cGxleCBzdHJlYW1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0U3RyZWFtKHdzLCBvcHRpb25zKSB7XG4gIGxldCByZXN1bWVPblJlY2VpdmVyRHJhaW4gPSB0cnVlO1xuICBsZXQgdGVybWluYXRlT25EZXN0cm95ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gICAgaWYgKHJlc3VtZU9uUmVjZWl2ZXJEcmFpbikgd3MuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICB3cy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdkcmFpbicpO1xuICAgICAgd3MuX3JlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd3MuX3JlY2VpdmVyLnJlbW92ZUFsbExpc3RlbmVycygnZHJhaW4nKTtcbiAgICB3cy5fcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgfVxuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKCFkdXBsZXgucHVzaChtc2cpKSB7XG4gICAgICByZXN1bWVPblJlY2VpdmVyRHJhaW4gPSBmYWxzZTtcbiAgICAgIHdzLl9zb2NrZXQucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChcbiAgICAgICh3cy5yZWFkeVN0YXRlID09PSB3cy5PUEVOIHx8IHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NJTkcpICYmXG4gICAgICAhcmVzdW1lT25SZWNlaXZlckRyYWluXG4gICAgKSB7XG4gICAgICByZXN1bWVPblJlY2VpdmVyRHJhaW4gPSB0cnVlO1xuICAgICAgaWYgKCF3cy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSB3cy5fc29ja2V0LnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICBkdXBsZXguX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/validation.js":
/*!***********************************************!*\
  !*** ../../node_modules/ws/lib/validation.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\n\nfunction isValidStatusCode(code) {\n  return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\n\n\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n          return false;\n        }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong\n      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n      ) {\n          return false;\n        }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong\n      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n      ) {\n          return false;\n        }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntry {\n  let isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"utf-8-validate\");\n  /* istanbul ignore if */\n\n\n  if (typeof isValidUTF8 === 'object') {\n    isValidUTF8 = isValidUTF8.Validation.isValidUTF8; // utf-8-validate@<3.0.0\n  }\n\n  module.exports = {\n    isValidStatusCode,\n\n    isValidUTF8(buf) {\n      return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    }\n\n  };\n} catch (e)\n/* istanbul ignore next */\n{\n  module.exports = {\n    isValidStatusCode,\n    isValidUTF8: _isValidUTF8\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQVFBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFMQTtBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQU5BO0FBU0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBSkE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanM/NGFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhdHVzIGNvZGUgaXMgYWxsb3dlZCBpbiBhIGNsb3NlIGZyYW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBzdGF0dXMgY29kZSBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICAoY29kZSA+PSAxMDAwICYmXG4gICAgICBjb2RlIDw9IDEwMTQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDQgJiZcbiAgICAgIGNvZGUgIT09IDEwMDUgJiZcbiAgICAgIGNvZGUgIT09IDEwMDYpIHx8XG4gICAgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYnVmZmVyIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOC5cbiAqIFBvcnRlZCBmcm9tIGh0dHBzOi8vd3d3LmNsLmNhbS5hYy51ay8lN0VtZ2syNS91Y3MvdXRmOF9jaGVjay5jIGJ5XG4gKiBNYXJrdXMgS3Vobi5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgYnVmYCBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTgsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfaXNWYWxpZFVURjgoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMHg4MCkgPT09IDApIHtcbiAgICAgIC8vIDB4eHh4eHh4XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAxID09PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgLy8gT3ZlcmxvbmdcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMjtcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgLy8gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDIgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZWQgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHhhMCkgLy8gU3Vycm9nYXRlIChVK0Q4MDAgLSBVK0RGRkYpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDM7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgIC8vIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAzID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgM10gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldID09PSAweGYwICYmIChidWZbaSArIDFdICYgMHhmMCkgPT09IDB4ODApIHx8IC8vIE92ZXJsb25nXG4gICAgICAgIChidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYpIHx8XG4gICAgICAgIGJ1ZltpXSA+IDB4ZjQgLy8gPiBVKzEwRkZGRlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnRyeSB7XG4gIGxldCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaXNWYWxpZFVURjggPT09ICdvYmplY3QnKSB7XG4gICAgaXNWYWxpZFVURjggPSBpc1ZhbGlkVVRGOC5WYWxpZGF0aW9uLmlzVmFsaWRVVEY4OyAvLyB1dGYtOC12YWxpZGF0ZUA8My4wLjBcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzVmFsaWRTdGF0dXNDb2RlLFxuICAgIGlzVmFsaWRVVEY4KGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAxNTAgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVmFsaWRVVEY4KGJ1Zik7XG4gICAgfVxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgICBpc1ZhbGlkVVRGODogX2lzVmFsaWRVVEY4XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/websocket-server.js":
/*!*****************************************************!*\
  !*** ../../node_modules/ws/lib/websocket-server.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls|https$\" }] */\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\n\nconst http = __webpack_require__(/*! http */ \"http\");\n\nconst https = __webpack_require__(/*! https */ \"https\");\n\nconst net = __webpack_require__(/*! net */ \"net\");\n\nconst tls = __webpack_require__(/*! tls */ \"tls\");\n\nconst {\n  createHash\n} = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../node_modules/ws/lib/permessage-deflate.js\");\n\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"../../node_modules/ws/lib/websocket.js\");\n\nconst {\n  format,\n  parse\n} = __webpack_require__(/*! ./extension */ \"../../node_modules/ws/lib/extension.js\");\n\nconst {\n  GUID,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\n\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    };\n\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + 'must be specified');\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n    this._state = RUNNING;\n  }\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n\n\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n  /**\n   * Close the server.\n   *\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  close(cb) {\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSED) {\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING; //\n    // Terminate all associated clients.\n    //\n\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n\n      this._removeListeners = this._server = null; //\n      // Close the http server if it was internally created.\n      //\n\n      if (this.options.port != null) {\n        server.close(emitClose.bind(undefined, this));\n        return;\n      }\n    }\n\n    process.nextTick(emitClose, this);\n  }\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n\n\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n\n\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n    const key = req.headers['sec-websocket-key'] !== undefined ? req.headers['sec-websocket-key'].trim() : false;\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (req.method !== 'GET' || upgrade === undefined || upgrade.toLowerCase() !== 'websocket' || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n\n      try {\n        const offers = parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    } //\n    // Optionally call external client verification handler.\n    //\n\n\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(key, extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(key, extensions, req, socket, head, cb);\n  }\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n\n\n  completeUpgrade(key, extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${digest}`];\n    const ws = new WebSocket(null);\n    let protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.split(',').map(trim); //\n      // Optionally call external protocol selection handler.\n      //\n\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    } //\n    // Allow external modification/inspection of handshake headers.\n    //\n\n\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws, req);\n  }\n\n}\n\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\n\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\n\n\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n/**\n * Handle premature socket errors.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\n\n\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-Type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n    socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join('\\r\\n') + '\\r\\n\\r\\n' + message);\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n/**\n * Remove whitespace characters from both ends of a string.\n *\n * @param {String} str The string\n * @return {String} A new string representing `str` stripped of whitespace\n *     characters from both its beginning and end\n * @private\n */\n\n\nfunction trim(str) {\n  return str.trim();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7O0FBZUE7QUFLQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFDQTtBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQVNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7O0FBRUE7QUFFQTtBQUlBO0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBN1VBOztBQWdWQTtBQUVBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBUUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcz9lN2JjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXm5ldHx0bHN8aHR0cHMkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcblxuY29uc3QgUlVOTklORyA9IDA7XG5jb25zdCBDTE9TSU5HID0gMTtcbmNvbnN0IENMT1NFRCA9IDI7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0IHNlcnZlci5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKGNiKSB0aGlzLm9uY2UoJ2Nsb3NlJywgY2IpO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICAvL1xuICAgIC8vIFRlcm1pbmF0ZSBhbGwgYXNzb2NpYXRlZCBjbGllbnRzLlxuICAgIC8vXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgdGhpcy5jbGllbnRzKSBjbGllbnQudGVybWluYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgaWYgKHNlcnZlcikge1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gQ2xvc2UgdGhlIGh0dHAgc2VydmVyIGlmIGl0IHdhcyBpbnRlcm5hbGx5IGNyZWF0ZWQuXG4gICAgICAvL1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgICAgc2VydmVyLmNsb3NlKGVtaXRDbG9zZS5iaW5kKHVuZGVmaW5lZCwgdGhpcykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGVcbiAgICogICAgIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9XG4gICAgICByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10udHJpbSgpXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdXBncmFkZSA9IHJlcS5oZWFkZXJzLnVwZ3JhZGU7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgcmVxLm1ldGhvZCAhPT0gJ0dFVCcgfHxcbiAgICAgIHVwZ3JhZGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0JyB8fFxuICAgICAgIWtleSB8fFxuICAgICAgIWtleVJlZ2V4LnRlc3Qoa2V5KSB8fFxuICAgICAgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHx8XG4gICAgICAhdGhpcy5zaG91bGRIYW5kbGUocmVxKVxuICAgICkge1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gcGFyc2UocmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddKTtcblxuICAgICAgICBpZiAob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICAgICAgZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSA9IHBlck1lc3NhZ2VEZWZsYXRlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBjbGllbnQgdmVyaWZpY2F0aW9uIGhhbmRsZXIuXG4gICAgLy9cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudCkge1xuICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgb3JpZ2luOlxuICAgICAgICAgIHJlcS5oZWFkZXJzW2Ake3ZlcnNpb24gPT09IDggPyAnc2VjLXdlYnNvY2tldC1vcmlnaW4nIDogJ29yaWdpbid9YF0sXG4gICAgICAgIHNlY3VyZTogISEocmVxLnNvY2tldC5hdXRob3JpemVkIHx8IHJlcS5zb2NrZXQuZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvLCAodmVyaWZpZWQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlIHx8IDQwMSwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoa2V5LCBleHRlbnNpb25zLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZ3JhZGUgdGhlIGNvbm5lY3Rpb24gdG8gV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSB2YWx1ZSBvZiB0aGUgYFNlYy1XZWJTb2NrZXQtS2V5YCBoZWFkZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGtleSwgZXh0ZW5zaW9ucywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG4gICAgLy9cbiAgICAvLyBEZXN0cm95IHRoZSBzb2NrZXQgaWYgdGhlIGNsaWVudCBoYXMgYWxyZWFkeSBzZW50IGEgRklOIHBhY2tldC5cbiAgICAvL1xuICAgIGlmICghc29ja2V0LnJlYWRhYmxlIHx8ICFzb2NrZXQud3JpdGFibGUpIHJldHVybiBzb2NrZXQuZGVzdHJveSgpO1xuXG4gICAgaWYgKHNvY2tldFtrV2ViU29ja2V0XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnc2VydmVyLmhhbmRsZVVwZ3JhZGUoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgJyArXG4gICAgICAgICAgJ3NvY2tldCwgcG9zc2libHkgZHVlIHRvIGEgbWlzY29uZmlndXJhdGlvbidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRlID4gUlVOTklORykgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNTAzKTtcblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgJ0hUVFAvMS4xIDEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAgICdVcGdyYWRlOiB3ZWJzb2NrZXQnLFxuICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGUnLFxuICAgICAgYFNlYy1XZWJTb2NrZXQtQWNjZXB0OiAke2RpZ2VzdH1gXG4gICAgXTtcblxuICAgIGNvbnN0IHdzID0gbmV3IFdlYlNvY2tldChudWxsKTtcbiAgICBsZXQgcHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuXG4gICAgaWYgKHByb3RvY29sKSB7XG4gICAgICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCcsJykubWFwKHRyaW0pO1xuXG4gICAgICAvL1xuICAgICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIHByb3RvY29sIHNlbGVjdGlvbiBoYW5kbGVyLlxuICAgICAgLy9cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKSB7XG4gICAgICAgIHByb3RvY29sID0gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbCwgcmVxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3RvY29sID0gcHJvdG9jb2xbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkKTtcblxuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIHRoaXMuY2xpZW50cy5hZGQod3MpO1xuICAgICAgd3Mub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5jbGllbnRzLmRlbGV0ZSh3cykpO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBwcmVtYXR1cmUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIGlmIChzb2NrZXQud3JpdGFibGUpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQ29ubmVjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH07XG5cbiAgICBzb2NrZXQud3JpdGUoXG4gICAgICBgSFRUUC8xLjEgJHtjb2RlfSAke2h0dHAuU1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgICAuam9pbignXFxyXFxuJykgK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1lc3NhZ2VcbiAgICApO1xuICB9XG5cbiAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICBzb2NrZXQuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIFJlbW92ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgZnJvbSBib3RoIGVuZHMgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgbmV3IHN0cmluZyByZXByZXNlbnRpbmcgYHN0cmAgc3RyaXBwZWQgb2Ygd2hpdGVzcGFjZVxuICogICAgIGNoYXJhY3RlcnMgZnJvbSBib3RoIGl0cyBiZWdpbm5pbmcgYW5kIGVuZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "../../node_modules/ws/lib/websocket.js":
/*!**********************************************!*\
  !*** ../../node_modules/ws/lib/websocket.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\n/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\n\nconst https = __webpack_require__(/*! https */ \"https\");\n\nconst http = __webpack_require__(/*! http */ \"http\");\n\nconst net = __webpack_require__(/*! net */ \"net\");\n\nconst tls = __webpack_require__(/*! tls */ \"tls\");\n\nconst {\n  randomBytes,\n  createHash\n} = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst {\n  Readable\n} = __webpack_require__(/*! stream */ \"stream\");\n\nconst {\n  URL\n} = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"../../node_modules/ws/lib/permessage-deflate.js\");\n\nconst Receiver = __webpack_require__(/*! ./receiver */ \"../../node_modules/ws/lib/receiver.js\");\n\nconst Sender = __webpack_require__(/*! ./sender */ \"../../node_modules/ws/lib/sender.js\");\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"../../node_modules/ws/lib/constants.js\");\n\nconst {\n  addEventListener,\n  removeEventListener\n} = __webpack_require__(/*! ./event-target */ \"../../node_modules/ws/lib/event-target.js\");\n\nconst {\n  format,\n  parse\n} = __webpack_require__(/*! ./extension */ \"../../node_modules/ws/lib/extension.js\");\n\nconst {\n  toBuffer\n} = __webpack_require__(/*! ./buffer-util */ \"../../node_modules/ws/lib/buffer-util.js\");\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\n\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._extensions = {};\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n\n\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type; //\n    // Allow to change `binaryType` on the fly.\n    //\n\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onclose() {\n    return undefined;\n  }\n  /* istanbul ignore next */\n\n\n  set onclose(listener) {}\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onerror() {\n    return undefined;\n  }\n  /* istanbul ignore next */\n\n\n  set onerror(listener) {}\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onopen() {\n    return undefined;\n  }\n  /* istanbul ignore next */\n\n\n  set onopen(listener) {}\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onmessage() {\n    return undefined;\n  }\n  /* istanbul ignore next */\n\n\n  set onmessage(listener) {}\n  /**\n   * @type {String}\n   */\n\n\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get readyState() {\n    return this._readyState;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get url() {\n    return this._url;\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} [maxPayload=0] The maximum allowed message size\n   * @private\n   */\n\n\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n\n\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {String} [data] A string explaining why the connection is closing\n   * @public\n   */\n\n\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    }); //\n    // Specify a timeout for the closing handshake to complete.\n    //\n\n\n    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n\n\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n\n      this._socket.destroy();\n    }\n  }\n\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\n\n\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'protocol', 'readyState', 'url'].forEach(property => {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n}); //\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n\n    get() {\n      const listeners = this.listeners(method);\n\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n\n    set(listener) {\n      const listeners = this.listeners(method);\n\n      for (let i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n\n      this.addEventListener(method, listener);\n    }\n\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {String} [protocols] The subprotocols\n * @param {Object} [options] Connection options\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @private\n */\n\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    parsedUrl = new URL(address);\n    websocket._url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    const err = new Error(`Invalid URL: ${websocket.url}`);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalUnixSocket = isUnixSocket;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isUnixSocket ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers; //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n\n      options = { ...options,\n        headers: {}\n      };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else {\n      const isSameHost = isUnixSocket ? websocket._originalUnixSocket ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalUnixSocket ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || websocket._originalSecure && !isSecure) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost) delete opts.headers.host;\n        opts.auth = undefined;\n      }\n    } //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n\n\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n  }\n\n  let req = websocket._req = get(opts);\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', err => {\n    if (req === null || req.aborted) return;\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n  req.on('response', res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (err) {\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res); //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    let protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (extensionNames.length) {\n        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n          const message = 'Server indicated an extension that was not requested';\n          abortHandshake(websocket, socket, message);\n          return;\n        }\n\n        try {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n        } catch (err) {\n          const message = 'Invalid Sec-WebSocket-Extensions header';\n          abortHandshake(websocket, socket, message);\n          return;\n        }\n\n        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\n\n\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\n\n\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\n\n\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length; //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    cb(err);\n  }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\n\n\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\n\n\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\n\n\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData); //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n\n\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\n\n\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\n\n\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\n\n\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\n\n\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\n\n\nfunction resume(stream) {\n  stream.resume();\n}\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\n\n\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  let chunk; //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\n\n\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n\n  websocket._receiver.end();\n\n  this.end();\n}\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BOztBQVFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7Ozs7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7Ozs7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7Ozs7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBSUE7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFsWkE7QUFxWkE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFLQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUtBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFLQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUtBOzs7OztBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQVFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBbkJBO0FBcUJBO0FBRUE7QUFDQTtBQUVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7O0FBa0JBO0FBQ0E7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQURBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7QUFFQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBTUE7QUFDQTs7QUFFQTs7QUFFQTtBQUVBOztBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFFQTs7QUFDQTs7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi8uLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcz8yYzhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXlJlYWRhYmxlJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgcmFuZG9tQnl0ZXMsIGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0LFxuICBOT09QXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9ICcnO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIHByb3RvY29scyA9IHByb3RvY29scy5qb2luKCcsICcpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHByb3RvY29scztcbiAgICAgICAgcHJvdG9jb2xzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGRldmlhdGVzIGZyb20gdGhlIFdIQVRXRyBpbnRlcmZhY2Ugc2luY2Ugd3MgZG9lc24ndCBzdXBwb3J0IHRoZVxuICAgKiByZXF1aXJlZCBkZWZhdWx0IFwiYmxvYlwiIHR5cGUgKGluc3RlYWQgd2UgZGVmaW5lIGEgY3VzdG9tIFwibm9kZWJ1ZmZlclwiXG4gICAqIHR5cGUpLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSB0eXBlO1xuXG4gICAgLy9cbiAgICAvLyBBbGxvdyB0byBjaGFuZ2UgYGJpbmFyeVR5cGVgIG9uIHRoZSBmbHkuXG4gICAgLy9cbiAgICBpZiAodGhpcy5fcmVjZWl2ZXIpIHRoaXMuX3JlY2VpdmVyLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50KCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSByZXR1cm4gdGhpcy5fYnVmZmVyZWRBbW91bnQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc2V0IG9uY2xvc2UobGlzdGVuZXIpIHt9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmVycm9yKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBzZXQgb25lcnJvcihsaXN0ZW5lcikge31cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc2V0IG9ub3BlbihsaXN0ZW5lcikge31cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgc2V0IG9ubWVzc2FnZShsaXN0ZW5lcikge31cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBwcm90b2NvbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdG9jb2w7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCByZWFkeVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHRoZSBzb2NrZXQgYW5kIHRoZSBpbnRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGVcbiAgICogICAgIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIHNpemVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG1heFBheWxvYWQpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcihcbiAgICAgIHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWRcbiAgICApO1xuXG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMpO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZGF0YV0gQSBzdHJpbmcgZXhwbGFpbmluZyB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmXG4gICAgICAgICh0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHwgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLl9zZW5kZXIuY2xvc2UoY29kZSwgZGF0YSwgIXRoaXMuX2lzU2VydmVyLCAoZXJyKSA9PiB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxuICAgICAgLy8gd2FudCB0byBrbm93IGlmIHRoZSBjbG9zZSBmcmFtZSBoYXMgYmVlbiBzZW50IGhlcmUuXG4gICAgICAvL1xuICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vXG4gICAgLy8gU3BlY2lmeSBhIHRpbWVvdXQgZm9yIHRoZSBjbG9zaW5nIGhhbmRzaGFrZSB0byBjb21wbGV0ZS5cbiAgICAvL1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3kuYmluZCh0aGlzLl9zb2NrZXQpLFxuICAgICAgY2xvc2VUaW1lb3V0XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwaW5nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5waW5nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBvbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcG9uZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucG9uZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzc10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnldIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnkgb3JcbiAgICogICAgIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIGRhdGEgaXMgd3JpdHRlbiBvdXRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyxcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG5bXG4gICdiaW5hcnlUeXBlJyxcbiAgJ2J1ZmZlcmVkQW1vdW50JyxcbiAgJ2V4dGVuc2lvbnMnLFxuICAncHJvdG9jb2wnLFxuICAncmVhZHlTdGF0ZScsXG4gICd1cmwnXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5fbGlzdGVuZXIpIHJldHVybiBsaXN0ZW5lcnNbaV0uX2xpc3RlbmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2V0KGxpc3RlbmVyKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVtb3ZlIG9ubHkgdGhlIGxpc3RlbmVycyBhZGRlZCB2aWEgYGFkZEV2ZW50TGlzdGVuZXJgLlxuICAgICAgICAvL1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLl9saXN0ZW5lcikgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm90b2NvbHNdIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0geyhCb29sZWFufE9iamVjdCl9IFtvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlPXRydWVdIEVuYWJsZS9kaXNhYmxlXG4gKiAgICAgcGVybWVzc2FnZS1kZWZsYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJvdG9jb2xWZXJzaW9uPTEzXSBWYWx1ZSBvZiB0aGVcbiAqICAgICBgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCBoZWFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5vcmlnaW5dIFZhbHVlIG9mIHRoZSBgT3JpZ2luYCBvclxuICogICAgIGBTZWMtV2ViU29ja2V0LU9yaWdpbmAgaGVhZGVyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICogICAgIHNpemVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9sbG93UmVkaXJlY3RzPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0byBmb2xsb3dcbiAqICAgICByZWRpcmVjdHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcbiAqICAgICBhbGxvd2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY3JlYXRlQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gICAgd2Vic29ja2V0Ll91cmwgPSBhZGRyZXNzLmhyZWY7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB3ZWJzb2NrZXQuX3VybCA9IGFkZHJlc3M7XG4gIH1cblxuICBjb25zdCBpc1VuaXhTb2NrZXQgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICd3cyt1bml4Oic7XG5cbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCAmJiAoIWlzVW5peFNvY2tldCB8fCAhcGFyc2VkVXJsLnBhdGhuYW1lKSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7d2Vic29ja2V0LnVybH1gKTtcblxuICAgIGlmICh3ZWJzb2NrZXQuX3JlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaXNTZWN1cmUgPVxuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonIHx8IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgY29uc3QgZ2V0ID0gaXNTZWN1cmUgPyBodHRwcy5nZXQgOiBodHRwLmdldDtcbiAgbGV0IHBlck1lc3NhZ2VEZWZsYXRlO1xuXG4gIG9wdHMuY3JlYXRlQ29ubmVjdGlvbiA9IGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3Q7XG4gIG9wdHMuZGVmYXVsdFBvcnQgPSBvcHRzLmRlZmF1bHRQb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLnBvcnQgPSBwYXJzZWRVcmwucG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5ob3N0ID0gcGFyc2VkVXJsLmhvc3RuYW1lLnN0YXJ0c1dpdGgoJ1snKVxuICAgID8gcGFyc2VkVXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgIDogcGFyc2VkVXJsLmhvc3RuYW1lO1xuICBvcHRzLmhlYWRlcnMgPSB7XG4gICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IG9wdHMucHJvdG9jb2xWZXJzaW9uLFxuICAgICdTZWMtV2ViU29ja2V0LUtleSc6IGtleSxcbiAgICBDb25uZWN0aW9uOiAnVXBncmFkZScsXG4gICAgVXBncmFkZTogJ3dlYnNvY2tldCcsXG4gICAgLi4ub3B0cy5oZWFkZXJzXG4gIH07XG4gIG9wdHMucGF0aCA9IHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIG9wdHMudGltZW91dCA9IG9wdHMuaGFuZHNoYWtlVGltZW91dDtcblxuICBpZiAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSAhPT0gdHJ1ZSA/IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgOiB7fSxcbiAgICAgIGZhbHNlLFxuICAgICAgb3B0cy5tYXhQYXlsb2FkXG4gICAgKTtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyddID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogcGVyTWVzc2FnZURlZmxhdGUub2ZmZXIoKVxuICAgIH0pO1xuICB9XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHByb3RvY29scztcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cblxuICBpZiAoaXNVbml4U29ja2V0KSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsVW5peFNvY2tldCA9IGlzVW5peFNvY2tldDtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgPSBpc1NlY3VyZTtcbiAgICAgIHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNVbml4U29ja2V0XG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzU2FtZUhvc3QgPSBpc1VuaXhTb2NrZXRcbiAgICAgICAgPyB3ZWJzb2NrZXQuX29yaWdpbmFsVW5peFNvY2tldFxuICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxuICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsVW5peFNvY2tldFxuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3QgPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoO1xuXG4gICAgICBpZiAoIWlzU2FtZUhvc3QgfHwgKHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgJiYgIWlzU2VjdXJlKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXG4gICAgICAgIC8vIGhlYWRlcnMgYXJlIGFsc28gZHJvcHBlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgc3ViZG9tYWluLlxuICAgICAgICAvL1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llO1xuXG4gICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xuXG4gICAgICAgIG9wdHMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cbiAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVxID0gKHdlYnNvY2tldC5fcmVxID0gZ2V0KG9wdHMpKTtcblxuICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCByZXEsICdPcGVuaW5nIGhhbmRzaGFrZSBoYXMgdGltZWQgb3V0Jyk7XG4gICAgfSk7XG4gIH1cblxuICByZXEub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgIGlmIChyZXEgPT09IG51bGwgfHwgcmVxLmFib3J0ZWQpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcbiAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgbGV0IGFkZHI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBuZXcgVVJMKGxvY2F0aW9uLCBhZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkciwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKCF3ZWJzb2NrZXQuZW1pdCgndW5leHBlY3RlZC1yZXNwb25zZScsIHJlcSwgcmVzKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2UoXG4gICAgICAgIHdlYnNvY2tldCxcbiAgICAgICAgcmVxLFxuICAgICAgICBgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2U6ICR7cmVzLnN0YXR1c0NvZGV9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJlcS5vbigndXBncmFkZScsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgIHdlYnNvY2tldC5lbWl0KCd1cGdyYWRlJywgcmVzKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIHVzZXIgbWF5IGhhdmUgY2xvc2VkIHRoZSBjb25uZWN0aW9uIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYHVwZ3JhZGVgXG4gICAgLy8gZXZlbnQuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG5cbiAgICBjb25zdCB1cGdyYWRlID0gcmVzLmhlYWRlcnMudXBncmFkZTtcblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmIChyZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgY29uc3QgcHJvdExpc3QgPSAocHJvdG9jb2xzIHx8ICcnKS5zcGxpdCgvLCAqLyk7XG4gICAgbGV0IHByb3RFcnJvcjtcblxuICAgIGlmICghcHJvdG9jb2xzICYmIHNlcnZlclByb3QpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhIHN1YnByb3RvY29sIGJ1dCBub25lIHdhcyByZXF1ZXN0ZWQnO1xuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xzICYmICFzZXJ2ZXJQcm90KSB7XG4gICAgICBwcm90RXJyb3IgPSAnU2VydmVyIHNlbnQgbm8gc3VicHJvdG9jb2wnO1xuICAgIH0gZWxzZSBpZiAoc2VydmVyUHJvdCAmJiAhcHJvdExpc3QuaW5jbHVkZXMoc2VydmVyUHJvdCkpIHtcbiAgICAgIHByb3RFcnJvciA9ICdTZXJ2ZXIgc2VudCBhbiBpbnZhbGlkIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoZXh0ZW5zaW9uTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBleHRlbnNpb25OYW1lcy5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAgICdTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkJztcbiAgICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwgb3B0cy5tYXhQYXlsb2FkKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRW1pdCB0aGUgYCdlcnJvcidgIGFuZCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBUaGUgZXJyb3IgdG8gZW1pdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIHdlYnNvY2tldC5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgbmV0LlNvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge25ldC5Tb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBuZXRDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuICByZXR1cm4gbmV0LmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYHRscy5UTFNTb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHt0bHMuVExTU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGxzQ29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoIW9wdGlvbnMuc2VydmVybmFtZSAmJiBvcHRpb25zLnNlcnZlcm5hbWUgIT09ICcnKSB7XG4gICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gbmV0LmlzSVAob3B0aW9ucy5ob3N0KSA/ICcnIDogb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEFib3J0IHRoZSBoYW5kc2hha2UgYW5kIGVtaXQgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyhodHRwLkNsaWVudFJlcXVlc3R8bmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc3RyZWFtIFRoZSByZXF1ZXN0IHRvXG4gKiAgICAgYWJvcnQgb3IgdGhlIHNvY2tldCB0byBkZXN0cm95XG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzdHJlYW0sIG1lc3NhZ2UpIHtcbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG5cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlKTtcblxuICBpZiAoc3RyZWFtLnNldEhlYWRlcikge1xuICAgIHN0cmVhbS5hYm9ydCgpO1xuXG4gICAgaWYgKHN0cmVhbS5zb2NrZXQgJiYgIXN0cmVhbS5zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAvL1xuICAgICAgLy8gT24gTm9kZS5qcyA+PSAxNC4zLjAgYHJlcXVlc3QuYWJvcnQoKWAgZG9lcyBub3QgZGVzdHJveSB0aGUgc29ja2V0IGlmXG4gICAgICAvLyBjYWxsZWQgYWZ0ZXIgdGhlIHJlcXVlc3QgY29tcGxldGVkLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xODY5LlxuICAgICAgLy9cbiAgICAgIHN0cmVhbS5zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHN0cmVhbS5vbmNlKCdhYm9ydCcsIHdlYnNvY2tldC5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQpKTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgY2IoZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICB0aGlzW2tXZWJTb2NrZXRdLl9zb2NrZXQucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhSYW5nZUVycm9yfEVycm9yKX0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uRXJyb3IoZXJyKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdICE9PSB1bmRlZmluZWQpIHtcbiAgICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG5cbiAgICAvL1xuICAgIC8vIE9uIE5vZGUuanMgPCAxNC4wLjAgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIHN5bmNocm9ub3VzbHkuIFNlZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xOTQwLlxuICAgIC8vXG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWUsIHdlYnNvY2tldC5fc29ja2V0KTtcblxuICAgIHdlYnNvY2tldC5jbG9zZShlcnJba1N0YXR1c0NvZGVdKTtcbiAgfVxuXG4gIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcnxCdWZmZXJbXSl9IGRhdGEgVGhlIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXdlYnNvY2tldC5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBsZXQgY2h1bms7XG5cbiAgLy9cbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxuICAvLyBgcmVjZWl2ZXJgIHN0cmVhbSBpcyBjbG9zZWQgYWZ0ZXIgd3JpdGluZyBhbnkgcmVtYWluaW5nIGJ1ZmZlcmVkIGRhdGEgdG9cbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgLiBJZiBpbnN0ZWFkLCB0aGUgc29ja2V0IGlzIHBhdXNlZCwgYW55IHBvc3NpYmxlIGJ1ZmZlcmVkXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuICAvL1xuICBpZiAoXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxuICAgICF3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcbiAgKSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "../../node_modules/yallist/yallist.js":
/*!*********************************************!*\
  !*** ../../node_modules/yallist/yallist.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = Yallist;\nYallist.Node = Node;\nYallist.create = Yallist;\n\nfunction Yallist(list) {\n  var self = this;\n\n  if (!(self instanceof Yallist)) {\n    self = new Yallist();\n  }\n\n  self.tail = null;\n  self.head = null;\n  self.length = 0;\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item);\n    });\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i]);\n    }\n  }\n\n  return self;\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list');\n  }\n\n  var next = node.next;\n  var prev = node.prev;\n\n  if (next) {\n    next.prev = prev;\n  }\n\n  if (prev) {\n    prev.next = next;\n  }\n\n  if (node === this.head) {\n    this.head = next;\n  }\n\n  if (node === this.tail) {\n    this.tail = prev;\n  }\n\n  node.list.length--;\n  node.next = null;\n  node.prev = null;\n  node.list = null;\n};\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var head = this.head;\n  node.list = this;\n  node.next = head;\n\n  if (head) {\n    head.prev = node;\n  }\n\n  this.head = node;\n\n  if (!this.tail) {\n    this.tail = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return;\n  }\n\n  if (node.list) {\n    node.list.removeNode(node);\n  }\n\n  var tail = this.tail;\n  node.list = this;\n  node.prev = tail;\n\n  if (tail) {\n    tail.next = node;\n  }\n\n  this.tail = node;\n\n  if (!this.head) {\n    this.head = node;\n  }\n\n  this.length++;\n};\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i]);\n  }\n\n  return this.length;\n};\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined;\n  }\n\n  var res = this.tail.value;\n  this.tail = this.tail.prev;\n\n  if (this.tail) {\n    this.tail.next = null;\n  } else {\n    this.head = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined;\n  }\n\n  var res = this.head.value;\n  this.head = this.head.next;\n\n  if (this.head) {\n    this.head.prev = null;\n  } else {\n    this.tail = null;\n  }\n\n  this.length--;\n  return res;\n};\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.next;\n  }\n};\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this;\n\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this);\n    walker = walker.prev;\n  }\n};\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev;\n  }\n\n  if (i === n && walker !== null) {\n    return walker.value;\n  }\n};\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.next;\n  }\n\n  return res;\n};\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this;\n  var res = new Yallist();\n\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this));\n    walker = walker.prev;\n  }\n\n  return res;\n};\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc;\n  var walker = this.head;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.head) {\n    walker = this.head.next;\n    acc = this.head.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.next;\n  }\n\n  return acc;\n};\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc;\n  var walker = this.tail;\n\n  if (arguments.length > 1) {\n    acc = initial;\n  } else if (this.tail) {\n    walker = this.tail.prev;\n    acc = this.tail.value;\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value');\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i);\n    walker = walker.prev;\n  }\n\n  return acc;\n};\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.next;\n  }\n\n  return arr;\n};\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length);\n\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value;\n    walker = walker.prev;\n  }\n\n  return arr;\n};\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next;\n  }\n\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length;\n\n  if (to < 0) {\n    to += this.length;\n  }\n\n  from = from || 0;\n\n  if (from < 0) {\n    from += this.length;\n  }\n\n  var ret = new Yallist();\n\n  if (to < from || to < 0) {\n    return ret;\n  }\n\n  if (from < 0) {\n    from = 0;\n  }\n\n  if (to > this.length) {\n    to = this.length;\n  }\n\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev;\n  }\n\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value);\n  }\n\n  return ret;\n};\n\nYallist.prototype.reverse = function () {\n  var head = this.head;\n  var tail = this.tail;\n\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev;\n    walker.prev = walker.next;\n    walker.next = p;\n  }\n\n  this.head = tail;\n  this.tail = head;\n  return this;\n};\n\nfunction push(self, item) {\n  self.tail = new Node(item, self.tail, null, self);\n\n  if (!self.head) {\n    self.head = self.tail;\n  }\n\n  self.length++;\n}\n\nfunction unshift(self, item) {\n  self.head = new Node(item, null, self.head, self);\n\n  if (!self.tail) {\n    self.tail = self.head;\n  }\n\n  self.length++;\n}\n\nfunction Node(value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list);\n  }\n\n  this.list = list;\n  this.value = value;\n\n  if (prev) {\n    prev.next = this;\n    this.prev = prev;\n  } else {\n    this.prev = null;\n  }\n\n  if (next) {\n    next.prev = this;\n    this.next = next;\n  } else {\n    this.next = null;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uLy4uL25vZGVfbW9kdWxlcy95YWxsaXN0L3lhbGxpc3QuanM/YjlhNCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiWWFsbGlzdCIsIk5vZGUiLCJjcmVhdGUiLCJsaXN0Iiwic2VsZiIsInRhaWwiLCJoZWFkIiwibGVuZ3RoIiwiZm9yRWFjaCIsIml0ZW0iLCJwdXNoIiwiYXJndW1lbnRzIiwiaSIsImwiLCJwcm90b3R5cGUiLCJyZW1vdmVOb2RlIiwibm9kZSIsIkVycm9yIiwibmV4dCIsInByZXYiLCJ1bnNoaWZ0Tm9kZSIsInB1c2hOb2RlIiwidW5zaGlmdCIsInBvcCIsInVuZGVmaW5lZCIsInJlcyIsInZhbHVlIiwic2hpZnQiLCJmbiIsInRoaXNwIiwid2Fsa2VyIiwiY2FsbCIsImZvckVhY2hSZXZlcnNlIiwiZ2V0IiwibiIsImdldFJldmVyc2UiLCJtYXAiLCJtYXBSZXZlcnNlIiwicmVkdWNlIiwiaW5pdGlhbCIsImFjYyIsIlR5cGVFcnJvciIsInJlZHVjZVJldmVyc2UiLCJ0b0FycmF5IiwiYXJyIiwiQXJyYXkiLCJ0b0FycmF5UmV2ZXJzZSIsInNsaWNlIiwiZnJvbSIsInRvIiwicmV0Iiwic2xpY2VSZXZlcnNlIiwicmV2ZXJzZSIsInAiXSwibWFwcGluZ3MiOiJBQUFBQSxNQUFNLENBQUNDLE9BQVAsR0FBaUJDLE9BQWpCO0FBRUFBLE9BQU8sQ0FBQ0MsSUFBUixHQUFlQSxJQUFmO0FBQ0FELE9BQU8sQ0FBQ0UsTUFBUixHQUFpQkYsT0FBakI7O0FBRUEsU0FBU0EsT0FBVCxDQUFrQkcsSUFBbEIsRUFBd0I7QUFDdEIsTUFBSUMsSUFBSSxHQUFHLElBQVg7O0FBQ0EsTUFBSSxFQUFFQSxJQUFJLFlBQVlKLE9BQWxCLENBQUosRUFBZ0M7QUFDOUJJLElBQUFBLElBQUksR0FBRyxJQUFJSixPQUFKLEVBQVA7QUFDRDs7QUFFREksRUFBQUEsSUFBSSxDQUFDQyxJQUFMLEdBQVksSUFBWjtBQUNBRCxFQUFBQSxJQUFJLENBQUNFLElBQUwsR0FBWSxJQUFaO0FBQ0FGLEVBQUFBLElBQUksQ0FBQ0csTUFBTCxHQUFjLENBQWQ7O0FBRUEsTUFBSUosSUFBSSxJQUFJLE9BQU9BLElBQUksQ0FBQ0ssT0FBWixLQUF3QixVQUFwQyxFQUFnRDtBQUM5Q0wsSUFBQUEsSUFBSSxDQUFDSyxPQUFMLENBQWEsVUFBVUMsSUFBVixFQUFnQjtBQUMzQkwsTUFBQUEsSUFBSSxDQUFDTSxJQUFMLENBQVVELElBQVY7QUFDRCxLQUZEO0FBR0QsR0FKRCxNQUlPLElBQUlFLFNBQVMsQ0FBQ0osTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUMvQixTQUFLLElBQUlLLENBQUMsR0FBRyxDQUFSLEVBQVdDLENBQUMsR0FBR0YsU0FBUyxDQUFDSixNQUE5QixFQUFzQ0ssQ0FBQyxHQUFHQyxDQUExQyxFQUE2Q0QsQ0FBQyxFQUE5QyxFQUFrRDtBQUNoRFIsTUFBQUEsSUFBSSxDQUFDTSxJQUFMLENBQVVDLFNBQVMsQ0FBQ0MsQ0FBRCxDQUFuQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT1IsSUFBUDtBQUNEOztBQUVESixPQUFPLENBQUNjLFNBQVIsQ0FBa0JDLFVBQWxCLEdBQStCLFVBQVVDLElBQVYsRUFBZ0I7QUFDN0MsTUFBSUEsSUFBSSxDQUFDYixJQUFMLEtBQWMsSUFBbEIsRUFBd0I7QUFDdEIsVUFBTSxJQUFJYyxLQUFKLENBQVUsa0RBQVYsQ0FBTjtBQUNEOztBQUVELE1BQUlDLElBQUksR0FBR0YsSUFBSSxDQUFDRSxJQUFoQjtBQUNBLE1BQUlDLElBQUksR0FBR0gsSUFBSSxDQUFDRyxJQUFoQjs7QUFFQSxNQUFJRCxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxDQUFDQyxJQUFMLEdBQVlBLElBQVo7QUFDRDs7QUFFRCxNQUFJQSxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxDQUFDRCxJQUFMLEdBQVlBLElBQVo7QUFDRDs7QUFFRCxNQUFJRixJQUFJLEtBQUssS0FBS1YsSUFBbEIsRUFBd0I7QUFDdEIsU0FBS0EsSUFBTCxHQUFZWSxJQUFaO0FBQ0Q7O0FBQ0QsTUFBSUYsSUFBSSxLQUFLLEtBQUtYLElBQWxCLEVBQXdCO0FBQ3RCLFNBQUtBLElBQUwsR0FBWWMsSUFBWjtBQUNEOztBQUVESCxFQUFBQSxJQUFJLENBQUNiLElBQUwsQ0FBVUksTUFBVjtBQUNBUyxFQUFBQSxJQUFJLENBQUNFLElBQUwsR0FBWSxJQUFaO0FBQ0FGLEVBQUFBLElBQUksQ0FBQ0csSUFBTCxHQUFZLElBQVo7QUFDQUgsRUFBQUEsSUFBSSxDQUFDYixJQUFMLEdBQVksSUFBWjtBQUNELENBM0JEOztBQTZCQUgsT0FBTyxDQUFDYyxTQUFSLENBQWtCTSxXQUFsQixHQUFnQyxVQUFVSixJQUFWLEVBQWdCO0FBQzlDLE1BQUlBLElBQUksS0FBSyxLQUFLVixJQUFsQixFQUF3QjtBQUN0QjtBQUNEOztBQUVELE1BQUlVLElBQUksQ0FBQ2IsSUFBVCxFQUFlO0FBQ2JhLElBQUFBLElBQUksQ0FBQ2IsSUFBTCxDQUFVWSxVQUFWLENBQXFCQyxJQUFyQjtBQUNEOztBQUVELE1BQUlWLElBQUksR0FBRyxLQUFLQSxJQUFoQjtBQUNBVSxFQUFBQSxJQUFJLENBQUNiLElBQUwsR0FBWSxJQUFaO0FBQ0FhLEVBQUFBLElBQUksQ0FBQ0UsSUFBTCxHQUFZWixJQUFaOztBQUNBLE1BQUlBLElBQUosRUFBVTtBQUNSQSxJQUFBQSxJQUFJLENBQUNhLElBQUwsR0FBWUgsSUFBWjtBQUNEOztBQUVELE9BQUtWLElBQUwsR0FBWVUsSUFBWjs7QUFDQSxNQUFJLENBQUMsS0FBS1gsSUFBVixFQUFnQjtBQUNkLFNBQUtBLElBQUwsR0FBWVcsSUFBWjtBQUNEOztBQUNELE9BQUtULE1BQUw7QUFDRCxDQXJCRDs7QUF1QkFQLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQk8sUUFBbEIsR0FBNkIsVUFBVUwsSUFBVixFQUFnQjtBQUMzQyxNQUFJQSxJQUFJLEtBQUssS0FBS1gsSUFBbEIsRUFBd0I7QUFDdEI7QUFDRDs7QUFFRCxNQUFJVyxJQUFJLENBQUNiLElBQVQsRUFBZTtBQUNiYSxJQUFBQSxJQUFJLENBQUNiLElBQUwsQ0FBVVksVUFBVixDQUFxQkMsSUFBckI7QUFDRDs7QUFFRCxNQUFJWCxJQUFJLEdBQUcsS0FBS0EsSUFBaEI7QUFDQVcsRUFBQUEsSUFBSSxDQUFDYixJQUFMLEdBQVksSUFBWjtBQUNBYSxFQUFBQSxJQUFJLENBQUNHLElBQUwsR0FBWWQsSUFBWjs7QUFDQSxNQUFJQSxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxDQUFDYSxJQUFMLEdBQVlGLElBQVo7QUFDRDs7QUFFRCxPQUFLWCxJQUFMLEdBQVlXLElBQVo7O0FBQ0EsTUFBSSxDQUFDLEtBQUtWLElBQVYsRUFBZ0I7QUFDZCxTQUFLQSxJQUFMLEdBQVlVLElBQVo7QUFDRDs7QUFDRCxPQUFLVCxNQUFMO0FBQ0QsQ0FyQkQ7O0FBdUJBUCxPQUFPLENBQUNjLFNBQVIsQ0FBa0JKLElBQWxCLEdBQXlCLFlBQVk7QUFDbkMsT0FBSyxJQUFJRSxDQUFDLEdBQUcsQ0FBUixFQUFXQyxDQUFDLEdBQUdGLFNBQVMsQ0FBQ0osTUFBOUIsRUFBc0NLLENBQUMsR0FBR0MsQ0FBMUMsRUFBNkNELENBQUMsRUFBOUMsRUFBa0Q7QUFDaERGLElBQUFBLElBQUksQ0FBQyxJQUFELEVBQU9DLFNBQVMsQ0FBQ0MsQ0FBRCxDQUFoQixDQUFKO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFLTCxNQUFaO0FBQ0QsQ0FMRDs7QUFPQVAsT0FBTyxDQUFDYyxTQUFSLENBQWtCUSxPQUFsQixHQUE0QixZQUFZO0FBQ3RDLE9BQUssSUFBSVYsQ0FBQyxHQUFHLENBQVIsRUFBV0MsQ0FBQyxHQUFHRixTQUFTLENBQUNKLE1BQTlCLEVBQXNDSyxDQUFDLEdBQUdDLENBQTFDLEVBQTZDRCxDQUFDLEVBQTlDLEVBQWtEO0FBQ2hEVSxJQUFBQSxPQUFPLENBQUMsSUFBRCxFQUFPWCxTQUFTLENBQUNDLENBQUQsQ0FBaEIsQ0FBUDtBQUNEOztBQUNELFNBQU8sS0FBS0wsTUFBWjtBQUNELENBTEQ7O0FBT0FQLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQlMsR0FBbEIsR0FBd0IsWUFBWTtBQUNsQyxNQUFJLENBQUMsS0FBS2xCLElBQVYsRUFBZ0I7QUFDZCxXQUFPbUIsU0FBUDtBQUNEOztBQUVELE1BQUlDLEdBQUcsR0FBRyxLQUFLcEIsSUFBTCxDQUFVcUIsS0FBcEI7QUFDQSxPQUFLckIsSUFBTCxHQUFZLEtBQUtBLElBQUwsQ0FBVWMsSUFBdEI7O0FBQ0EsTUFBSSxLQUFLZCxJQUFULEVBQWU7QUFDYixTQUFLQSxJQUFMLENBQVVhLElBQVYsR0FBaUIsSUFBakI7QUFDRCxHQUZELE1BRU87QUFDTCxTQUFLWixJQUFMLEdBQVksSUFBWjtBQUNEOztBQUNELE9BQUtDLE1BQUw7QUFDQSxTQUFPa0IsR0FBUDtBQUNELENBZEQ7O0FBZ0JBekIsT0FBTyxDQUFDYyxTQUFSLENBQWtCYSxLQUFsQixHQUEwQixZQUFZO0FBQ3BDLE1BQUksQ0FBQyxLQUFLckIsSUFBVixFQUFnQjtBQUNkLFdBQU9rQixTQUFQO0FBQ0Q7O0FBRUQsTUFBSUMsR0FBRyxHQUFHLEtBQUtuQixJQUFMLENBQVVvQixLQUFwQjtBQUNBLE9BQUtwQixJQUFMLEdBQVksS0FBS0EsSUFBTCxDQUFVWSxJQUF0Qjs7QUFDQSxNQUFJLEtBQUtaLElBQVQsRUFBZTtBQUNiLFNBQUtBLElBQUwsQ0FBVWEsSUFBVixHQUFpQixJQUFqQjtBQUNELEdBRkQsTUFFTztBQUNMLFNBQUtkLElBQUwsR0FBWSxJQUFaO0FBQ0Q7O0FBQ0QsT0FBS0UsTUFBTDtBQUNBLFNBQU9rQixHQUFQO0FBQ0QsQ0FkRDs7QUFnQkF6QixPQUFPLENBQUNjLFNBQVIsQ0FBa0JOLE9BQWxCLEdBQTRCLFVBQVVvQixFQUFWLEVBQWNDLEtBQWQsRUFBcUI7QUFDL0NBLEVBQUFBLEtBQUssR0FBR0EsS0FBSyxJQUFJLElBQWpCOztBQUNBLE9BQUssSUFBSUMsTUFBTSxHQUFHLEtBQUt4QixJQUFsQixFQUF3Qk0sQ0FBQyxHQUFHLENBQWpDLEVBQW9Da0IsTUFBTSxLQUFLLElBQS9DLEVBQXFEbEIsQ0FBQyxFQUF0RCxFQUEwRDtBQUN4RGdCLElBQUFBLEVBQUUsQ0FBQ0csSUFBSCxDQUFRRixLQUFSLEVBQWVDLE1BQU0sQ0FBQ0osS0FBdEIsRUFBNkJkLENBQTdCLEVBQWdDLElBQWhDO0FBQ0FrQixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ1osSUFBaEI7QUFDRDtBQUNGLENBTkQ7O0FBUUFsQixPQUFPLENBQUNjLFNBQVIsQ0FBa0JrQixjQUFsQixHQUFtQyxVQUFVSixFQUFWLEVBQWNDLEtBQWQsRUFBcUI7QUFDdERBLEVBQUFBLEtBQUssR0FBR0EsS0FBSyxJQUFJLElBQWpCOztBQUNBLE9BQUssSUFBSUMsTUFBTSxHQUFHLEtBQUt6QixJQUFsQixFQUF3Qk8sQ0FBQyxHQUFHLEtBQUtMLE1BQUwsR0FBYyxDQUEvQyxFQUFrRHVCLE1BQU0sS0FBSyxJQUE3RCxFQUFtRWxCLENBQUMsRUFBcEUsRUFBd0U7QUFDdEVnQixJQUFBQSxFQUFFLENBQUNHLElBQUgsQ0FBUUYsS0FBUixFQUFlQyxNQUFNLENBQUNKLEtBQXRCLEVBQTZCZCxDQUE3QixFQUFnQyxJQUFoQztBQUNBa0IsSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNYLElBQWhCO0FBQ0Q7QUFDRixDQU5EOztBQVFBbkIsT0FBTyxDQUFDYyxTQUFSLENBQWtCbUIsR0FBbEIsR0FBd0IsVUFBVUMsQ0FBVixFQUFhO0FBQ25DLE9BQUssSUFBSXRCLENBQUMsR0FBRyxDQUFSLEVBQVdrQixNQUFNLEdBQUcsS0FBS3hCLElBQTlCLEVBQW9Dd0IsTUFBTSxLQUFLLElBQVgsSUFBbUJsQixDQUFDLEdBQUdzQixDQUEzRCxFQUE4RHRCLENBQUMsRUFBL0QsRUFBbUU7QUFDakU7QUFDQWtCLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWixJQUFoQjtBQUNEOztBQUNELE1BQUlOLENBQUMsS0FBS3NCLENBQU4sSUFBV0osTUFBTSxLQUFLLElBQTFCLEVBQWdDO0FBQzlCLFdBQU9BLE1BQU0sQ0FBQ0osS0FBZDtBQUNEO0FBQ0YsQ0FSRDs7QUFVQTFCLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQnFCLFVBQWxCLEdBQStCLFVBQVVELENBQVYsRUFBYTtBQUMxQyxPQUFLLElBQUl0QixDQUFDLEdBQUcsQ0FBUixFQUFXa0IsTUFBTSxHQUFHLEtBQUt6QixJQUE5QixFQUFvQ3lCLE1BQU0sS0FBSyxJQUFYLElBQW1CbEIsQ0FBQyxHQUFHc0IsQ0FBM0QsRUFBOER0QixDQUFDLEVBQS9ELEVBQW1FO0FBQ2pFO0FBQ0FrQixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ1gsSUFBaEI7QUFDRDs7QUFDRCxNQUFJUCxDQUFDLEtBQUtzQixDQUFOLElBQVdKLE1BQU0sS0FBSyxJQUExQixFQUFnQztBQUM5QixXQUFPQSxNQUFNLENBQUNKLEtBQWQ7QUFDRDtBQUNGLENBUkQ7O0FBVUExQixPQUFPLENBQUNjLFNBQVIsQ0FBa0JzQixHQUFsQixHQUF3QixVQUFVUixFQUFWLEVBQWNDLEtBQWQsRUFBcUI7QUFDM0NBLEVBQUFBLEtBQUssR0FBR0EsS0FBSyxJQUFJLElBQWpCO0FBQ0EsTUFBSUosR0FBRyxHQUFHLElBQUl6QixPQUFKLEVBQVY7O0FBQ0EsT0FBSyxJQUFJOEIsTUFBTSxHQUFHLEtBQUt4QixJQUF2QixFQUE2QndCLE1BQU0sS0FBSyxJQUF4QyxHQUErQztBQUM3Q0wsSUFBQUEsR0FBRyxDQUFDZixJQUFKLENBQVNrQixFQUFFLENBQUNHLElBQUgsQ0FBUUYsS0FBUixFQUFlQyxNQUFNLENBQUNKLEtBQXRCLEVBQTZCLElBQTdCLENBQVQ7QUFDQUksSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNaLElBQWhCO0FBQ0Q7O0FBQ0QsU0FBT08sR0FBUDtBQUNELENBUkQ7O0FBVUF6QixPQUFPLENBQUNjLFNBQVIsQ0FBa0J1QixVQUFsQixHQUErQixVQUFVVCxFQUFWLEVBQWNDLEtBQWQsRUFBcUI7QUFDbERBLEVBQUFBLEtBQUssR0FBR0EsS0FBSyxJQUFJLElBQWpCO0FBQ0EsTUFBSUosR0FBRyxHQUFHLElBQUl6QixPQUFKLEVBQVY7O0FBQ0EsT0FBSyxJQUFJOEIsTUFBTSxHQUFHLEtBQUt6QixJQUF2QixFQUE2QnlCLE1BQU0sS0FBSyxJQUF4QyxHQUErQztBQUM3Q0wsSUFBQUEsR0FBRyxDQUFDZixJQUFKLENBQVNrQixFQUFFLENBQUNHLElBQUgsQ0FBUUYsS0FBUixFQUFlQyxNQUFNLENBQUNKLEtBQXRCLEVBQTZCLElBQTdCLENBQVQ7QUFDQUksSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNYLElBQWhCO0FBQ0Q7O0FBQ0QsU0FBT00sR0FBUDtBQUNELENBUkQ7O0FBVUF6QixPQUFPLENBQUNjLFNBQVIsQ0FBa0J3QixNQUFsQixHQUEyQixVQUFVVixFQUFWLEVBQWNXLE9BQWQsRUFBdUI7QUFDaEQsTUFBSUMsR0FBSjtBQUNBLE1BQUlWLE1BQU0sR0FBRyxLQUFLeEIsSUFBbEI7O0FBQ0EsTUFBSUssU0FBUyxDQUFDSixNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3hCaUMsSUFBQUEsR0FBRyxHQUFHRCxPQUFOO0FBQ0QsR0FGRCxNQUVPLElBQUksS0FBS2pDLElBQVQsRUFBZTtBQUNwQndCLElBQUFBLE1BQU0sR0FBRyxLQUFLeEIsSUFBTCxDQUFVWSxJQUFuQjtBQUNBc0IsSUFBQUEsR0FBRyxHQUFHLEtBQUtsQyxJQUFMLENBQVVvQixLQUFoQjtBQUNELEdBSE0sTUFHQTtBQUNMLFVBQU0sSUFBSWUsU0FBSixDQUFjLDRDQUFkLENBQU47QUFDRDs7QUFFRCxPQUFLLElBQUk3QixDQUFDLEdBQUcsQ0FBYixFQUFnQmtCLE1BQU0sS0FBSyxJQUEzQixFQUFpQ2xCLENBQUMsRUFBbEMsRUFBc0M7QUFDcEM0QixJQUFBQSxHQUFHLEdBQUdaLEVBQUUsQ0FBQ1ksR0FBRCxFQUFNVixNQUFNLENBQUNKLEtBQWIsRUFBb0JkLENBQXBCLENBQVI7QUFDQWtCLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWixJQUFoQjtBQUNEOztBQUVELFNBQU9zQixHQUFQO0FBQ0QsQ0FsQkQ7O0FBb0JBeEMsT0FBTyxDQUFDYyxTQUFSLENBQWtCNEIsYUFBbEIsR0FBa0MsVUFBVWQsRUFBVixFQUFjVyxPQUFkLEVBQXVCO0FBQ3ZELE1BQUlDLEdBQUo7QUFDQSxNQUFJVixNQUFNLEdBQUcsS0FBS3pCLElBQWxCOztBQUNBLE1BQUlNLFNBQVMsQ0FBQ0osTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QmlDLElBQUFBLEdBQUcsR0FBR0QsT0FBTjtBQUNELEdBRkQsTUFFTyxJQUFJLEtBQUtsQyxJQUFULEVBQWU7QUFDcEJ5QixJQUFBQSxNQUFNLEdBQUcsS0FBS3pCLElBQUwsQ0FBVWMsSUFBbkI7QUFDQXFCLElBQUFBLEdBQUcsR0FBRyxLQUFLbkMsSUFBTCxDQUFVcUIsS0FBaEI7QUFDRCxHQUhNLE1BR0E7QUFDTCxVQUFNLElBQUllLFNBQUosQ0FBYyw0Q0FBZCxDQUFOO0FBQ0Q7O0FBRUQsT0FBSyxJQUFJN0IsQ0FBQyxHQUFHLEtBQUtMLE1BQUwsR0FBYyxDQUEzQixFQUE4QnVCLE1BQU0sS0FBSyxJQUF6QyxFQUErQ2xCLENBQUMsRUFBaEQsRUFBb0Q7QUFDbEQ0QixJQUFBQSxHQUFHLEdBQUdaLEVBQUUsQ0FBQ1ksR0FBRCxFQUFNVixNQUFNLENBQUNKLEtBQWIsRUFBb0JkLENBQXBCLENBQVI7QUFDQWtCLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDWCxJQUFoQjtBQUNEOztBQUVELFNBQU9xQixHQUFQO0FBQ0QsQ0FsQkQ7O0FBb0JBeEMsT0FBTyxDQUFDYyxTQUFSLENBQWtCNkIsT0FBbEIsR0FBNEIsWUFBWTtBQUN0QyxNQUFJQyxHQUFHLEdBQUcsSUFBSUMsS0FBSixDQUFVLEtBQUt0QyxNQUFmLENBQVY7O0FBQ0EsT0FBSyxJQUFJSyxDQUFDLEdBQUcsQ0FBUixFQUFXa0IsTUFBTSxHQUFHLEtBQUt4QixJQUE5QixFQUFvQ3dCLE1BQU0sS0FBSyxJQUEvQyxFQUFxRGxCLENBQUMsRUFBdEQsRUFBMEQ7QUFDeERnQyxJQUFBQSxHQUFHLENBQUNoQyxDQUFELENBQUgsR0FBU2tCLE1BQU0sQ0FBQ0osS0FBaEI7QUFDQUksSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNaLElBQWhCO0FBQ0Q7O0FBQ0QsU0FBTzBCLEdBQVA7QUFDRCxDQVBEOztBQVNBNUMsT0FBTyxDQUFDYyxTQUFSLENBQWtCZ0MsY0FBbEIsR0FBbUMsWUFBWTtBQUM3QyxNQUFJRixHQUFHLEdBQUcsSUFBSUMsS0FBSixDQUFVLEtBQUt0QyxNQUFmLENBQVY7O0FBQ0EsT0FBSyxJQUFJSyxDQUFDLEdBQUcsQ0FBUixFQUFXa0IsTUFBTSxHQUFHLEtBQUt6QixJQUE5QixFQUFvQ3lCLE1BQU0sS0FBSyxJQUEvQyxFQUFxRGxCLENBQUMsRUFBdEQsRUFBMEQ7QUFDeERnQyxJQUFBQSxHQUFHLENBQUNoQyxDQUFELENBQUgsR0FBU2tCLE1BQU0sQ0FBQ0osS0FBaEI7QUFDQUksSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNYLElBQWhCO0FBQ0Q7O0FBQ0QsU0FBT3lCLEdBQVA7QUFDRCxDQVBEOztBQVNBNUMsT0FBTyxDQUFDYyxTQUFSLENBQWtCaUMsS0FBbEIsR0FBMEIsVUFBVUMsSUFBVixFQUFnQkMsRUFBaEIsRUFBb0I7QUFDNUNBLEVBQUFBLEVBQUUsR0FBR0EsRUFBRSxJQUFJLEtBQUsxQyxNQUFoQjs7QUFDQSxNQUFJMEMsRUFBRSxHQUFHLENBQVQsRUFBWTtBQUNWQSxJQUFBQSxFQUFFLElBQUksS0FBSzFDLE1BQVg7QUFDRDs7QUFDRHlDLEVBQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQWY7O0FBQ0EsTUFBSUEsSUFBSSxHQUFHLENBQVgsRUFBYztBQUNaQSxJQUFBQSxJQUFJLElBQUksS0FBS3pDLE1BQWI7QUFDRDs7QUFDRCxNQUFJMkMsR0FBRyxHQUFHLElBQUlsRCxPQUFKLEVBQVY7O0FBQ0EsTUFBSWlELEVBQUUsR0FBR0QsSUFBTCxJQUFhQyxFQUFFLEdBQUcsQ0FBdEIsRUFBeUI7QUFDdkIsV0FBT0MsR0FBUDtBQUNEOztBQUNELE1BQUlGLElBQUksR0FBRyxDQUFYLEVBQWM7QUFDWkEsSUFBQUEsSUFBSSxHQUFHLENBQVA7QUFDRDs7QUFDRCxNQUFJQyxFQUFFLEdBQUcsS0FBSzFDLE1BQWQsRUFBc0I7QUFDcEIwQyxJQUFBQSxFQUFFLEdBQUcsS0FBSzFDLE1BQVY7QUFDRDs7QUFDRCxPQUFLLElBQUlLLENBQUMsR0FBRyxDQUFSLEVBQVdrQixNQUFNLEdBQUcsS0FBS3hCLElBQTlCLEVBQW9Dd0IsTUFBTSxLQUFLLElBQVgsSUFBbUJsQixDQUFDLEdBQUdvQyxJQUEzRCxFQUFpRXBDLENBQUMsRUFBbEUsRUFBc0U7QUFDcEVrQixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ1osSUFBaEI7QUFDRDs7QUFDRCxTQUFPWSxNQUFNLEtBQUssSUFBWCxJQUFtQmxCLENBQUMsR0FBR3FDLEVBQTlCLEVBQWtDckMsQ0FBQyxJQUFJa0IsTUFBTSxHQUFHQSxNQUFNLENBQUNaLElBQXZELEVBQTZEO0FBQzNEZ0MsSUFBQUEsR0FBRyxDQUFDeEMsSUFBSixDQUFTb0IsTUFBTSxDQUFDSixLQUFoQjtBQUNEOztBQUNELFNBQU93QixHQUFQO0FBQ0QsQ0ExQkQ7O0FBNEJBbEQsT0FBTyxDQUFDYyxTQUFSLENBQWtCcUMsWUFBbEIsR0FBaUMsVUFBVUgsSUFBVixFQUFnQkMsRUFBaEIsRUFBb0I7QUFDbkRBLEVBQUFBLEVBQUUsR0FBR0EsRUFBRSxJQUFJLEtBQUsxQyxNQUFoQjs7QUFDQSxNQUFJMEMsRUFBRSxHQUFHLENBQVQsRUFBWTtBQUNWQSxJQUFBQSxFQUFFLElBQUksS0FBSzFDLE1BQVg7QUFDRDs7QUFDRHlDLEVBQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQWY7O0FBQ0EsTUFBSUEsSUFBSSxHQUFHLENBQVgsRUFBYztBQUNaQSxJQUFBQSxJQUFJLElBQUksS0FBS3pDLE1BQWI7QUFDRDs7QUFDRCxNQUFJMkMsR0FBRyxHQUFHLElBQUlsRCxPQUFKLEVBQVY7O0FBQ0EsTUFBSWlELEVBQUUsR0FBR0QsSUFBTCxJQUFhQyxFQUFFLEdBQUcsQ0FBdEIsRUFBeUI7QUFDdkIsV0FBT0MsR0FBUDtBQUNEOztBQUNELE1BQUlGLElBQUksR0FBRyxDQUFYLEVBQWM7QUFDWkEsSUFBQUEsSUFBSSxHQUFHLENBQVA7QUFDRDs7QUFDRCxNQUFJQyxFQUFFLEdBQUcsS0FBSzFDLE1BQWQsRUFBc0I7QUFDcEIwQyxJQUFBQSxFQUFFLEdBQUcsS0FBSzFDLE1BQVY7QUFDRDs7QUFDRCxPQUFLLElBQUlLLENBQUMsR0FBRyxLQUFLTCxNQUFiLEVBQXFCdUIsTUFBTSxHQUFHLEtBQUt6QixJQUF4QyxFQUE4Q3lCLE1BQU0sS0FBSyxJQUFYLElBQW1CbEIsQ0FBQyxHQUFHcUMsRUFBckUsRUFBeUVyQyxDQUFDLEVBQTFFLEVBQThFO0FBQzVFa0IsSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNYLElBQWhCO0FBQ0Q7O0FBQ0QsU0FBT1csTUFBTSxLQUFLLElBQVgsSUFBbUJsQixDQUFDLEdBQUdvQyxJQUE5QixFQUFvQ3BDLENBQUMsSUFBSWtCLE1BQU0sR0FBR0EsTUFBTSxDQUFDWCxJQUF6RCxFQUErRDtBQUM3RCtCLElBQUFBLEdBQUcsQ0FBQ3hDLElBQUosQ0FBU29CLE1BQU0sQ0FBQ0osS0FBaEI7QUFDRDs7QUFDRCxTQUFPd0IsR0FBUDtBQUNELENBMUJEOztBQTRCQWxELE9BQU8sQ0FBQ2MsU0FBUixDQUFrQnNDLE9BQWxCLEdBQTRCLFlBQVk7QUFDdEMsTUFBSTlDLElBQUksR0FBRyxLQUFLQSxJQUFoQjtBQUNBLE1BQUlELElBQUksR0FBRyxLQUFLQSxJQUFoQjs7QUFDQSxPQUFLLElBQUl5QixNQUFNLEdBQUd4QixJQUFsQixFQUF3QndCLE1BQU0sS0FBSyxJQUFuQyxFQUF5Q0EsTUFBTSxHQUFHQSxNQUFNLENBQUNYLElBQXpELEVBQStEO0FBQzdELFFBQUlrQyxDQUFDLEdBQUd2QixNQUFNLENBQUNYLElBQWY7QUFDQVcsSUFBQUEsTUFBTSxDQUFDWCxJQUFQLEdBQWNXLE1BQU0sQ0FBQ1osSUFBckI7QUFDQVksSUFBQUEsTUFBTSxDQUFDWixJQUFQLEdBQWNtQyxDQUFkO0FBQ0Q7O0FBQ0QsT0FBSy9DLElBQUwsR0FBWUQsSUFBWjtBQUNBLE9BQUtBLElBQUwsR0FBWUMsSUFBWjtBQUNBLFNBQU8sSUFBUDtBQUNELENBWEQ7O0FBYUEsU0FBU0ksSUFBVCxDQUFlTixJQUFmLEVBQXFCSyxJQUFyQixFQUEyQjtBQUN6QkwsRUFBQUEsSUFBSSxDQUFDQyxJQUFMLEdBQVksSUFBSUosSUFBSixDQUFTUSxJQUFULEVBQWVMLElBQUksQ0FBQ0MsSUFBcEIsRUFBMEIsSUFBMUIsRUFBZ0NELElBQWhDLENBQVo7O0FBQ0EsTUFBSSxDQUFDQSxJQUFJLENBQUNFLElBQVYsRUFBZ0I7QUFDZEYsSUFBQUEsSUFBSSxDQUFDRSxJQUFMLEdBQVlGLElBQUksQ0FBQ0MsSUFBakI7QUFDRDs7QUFDREQsRUFBQUEsSUFBSSxDQUFDRyxNQUFMO0FBQ0Q7O0FBRUQsU0FBU2UsT0FBVCxDQUFrQmxCLElBQWxCLEVBQXdCSyxJQUF4QixFQUE4QjtBQUM1QkwsRUFBQUEsSUFBSSxDQUFDRSxJQUFMLEdBQVksSUFBSUwsSUFBSixDQUFTUSxJQUFULEVBQWUsSUFBZixFQUFxQkwsSUFBSSxDQUFDRSxJQUExQixFQUFnQ0YsSUFBaEMsQ0FBWjs7QUFDQSxNQUFJLENBQUNBLElBQUksQ0FBQ0MsSUFBVixFQUFnQjtBQUNkRCxJQUFBQSxJQUFJLENBQUNDLElBQUwsR0FBWUQsSUFBSSxDQUFDRSxJQUFqQjtBQUNEOztBQUNERixFQUFBQSxJQUFJLENBQUNHLE1BQUw7QUFDRDs7QUFFRCxTQUFTTixJQUFULENBQWV5QixLQUFmLEVBQXNCUCxJQUF0QixFQUE0QkQsSUFBNUIsRUFBa0NmLElBQWxDLEVBQXdDO0FBQ3RDLE1BQUksRUFBRSxnQkFBZ0JGLElBQWxCLENBQUosRUFBNkI7QUFDM0IsV0FBTyxJQUFJQSxJQUFKLENBQVN5QixLQUFULEVBQWdCUCxJQUFoQixFQUFzQkQsSUFBdEIsRUFBNEJmLElBQTVCLENBQVA7QUFDRDs7QUFFRCxPQUFLQSxJQUFMLEdBQVlBLElBQVo7QUFDQSxPQUFLdUIsS0FBTCxHQUFhQSxLQUFiOztBQUVBLE1BQUlQLElBQUosRUFBVTtBQUNSQSxJQUFBQSxJQUFJLENBQUNELElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0QsR0FIRCxNQUdPO0FBQ0wsU0FBS0EsSUFBTCxHQUFZLElBQVo7QUFDRDs7QUFFRCxNQUFJRCxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxDQUFDQyxJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUtELElBQUwsR0FBWUEsSUFBWjtBQUNELEdBSEQsTUFHTztBQUNMLFNBQUtBLElBQUwsR0FBWSxJQUFaO0FBQ0Q7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cbiJdLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/yallist/yallist.js\n");

/***/ }),

/***/ "./src/standalone.js":
/*!***************************!*\
  !*** ./src/standalone.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/bridge */ \"../react-devtools-shared/src/bridge.js\");\n/* harmony import */ var react_devtools_shared_src_devtools_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/devtools/store */ \"../react-devtools-shared/src/devtools/store.js\");\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/* harmony import */ var react_devtools_shared_src_registerDevToolsEventLogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-shared/src/registerDevToolsEventLogger */ \"../react-devtools-shared/src/registerDevToolsEventLogger.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ws */ \"../../node_modules/ws/index.js\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ws__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-devtools-shared/src/constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var react_devtools_shared_src_symbolicateSource__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-devtools-shared/src/symbolicateSource */ \"../react-devtools-shared/src/symbolicateSource.js\");\n/* harmony import */ var jsc_safe_url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jsc-safe-url */ \"../../node_modules/jsc-safe-url/index.js\");\n/* harmony import */ var jsc_safe_url__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(jsc_safe_url__WEBPACK_IMPORTED_MODULE_9__);\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\n\nlet statusListener = (message, status) => {\n  log('Status', message, status);\n};\n\nfunction setStatusListener(value) {\n  statusListener = value;\n  return Devtools;\n}\n\nlet disconnectedCallback = () => {};\n\nfunction setDisconnectedCallback(value) {\n  disconnectedCallback = value;\n  return Devtools;\n}\n\nlet dataCallback = () => {};\n\nfunction setDataCallback(value) {\n  dataCallback = value;\n  return Devtools;\n}\n\nlet inspectionCallback = () => {};\n\nfunction setInspectionCallback(value) {\n  inspectionCallback = value;\n  return Devtools;\n}\n\nfunction startInspectingHost() {\n  if (!bridge || !store) {\n    console.log('no bridge or store');\n    return Devtools;\n  }\n\n  bridge.send('startInspectingHost');\n  return Devtools;\n}\n\nfunction stopInspectingHost() {\n  if (!bridge || !store) {\n    console.log('no bridge or store');\n    return Devtools;\n  }\n\n  bridge.send('stopInspectingHost', false);\n  return Devtools;\n}\n\nlet bridge = null;\nlet store = null;\n\nconst log = (...args) => console.log('[React DevTools]', ...args);\n\nlog.warn = (...args) => console.warn('[React DevTools]', ...args);\n\nlog.error = (...args) => console.error('[React DevTools]', ...args);\n\nfunction debug(methodName, ...args) {\n  if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_7__.__DEBUG__) {\n    console.log(`%c[core/standalone] %c${methodName}`, 'color: teal; font-weight: bold;', 'font-weight: bold;', ...args);\n  }\n}\n\nlet i = 0;\n\nfunction reload() {\n  if (!bridge || !store) {\n    console.log('no bridge or store');\n    return;\n  }\n\n  const localBridge = bridge;\n  const localStore = store;\n  localBridge.addListener('selectElement', elementId => {\n    const rendererID = localStore.getRendererIDForElement(elementId); // const element = localStore.getElementByID(elementId);\n\n    if (rendererID === null) {\n      console.log('no renderer id');\n      return;\n    }\n\n    const payload = {\n      id: elementId,\n      rendererID,\n      requestID: i++,\n      path: null,\n      forceFullData: true\n    };\n    localBridge.send('inspectElement', payload);\n  });\n  localBridge.addListener('startInspectingHost', () => {\n    inspectionCallback(true);\n  });\n  localBridge.addListener('stopInspectingHost', () => {\n    inspectionCallback(false);\n  });\n  localBridge.addListener('inspectedElement', async data => {\n    if (data == null) return null;\n\n    if (data.type === 'full-data') {\n      if (data.value.source == null) {\n        return Promise.resolve(null);\n      }\n\n      ;\n      const {\n        sourceURL,\n        line,\n        column\n      } = data.value.source;\n      console.log('[devtools] input', {\n        sourceURL,\n        line,\n        column,\n        fetchFileWithCaching\n      });\n      const symbolicatedSource = await (0,react_devtools_shared_src_symbolicateSource__WEBPACK_IMPORTED_MODULE_8__.symbolicateSourceWithCache)(fetchFileWithCaching, sourceURL, line, column);\n      console.log('[devtools] output', {\n        source: symbolicatedSource\n      });\n\n      if (symbolicatedSource == null) {\n        console.log('[devtools] No symbolicated source, rendering simple source ', formatSourceForDisplay(sourceURL, line));\n      } else {\n        console.log('[devtools] Symbolicated source found:', formatSourceForDisplay(symbolicatedSource.sourceURL, symbolicatedSource.line));\n      }\n\n      dataCallback(data);\n    } else {\n      dataCallback(data);\n    }\n  });\n} // This function is based on describeComponentFrame() in packages/shared/ReactComponentStackFrame\n\n\nfunction formatSourceForDisplay(sourceURL, line) {\n  // Metro can return JSC-safe URLs, which have `//&` as a delimiter\n  // https://www.npmjs.com/package/jsc-safe-url\n  const sanitizedSourceURL = sourceURL.includes('//&') ? (0,jsc_safe_url__WEBPACK_IMPORTED_MODULE_9__.toNormalUrl)(sourceURL) : sourceURL; // Note: this RegExp doesn't work well with URLs from Metro,\n  // which provides bundle URL with query parameters prefixed with /&\n\n  const BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n  let nameOnly = sanitizedSourceURL.replace(BEFORE_SLASH_RE, ''); // In DEV, include code for a common special case:\n  // prefer \"folder/index.js\" instead of just \"index.js\".\n\n  if (/^index\\./.test(nameOnly)) {\n    const match = sanitizedSourceURL.match(BEFORE_SLASH_RE);\n\n    if (match) {\n      const pathBeforeSlash = match[1];\n\n      if (pathBeforeSlash) {\n        const folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n        nameOnly = folderName + '/' + nameOnly;\n      }\n    }\n  }\n\n  return `${nameOnly}:${line}`;\n}\n\nfunction onDisconnected() {\n  disconnectedCallback();\n}\n\nfunction onError({\n  code,\n  message\n}) {\n  console.error(`Error: ${code} ${message}`);\n}\n\nfunction initialize(socket) {\n  const listeners = [];\n\n  socket.onmessage = event => {\n    let data;\n\n    try {\n      if (typeof event.data === 'string') {\n        data = JSON.parse(event.data);\n\n        if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_7__.__DEBUG__) {\n          debug('WebSocket.onmessage', data);\n        }\n      } else {\n        throw Error();\n      }\n    } catch (e) {\n      log.error('Failed to parse JSON', event.data);\n      return;\n    }\n\n    listeners.forEach(fn => {\n      try {\n        fn(data);\n      } catch (error) {\n        log.error('Error calling listener', data);\n        throw error;\n      }\n    });\n  };\n\n  bridge = new react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    listen(fn) {\n      listeners.push(fn);\n      return () => {\n        const index = listeners.indexOf(fn);\n\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n      };\n    },\n\n    send(event, payload, transferable) {\n      if (socket.readyState === socket.OPEN) {\n        socket.send(JSON.stringify({\n          event,\n          payload\n        }));\n      }\n    }\n\n  });\n  bridge.addListener('shutdown', () => {\n    socket.close();\n  }); // $FlowFixMe[incompatible-call] found when upgrading Flow\n\n  store = new react_devtools_shared_src_devtools_store__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bridge, {\n    checkBridgeProtocolCompatibility: true,\n    supportsTraceUpdates: true,\n    supportsClickToInspect: true\n  });\n  log('Connected');\n  statusListener('DevTools initialized.', 'devtools-connected');\n  reload();\n}\n\nfunction connectToSocket(socket) {\n  socket.onerror = err => {\n    onDisconnected();\n    log.error('Error with websocket connection', err);\n  };\n\n  socket.onclose = () => {\n    onDisconnected();\n    log('Connection to RN closed');\n  };\n\n  initialize(socket);\n  return {\n    close: function () {\n      onDisconnected();\n    }\n  };\n}\n\nfunction startServer(port = 8097, host = 'localhost', httpsOptions, loggerOptions, attempts = 0) {\n  (0,react_devtools_shared_src_registerDevToolsEventLogger__WEBPACK_IMPORTED_MODULE_3__.registerDevToolsEventLogger)(loggerOptions?.surface ?? 'standalone');\n  const useHttps = !!httpsOptions;\n  const httpServer = useHttps ? (__webpack_require__(/*! https */ \"https\").createServer)(httpsOptions) : (__webpack_require__(/*! http */ \"http\").createServer)();\n  const server = new ws__WEBPACK_IMPORTED_MODULE_4__.Server({\n    server: httpServer,\n    maxPayload: 1e9\n  });\n  let connected = null;\n  server.on('connection', socket => {\n    if (connected !== null) {\n      connected.close();\n      log.warn('Only one connection allowed at a time.', 'Closing the previous connection');\n    }\n\n    connected = socket;\n\n    socket.onerror = error => {\n      connected = null;\n      onDisconnected();\n      log.error('Error with websocket connection', error);\n    };\n\n    socket.onclose = () => {\n      connected = null;\n      onDisconnected();\n      log('Connection to RN closed');\n    };\n\n    initialize(socket);\n  });\n\n  function handleWSError(event) {\n    if (event.code === 'EADDRINUSE') {\n      if (attempts < 10) {\n        log.warn(`Port ${port} in use, trying port ${port + 1}...`); // Try next port\n\n        return startServer(port + 1, host, httpsOptions, loggerOptions, attempts + 1);\n      } else {\n        onError(event);\n        statusListener('Failed to start the server after 10 attempts.', 'error');\n      }\n    } else {\n      onError(event);\n      statusListener('Failed to start the server.', 'error');\n    }\n\n    return Devtools;\n  }\n\n  server.on('error', handleWSError);\n\n  function handleError(event) {\n    onError(event);\n    statusListener('Failed to start the server.', 'error');\n    return Devtools;\n  }\n\n  httpServer.on('error', handleError);\n  httpServer.on('request', (request, response) => {\n    // Serve a file that immediately sets up the connection.\n    const backendFile = (0,fs__WEBPACK_IMPORTED_MODULE_6__.readFileSync)((0,path__WEBPACK_IMPORTED_MODULE_5__.join)(__dirname, 'backend.js'));\n    const savedPreferencesString = `\n      window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = ${JSON.stringify((0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_2__.getSavedComponentFilters)())};`;\n    response.end(savedPreferencesString + '\\n;' + backendFile.toString() + '\\n;' + 'ReactDevToolsBackend.initialize();' + '\\n' + `ReactDevToolsBackend.connectToDevTools({port: ${port}, host: '${host}', useHttps: ${useHttps ? 'true' : 'false'}});\n        `);\n  });\n  httpServer.listen(port, () => {\n    Devtools.currentPort = port;\n    statusListener('The server is listening on the port ' + port + '.', 'server-connected');\n  });\n  return Devtools;\n}\n\nconst resourceCache = new Map(); // As a potential improvement, this should be done from the backend of RDT.\n// Browser extension is doing this via exchanging messages\n// between devtools_page and dedicated content script for it, see `fetchFileWithCaching.js`.\n\nasync function fetchFileWithCaching(url) {\n  if (resourceCache.has(url)) {\n    const content = resourceCache.get(url);\n\n    if (content != null) {\n      return Promise.resolve(content);\n    }\n  }\n\n  return fetch(url).then(data => data.text()).then(content => {\n    resourceCache.set(url, content);\n    return content;\n  });\n}\n\nconst Devtools = {\n  currentPort: null,\n  connectToSocket,\n  setStatusListener,\n  setDisconnectedCallback,\n  startServer,\n  setDataCallback,\n  setInspectionCallback,\n  startInspectingHost,\n  stopInspectingHost\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Devtools);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RhbmRhbG9uZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTs7QUFPQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFNQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTs7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7QUFDQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBZEE7QUFpQkE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQVdBO0FBT0E7QUFFQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUFBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUE2QkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4vc3JjL3N0YW5kYWxvbmUuanM/ZTAwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgQnJpZGdlIGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYnJpZGdlJztcbmltcG9ydCBTdG9yZSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL3N0b3JlJztcbmltcG9ydCB7Z2V0U2F2ZWRDb21wb25lbnRGaWx0ZXJzfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3V0aWxzJztcbmltcG9ydCB7cmVnaXN0ZXJEZXZUb29sc0V2ZW50TG9nZ2VyfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3JlZ2lzdGVyRGV2VG9vbHNFdmVudExvZ2dlcic7XG5pbXBvcnQge1NlcnZlcn0gZnJvbSAnd3MnO1xuaW1wb3J0IHtqb2lufSBmcm9tICdwYXRoJztcbmltcG9ydCB7cmVhZEZpbGVTeW5jfSBmcm9tICdmcyc7XG5pbXBvcnQge19fREVCVUdfX30gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMnO1xuXG5pbXBvcnQgdHlwZSB7RnJvbnRlbmRCcmlkZ2V9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYnJpZGdlJztcbmltcG9ydCB7c3ltYm9saWNhdGVTb3VyY2VXaXRoQ2FjaGV9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvc3ltYm9saWNhdGVTb3VyY2UnO1xuaW1wb3J0IHR5cGUge0luc3BlY3RlZEVsZW1lbnRQYXlsb2FkfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdHlwZXMnO1xuaW1wb3J0IHsgdG9Ob3JtYWxVcmwgfSBmcm9tICdqc2Mtc2FmZS11cmwnO1xuZXhwb3J0IHR5cGUgU3RhdHVzVHlwZXMgPSAnc2VydmVyLWNvbm5lY3RlZCcgfCAnZGV2dG9vbHMtY29ubmVjdGVkJyB8ICdlcnJvcic7XG5leHBvcnQgdHlwZSBTdGF0dXNMaXN0ZW5lciA9IChtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogU3RhdHVzVHlwZXMpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBPbkRpc2Nvbm5lY3RlZENhbGxiYWNrID0gKCkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIE9uRGF0YUNhbGxiYWNrID0gKGRhdGE6IEluc3BlY3RlZEVsZW1lbnRQYXlsb2FkKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgT25JbnNwZWN0aW9uQ2FsbGJhY2sgPSAoaXNJbnNwZWN0aW5nOiBib29sZWFuKSA9PiB2b2lkO1xuXG5sZXQgc3RhdHVzTGlzdGVuZXI6IFN0YXR1c0xpc3RlbmVyID0gKFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIHN0YXR1cz86IFN0YXR1c1R5cGVzLFxuKSA9PiB7XG4gIGxvZygnU3RhdHVzJywgbWVzc2FnZSwgc3RhdHVzKTtcbn07XG5cbmZ1bmN0aW9uIHNldFN0YXR1c0xpc3RlbmVyKHZhbHVlOiBTdGF0dXNMaXN0ZW5lcik6IERldnRvb2xzVHlwZSB7XG4gIHN0YXR1c0xpc3RlbmVyID0gdmFsdWU7XG4gIHJldHVybiBEZXZ0b29scztcbn1cblxubGV0IGRpc2Nvbm5lY3RlZENhbGxiYWNrOiBPbkRpc2Nvbm5lY3RlZENhbGxiYWNrID0gKCkgPT4ge307XG5mdW5jdGlvbiBzZXREaXNjb25uZWN0ZWRDYWxsYmFjayh2YWx1ZTogT25EaXNjb25uZWN0ZWRDYWxsYmFjayk6IERldnRvb2xzVHlwZSB7XG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gdmFsdWU7XG4gIHJldHVybiBEZXZ0b29scztcbn1cblxubGV0IGRhdGFDYWxsYmFjazogT25EYXRhQ2FsbGJhY2sgPSAoKSA9PiB7fTtcbmZ1bmN0aW9uIHNldERhdGFDYWxsYmFjayh2YWx1ZTogT25EYXRhQ2FsbGJhY2spOiBEZXZ0b29sc1R5cGUge1xuICBkYXRhQ2FsbGJhY2sgPSB2YWx1ZTtcbiAgcmV0dXJuIERldnRvb2xzO1xufVxuXG5sZXQgaW5zcGVjdGlvbkNhbGxiYWNrOiBPbkluc3BlY3Rpb25DYWxsYmFjayA9ICgpID0+IHt9O1xuZnVuY3Rpb24gc2V0SW5zcGVjdGlvbkNhbGxiYWNrKHZhbHVlOiBPbkluc3BlY3Rpb25DYWxsYmFjayk6IERldnRvb2xzVHlwZSB7XG4gIGluc3BlY3Rpb25DYWxsYmFjayA9IHZhbHVlO1xuICByZXR1cm4gRGV2dG9vbHM7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0SW5zcGVjdGluZ0hvc3QoKSB7XG4gIGlmICghYnJpZGdlIHx8ICFzdG9yZSkge1xuICAgIGNvbnNvbGUubG9nKCdubyBicmlkZ2Ugb3Igc3RvcmUnKTtcbiAgICByZXR1cm4gRGV2dG9vbHM7XG4gIH1cbiAgYnJpZGdlLnNlbmQoJ3N0YXJ0SW5zcGVjdGluZ0hvc3QnKTtcbiAgcmV0dXJuIERldnRvb2xzO1xufVxuXG5mdW5jdGlvbiBzdG9wSW5zcGVjdGluZ0hvc3QoKSB7XG4gIGlmICghYnJpZGdlIHx8ICFzdG9yZSkge1xuICAgIGNvbnNvbGUubG9nKCdubyBicmlkZ2Ugb3Igc3RvcmUnKTtcbiAgICByZXR1cm4gRGV2dG9vbHM7XG4gIH1cbiAgYnJpZGdlLnNlbmQoJ3N0b3BJbnNwZWN0aW5nSG9zdCcsIGZhbHNlKTtcbiAgcmV0dXJuIERldnRvb2xzO1xufVxuXG5sZXQgYnJpZGdlOiBGcm9udGVuZEJyaWRnZSB8IG51bGwgPSBudWxsO1xubGV0IHN0b3JlOiBTdG9yZSB8IG51bGwgPSBudWxsO1xuXG5jb25zdCBsb2cgPSAoLi4uYXJnczogQXJyYXk8bWl4ZWQ+KSA9PiBjb25zb2xlLmxvZygnW1JlYWN0IERldlRvb2xzXScsIC4uLmFyZ3MpO1xubG9nLndhcm4gPSAoLi4uYXJnczogQXJyYXk8bWl4ZWQ+KSA9PiBjb25zb2xlLndhcm4oJ1tSZWFjdCBEZXZUb29sc10nLCAuLi5hcmdzKTtcbmxvZy5lcnJvciA9ICguLi5hcmdzOiBBcnJheTxtaXhlZD4pID0+XG4gIGNvbnNvbGUuZXJyb3IoJ1tSZWFjdCBEZXZUb29sc10nLCAuLi5hcmdzKTtcblxuZnVuY3Rpb24gZGVidWcobWV0aG9kTmFtZTogc3RyaW5nLCAuLi5hcmdzOiBBcnJheTxtaXhlZD4pIHtcbiAgaWYgKF9fREVCVUdfXykge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYCVjW2NvcmUvc3RhbmRhbG9uZV0gJWMke21ldGhvZE5hbWV9YCxcbiAgICAgICdjb2xvcjogdGVhbDsgZm9udC13ZWlnaHQ6IGJvbGQ7JyxcbiAgICAgICdmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgLi4uYXJncyxcbiAgICApO1xuICB9XG59XG5cbmxldCBpID0gMDtcblxuZnVuY3Rpb24gcmVsb2FkKCkge1xuICBpZiAoIWJyaWRnZSB8fCAhc3RvcmUpIHtcbiAgICBjb25zb2xlLmxvZygnbm8gYnJpZGdlIG9yIHN0b3JlJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxvY2FsQnJpZGdlID0gYnJpZGdlO1xuICBjb25zdCBsb2NhbFN0b3JlID0gc3RvcmU7XG5cbiAgbG9jYWxCcmlkZ2UuYWRkTGlzdGVuZXIoJ3NlbGVjdEVsZW1lbnQnLCBlbGVtZW50SWQgPT4ge1xuICAgIGNvbnN0IHJlbmRlcmVySUQgPSBsb2NhbFN0b3JlLmdldFJlbmRlcmVySURGb3JFbGVtZW50KGVsZW1lbnRJZCk7XG4gICAgLy8gY29uc3QgZWxlbWVudCA9IGxvY2FsU3RvcmUuZ2V0RWxlbWVudEJ5SUQoZWxlbWVudElkKTtcblxuICAgIGlmIChyZW5kZXJlcklEID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnbm8gcmVuZGVyZXIgaWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgaWQ6IGVsZW1lbnRJZCxcbiAgICAgIHJlbmRlcmVySUQsXG4gICAgICByZXF1ZXN0SUQ6IGkrKyxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBmb3JjZUZ1bGxEYXRhOiB0cnVlLFxuICAgIH07XG5cbiAgICBsb2NhbEJyaWRnZS5zZW5kKCdpbnNwZWN0RWxlbWVudCcsIHBheWxvYWQpO1xuICB9KTtcbiAgXG4gIGxvY2FsQnJpZGdlLmFkZExpc3RlbmVyKCdzdGFydEluc3BlY3RpbmdIb3N0JywgKCkgPT4ge1xuICAgIGluc3BlY3Rpb25DYWxsYmFjayh0cnVlKTtcbiAgfSlcblxuICBsb2NhbEJyaWRnZS5hZGRMaXN0ZW5lcignc3RvcEluc3BlY3RpbmdIb3N0JywgKCkgPT4ge1xuICAgIGluc3BlY3Rpb25DYWxsYmFjayhmYWxzZSk7XG4gIH0pXG5cbiAgbG9jYWxCcmlkZ2UuYWRkTGlzdGVuZXIoJ2luc3BlY3RlZEVsZW1lbnQnLCBhc3luYyBkYXRhID0+IHtcbiAgICBpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdmdWxsLWRhdGEnKSB7XG4gICAgICBcblxuICAgICAgaWYgKGRhdGEudmFsdWUuc291cmNlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKVxuICAgICAgfTtcblxuICAgICAgY29uc3Qge3NvdXJjZVVSTCwgbGluZSwgY29sdW1ufSA9IGRhdGEudmFsdWUuc291cmNlO1xuICAgICAgY29uc29sZS5sb2coJ1tkZXZ0b29sc10gaW5wdXQnLCB7IHNvdXJjZVVSTCwgbGluZSwgY29sdW1uLCBmZXRjaEZpbGVXaXRoQ2FjaGluZ30pO1xuICAgICAgY29uc3Qgc3ltYm9saWNhdGVkU291cmNlID0gYXdhaXQgc3ltYm9saWNhdGVTb3VyY2VXaXRoQ2FjaGUoXG4gICAgICAgIGZldGNoRmlsZVdpdGhDYWNoaW5nLFxuICAgICAgICBzb3VyY2VVUkwsXG4gICAgICAgIGxpbmUsXG4gICAgICAgIGNvbHVtbixcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZygnW2RldnRvb2xzXSBvdXRwdXQnLCB7IHNvdXJjZTogc3ltYm9saWNhdGVkU291cmNlIH0pO1xuXG4gICAgICBpZiAoc3ltYm9saWNhdGVkU291cmNlID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tkZXZ0b29sc10gTm8gc3ltYm9saWNhdGVkIHNvdXJjZSwgcmVuZGVyaW5nIHNpbXBsZSBzb3VyY2UgJywgZm9ybWF0U291cmNlRm9yRGlzcGxheShzb3VyY2VVUkwsIGxpbmUpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tkZXZ0b29sc10gU3ltYm9saWNhdGVkIHNvdXJjZSBmb3VuZDonLCBmb3JtYXRTb3VyY2VGb3JEaXNwbGF5KHN5bWJvbGljYXRlZFNvdXJjZS5zb3VyY2VVUkwsIHN5bWJvbGljYXRlZFNvdXJjZS5saW5lKSlcbiAgICAgIH1cblxuICAgICAgZGF0YUNhbGxiYWNrKGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhQ2FsbGJhY2soZGF0YSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKCkgaW4gcGFja2FnZXMvc2hhcmVkL1JlYWN0Q29tcG9uZW50U3RhY2tGcmFtZVxuZnVuY3Rpb24gZm9ybWF0U291cmNlRm9yRGlzcGxheShzb3VyY2VVUkw6IHN0cmluZywgbGluZTogbnVtYmVyKSB7XG4gIC8vIE1ldHJvIGNhbiByZXR1cm4gSlNDLXNhZmUgVVJMcywgd2hpY2ggaGF2ZSBgLy8mYCBhcyBhIGRlbGltaXRlclxuICAvLyBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9qc2Mtc2FmZS11cmxcbiAgY29uc3Qgc2FuaXRpemVkU291cmNlVVJMID0gc291cmNlVVJMLmluY2x1ZGVzKCcvLyYnKVxuICAgID8gdG9Ob3JtYWxVcmwoc291cmNlVVJMKVxuICAgIDogc291cmNlVVJMO1xuXG4gIC8vIE5vdGU6IHRoaXMgUmVnRXhwIGRvZXNuJ3Qgd29yayB3ZWxsIHdpdGggVVJMcyBmcm9tIE1ldHJvLFxuICAvLyB3aGljaCBwcm92aWRlcyBidW5kbGUgVVJMIHdpdGggcXVlcnkgcGFyYW1ldGVycyBwcmVmaXhlZCB3aXRoIC8mXG4gIGNvbnN0IEJFRk9SRV9TTEFTSF9SRSA9IC9eKC4qKVtcXFxcXFwvXS87XG5cbiAgbGV0IG5hbWVPbmx5ID0gc2FuaXRpemVkU291cmNlVVJMLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG5cbiAgLy8gSW4gREVWLCBpbmNsdWRlIGNvZGUgZm9yIGEgY29tbW9uIHNwZWNpYWwgY2FzZTpcbiAgLy8gcHJlZmVyIFwiZm9sZGVyL2luZGV4LmpzXCIgaW5zdGVhZCBvZiBqdXN0IFwiaW5kZXguanNcIi5cbiAgaWYgKC9eaW5kZXhcXC4vLnRlc3QobmFtZU9ubHkpKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBzYW5pdGl6ZWRTb3VyY2VVUkwubWF0Y2goQkVGT1JFX1NMQVNIX1JFKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IHBhdGhCZWZvcmVTbGFzaCA9IG1hdGNoWzFdO1xuICAgICAgaWYgKHBhdGhCZWZvcmVTbGFzaCkge1xuICAgICAgICBjb25zdCBmb2xkZXJOYW1lID0gcGF0aEJlZm9yZVNsYXNoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG4gICAgICAgIG5hbWVPbmx5ID0gZm9sZGVyTmFtZSArICcvJyArIG5hbWVPbmx5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBgJHtuYW1lT25seX06JHtsaW5lfWA7XG59XG5cbmZ1bmN0aW9uIG9uRGlzY29ubmVjdGVkKCkge1xuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xufVxuXG5mdW5jdGlvbiBvbkVycm9yKHtjb2RlLCBtZXNzYWdlfTogJEZsb3dGaXhNZSkge1xuICBjb25zb2xlLmVycm9yKGBFcnJvcjogJHtjb2RlfSAke21lc3NhZ2V9YCk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUoc29ja2V0OiBXZWJTb2NrZXQpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgbGV0IGRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG5cbiAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgIGRlYnVnKCdXZWJTb2NrZXQub25tZXNzYWdlJywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgSlNPTicsIGV2ZW50LmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmbiA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmbihkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZy5lcnJvcignRXJyb3IgY2FsbGluZyBsaXN0ZW5lcicsIGRhdGEpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBicmlkZ2UgPSBuZXcgQnJpZGdlKHtcbiAgICBsaXN0ZW4oZm4pIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGZuKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoZm4pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgc2VuZChldmVudDogc3RyaW5nLCBwYXlsb2FkOiBhbnksIHRyYW5zZmVyYWJsZT86IEFycmF5PGFueT4pIHtcbiAgICAgIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gc29ja2V0Lk9QRU4pIHtcbiAgICAgICAgc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe2V2ZW50LCBwYXlsb2FkfSkpO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xuXG4gICgoYnJpZGdlOiBhbnkpOiBGcm9udGVuZEJyaWRnZSkuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgKCkgPT4ge1xuICAgIHNvY2tldC5jbG9zZSgpO1xuICB9KTtcblxuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gIHN0b3JlID0gbmV3IFN0b3JlKGJyaWRnZSwge1xuICAgIGNoZWNrQnJpZGdlUHJvdG9jb2xDb21wYXRpYmlsaXR5OiB0cnVlLFxuICAgIHN1cHBvcnRzVHJhY2VVcGRhdGVzOiB0cnVlLFxuICAgIHN1cHBvcnRzQ2xpY2tUb0luc3BlY3Q6IHRydWUsXG4gIH0pO1xuXG4gIGxvZygnQ29ubmVjdGVkJyk7XG4gIHN0YXR1c0xpc3RlbmVyKCdEZXZUb29scyBpbml0aWFsaXplZC4nLCAnZGV2dG9vbHMtY29ubmVjdGVkJyk7XG4gIHJlbG9hZCgpO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0VG9Tb2NrZXQoc29ja2V0OiBXZWJTb2NrZXQpOiB7Y2xvc2UoKTogdm9pZH0ge1xuICBzb2NrZXQub25lcnJvciA9IGVyciA9PiB7XG4gICAgb25EaXNjb25uZWN0ZWQoKTtcbiAgICBsb2cuZXJyb3IoJ0Vycm9yIHdpdGggd2Vic29ja2V0IGNvbm5lY3Rpb24nLCBlcnIpO1xuICB9O1xuICBzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcbiAgICBvbkRpc2Nvbm5lY3RlZCgpO1xuICAgIGxvZygnQ29ubmVjdGlvbiB0byBSTiBjbG9zZWQnKTtcbiAgfTtcbiAgaW5pdGlhbGl6ZShzb2NrZXQpO1xuXG4gIHJldHVybiB7XG4gICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uRGlzY29ubmVjdGVkKCk7XG4gICAgfSxcbiAgfTtcbn1cblxudHlwZSBTZXJ2ZXJPcHRpb25zID0ge1xuICBrZXk/OiBzdHJpbmcsXG4gIGNlcnQ/OiBzdHJpbmcsXG59O1xuXG50eXBlIExvZ2dlck9wdGlvbnMgPSB7XG4gIHN1cmZhY2U/OiA/c3RyaW5nLFxufTtcblxuZnVuY3Rpb24gc3RhcnRTZXJ2ZXIoXG4gIHBvcnQ6IG51bWJlciA9IDgwOTcsXG4gIGhvc3Q6IHN0cmluZyA9ICdsb2NhbGhvc3QnLFxuICBodHRwc09wdGlvbnM/OiBTZXJ2ZXJPcHRpb25zLFxuICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgYXR0ZW1wdHM6IG51bWJlciA9IDAsXG4pOiBEZXZ0b29sc1R5cGUge1xuICByZWdpc3RlckRldlRvb2xzRXZlbnRMb2dnZXIobG9nZ2VyT3B0aW9ucz8uc3VyZmFjZSA/PyAnc3RhbmRhbG9uZScpO1xuXG4gIGNvbnN0IHVzZUh0dHBzID0gISFodHRwc09wdGlvbnM7XG4gIGNvbnN0IGh0dHBTZXJ2ZXIgPSB1c2VIdHRwc1xuICAgID8gcmVxdWlyZSgnaHR0cHMnKS5jcmVhdGVTZXJ2ZXIoaHR0cHNPcHRpb25zKVxuICAgIDogcmVxdWlyZSgnaHR0cCcpLmNyZWF0ZVNlcnZlcigpO1xuICBjb25zdCBzZXJ2ZXIgPSBuZXcgU2VydmVyKHtzZXJ2ZXI6IGh0dHBTZXJ2ZXIsIG1heFBheWxvYWQ6IDFlOX0pO1xuICBsZXQgY29ubmVjdGVkOiBXZWJTb2NrZXQgfCBudWxsID0gbnVsbDtcblxuICBzZXJ2ZXIub24oJ2Nvbm5lY3Rpb24nLCAoc29ja2V0OiBXZWJTb2NrZXQpID0+IHtcbiAgICBpZiAoY29ubmVjdGVkICE9PSBudWxsKSB7XG4gICAgICBjb25uZWN0ZWQuY2xvc2UoKTtcbiAgICAgIGxvZy53YXJuKFxuICAgICAgICAnT25seSBvbmUgY29ubmVjdGlvbiBhbGxvd2VkIGF0IGEgdGltZS4nLFxuICAgICAgICAnQ2xvc2luZyB0aGUgcHJldmlvdXMgY29ubmVjdGlvbicsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25uZWN0ZWQgPSBzb2NrZXQ7XG4gICAgc29ja2V0Lm9uZXJyb3IgPSBlcnJvciA9PiB7XG4gICAgICBjb25uZWN0ZWQgPSBudWxsO1xuICAgICAgb25EaXNjb25uZWN0ZWQoKTtcbiAgICAgIGxvZy5lcnJvcignRXJyb3Igd2l0aCB3ZWJzb2NrZXQgY29ubmVjdGlvbicsIGVycm9yKTtcbiAgICB9O1xuICAgIHNvY2tldC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgY29ubmVjdGVkID0gbnVsbDtcbiAgICAgIG9uRGlzY29ubmVjdGVkKCk7XG4gICAgICBsb2coJ0Nvbm5lY3Rpb24gdG8gUk4gY2xvc2VkJyk7XG4gICAgfTtcbiAgICBpbml0aWFsaXplKHNvY2tldCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVdTRXJyb3IoZXZlbnQ6ICRGbG93Rml4TWUpIHtcbiAgICBpZiAoZXZlbnQuY29kZSA9PT0gJ0VBRERSSU5VU0UnKSB7XG4gICAgICBpZiAoYXR0ZW1wdHMgPCAxMCkge1xuICAgICAgICBsb2cud2FybihgUG9ydCAke3BvcnR9IGluIHVzZSwgdHJ5aW5nIHBvcnQgJHtwb3J0ICsgMX0uLi5gKTtcbiAgICAgICAgLy8gVHJ5IG5leHQgcG9ydFxuICAgICAgICByZXR1cm4gc3RhcnRTZXJ2ZXIoXG4gICAgICAgICAgcG9ydCArIDEsXG4gICAgICAgICAgaG9zdCxcbiAgICAgICAgICBodHRwc09wdGlvbnMsXG4gICAgICAgICAgbG9nZ2VyT3B0aW9ucyxcbiAgICAgICAgICBhdHRlbXB0cyArIDEsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkVycm9yKGV2ZW50KTtcbiAgICAgICAgc3RhdHVzTGlzdGVuZXIoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBzdGFydCB0aGUgc2VydmVyIGFmdGVyIDEwIGF0dGVtcHRzLicsXG4gICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihldmVudCk7XG4gICAgICBzdGF0dXNMaXN0ZW5lcignRmFpbGVkIHRvIHN0YXJ0IHRoZSBzZXJ2ZXIuJywgJ2Vycm9yJyk7XG4gICAgfVxuICAgIHJldHVybiBEZXZ0b29scztcbiAgfVxuXG4gIHNlcnZlci5vbignZXJyb3InLCBoYW5kbGVXU0Vycm9yKTtcblxuICBmdW5jdGlvbiBoYW5kbGVFcnJvcihldmVudDogJEZsb3dGaXhNZSkge1xuICAgIG9uRXJyb3IoZXZlbnQpO1xuICAgIHN0YXR1c0xpc3RlbmVyKCdGYWlsZWQgdG8gc3RhcnQgdGhlIHNlcnZlci4nLCAnZXJyb3InKTtcbiAgICByZXR1cm4gRGV2dG9vbHM7XG4gIH1cblxuICBodHRwU2VydmVyLm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcblxuICBodHRwU2VydmVyLm9uKCdyZXF1ZXN0JywgKHJlcXVlc3Q6ICRGbG93Rml4TWUsIHJlc3BvbnNlOiAkRmxvd0ZpeE1lKSA9PiB7XG4gICAgLy8gU2VydmUgYSBmaWxlIHRoYXQgaW1tZWRpYXRlbHkgc2V0cyB1cCB0aGUgY29ubmVjdGlvbi5cbiAgICBjb25zdCBiYWNrZW5kRmlsZSA9IHJlYWRGaWxlU3luYyhqb2luKF9fZGlybmFtZSwgJ2JhY2tlbmQuanMnKSk7XG5cbiAgICBjb25zdCBzYXZlZFByZWZlcmVuY2VzU3RyaW5nID0gYFxuICAgICAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQ09NUE9ORU5UX0ZJTFRFUlNfXyA9ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGdldFNhdmVkQ29tcG9uZW50RmlsdGVycygpLFxuICAgICAgKX07YDtcblxuICAgIHJlc3BvbnNlLmVuZChcbiAgICAgIHNhdmVkUHJlZmVyZW5jZXNTdHJpbmcgK1xuICAgICAgICAnXFxuOycgK1xuICAgICAgICBiYWNrZW5kRmlsZS50b1N0cmluZygpICtcbiAgICAgICAgJ1xcbjsnICtcbiAgICAgICAgJ1JlYWN0RGV2VG9vbHNCYWNrZW5kLmluaXRpYWxpemUoKTsnICtcbiAgICAgICAgJ1xcbicgK1xuICAgICAgICBgUmVhY3REZXZUb29sc0JhY2tlbmQuY29ubmVjdFRvRGV2VG9vbHMoe3BvcnQ6ICR7cG9ydH0sIGhvc3Q6ICcke2hvc3R9JywgdXNlSHR0cHM6ICR7XG4gICAgICAgICAgdXNlSHR0cHMgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICAgIH19KTtcbiAgICAgICAgYCxcbiAgICApO1xuICB9KTtcblxuICBodHRwU2VydmVyLmxpc3Rlbihwb3J0LCAoKSA9PiB7XG4gICAgRGV2dG9vbHMuY3VycmVudFBvcnQgPSBwb3J0O1xuICAgIHN0YXR1c0xpc3RlbmVyKFxuICAgICAgJ1RoZSBzZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uIHRoZSBwb3J0ICcgKyBwb3J0ICsgJy4nLFxuICAgICAgJ3NlcnZlci1jb25uZWN0ZWQnLFxuICAgICk7XG4gIH0pO1xuXG4gIHJldHVybiBEZXZ0b29scztcbn1cblxuY29uc3QgcmVzb3VyY2VDYWNoZTogTWFwPHN0cmluZywgc3RyaW5nPiA9IG5ldyBNYXAoKTtcblxuLy8gQXMgYSBwb3RlbnRpYWwgaW1wcm92ZW1lbnQsIHRoaXMgc2hvdWxkIGJlIGRvbmUgZnJvbSB0aGUgYmFja2VuZCBvZiBSRFQuXG4vLyBCcm93c2VyIGV4dGVuc2lvbiBpcyBkb2luZyB0aGlzIHZpYSBleGNoYW5naW5nIG1lc3NhZ2VzXG4vLyBiZXR3ZWVuIGRldnRvb2xzX3BhZ2UgYW5kIGRlZGljYXRlZCBjb250ZW50IHNjcmlwdCBmb3IgaXQsIHNlZSBgZmV0Y2hGaWxlV2l0aENhY2hpbmcuanNgLlxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hGaWxlV2l0aENhY2hpbmcodXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAocmVzb3VyY2VDYWNoZS5oYXModXJsKSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSByZXNvdXJjZUNhY2hlLmdldCh1cmwpO1xuICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZldGNoKHVybClcbiAgICAudGhlbihkYXRhID0+IGRhdGEudGV4dCgpKVxuICAgIC50aGVuKGNvbnRlbnQgPT4ge1xuICAgICAgcmVzb3VyY2VDYWNoZS5zZXQodXJsLCBjb250ZW50KTtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pO1xufVxuXG5jb25zdCBEZXZ0b29sczogRGV2dG9vbHNUeXBlID0ge1xuICBjdXJyZW50UG9ydDogbnVsbCxcbiAgY29ubmVjdFRvU29ja2V0LFxuICBzZXRTdGF0dXNMaXN0ZW5lcixcbiAgc2V0RGlzY29ubmVjdGVkQ2FsbGJhY2ssXG4gIHN0YXJ0U2VydmVyLFxuICBzZXREYXRhQ2FsbGJhY2ssXG4gIHNldEluc3BlY3Rpb25DYWxsYmFjayxcbiAgc3RhcnRJbnNwZWN0aW5nSG9zdCxcbiAgc3RvcEluc3BlY3RpbmdIb3N0LFxufTtcblxudHlwZSBEZXZ0b29sc1R5cGUgPSB7XG4gIGN1cnJlbnRQb3J0OiA/bnVtYmVyLFxuICBjb25uZWN0VG9Tb2NrZXQ6IChzb2NrZXQ6IFdlYlNvY2tldCkgPT4ge2Nsb3NlKCk6IHZvaWR9LFxuICBzZXRTdGF0dXNMaXN0ZW5lcjogKHZhbHVlOiBTdGF0dXNMaXN0ZW5lcikgPT4gRGV2dG9vbHNUeXBlLFxuICBzZXREaXNjb25uZWN0ZWRDYWxsYmFjazogKHZhbHVlOiBPbkRpc2Nvbm5lY3RlZENhbGxiYWNrKSA9PiBEZXZ0b29sc1R5cGUsXG4gIHNldERhdGFDYWxsYmFjazogKHZhbHVlOiBPbkRhdGFDYWxsYmFjaykgPT4gRGV2dG9vbHNUeXBlLFxuICBzZXRJbnNwZWN0aW9uQ2FsbGJhY2s6ICh2YWx1ZTogT25JbnNwZWN0aW9uQ2FsbGJhY2spID0+IERldnRvb2xzVHlwZSxcbiAgc3RhcnRJbnNwZWN0aW5nSG9zdDogKCkgPT4gRGV2dG9vbHNUeXBlLFxuICBzdG9wSW5zcGVjdGluZ0hvc3Q6ICgpID0+IERldnRvb2xzVHlwZSxcbiAgc3RhcnRTZXJ2ZXI6IChcbiAgICBwb3J0OiBudW1iZXIsXG4gICAgaG9zdDogc3RyaW5nLFxuICAgIGh0dHBzT3B0aW9ucz86IFNlcnZlck9wdGlvbnMsXG4gICAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnMsXG4gICkgPT4gRGV2dG9vbHNUeXBlLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGV2dG9vbHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/standalone.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/Logger.js":
/*!**********************************************!*\
  !*** ../react-devtools-shared/src/Logger.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"logEvent\": () => (/* binding */ logEvent),\n/* harmony export */   \"registerEventLogger\": () => (/* binding */ registerEventLogger)\n/* harmony export */ });\n/* harmony import */ var react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-feature-flags */ \"../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nlet logFunctions = [];\nconst logEvent = react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_0__.enableLogger === true ? function logEvent(event) {\n  logFunctions.forEach(log => {\n    log(event);\n  });\n} : function logEvent() {};\nconst registerEventLogger = react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_0__.enableLogger === true ? function registerEventLogger(logFunction) {\n  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_0__.enableLogger) {\n    logFunctions.push(logFunction);\n    return function unregisterEventLogger() {\n      logFunctions = logFunctions.filter(log => log !== logFunction);\n    };\n  }\n\n  return () => {};\n} : function registerEventLogger(logFunction) {\n  return () => {};\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9Mb2dnZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUF5REE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvTG9nZ2VyLmpzP2NkY2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93IHN0cmljdC1sb2NhbFxuICovXG5cbmltcG9ydCB7ZW5hYmxlTG9nZ2VyfSBmcm9tICdyZWFjdC1kZXZ0b29scy1mZWF0dXJlLWZsYWdzJztcblxuZXhwb3J0IHR5cGUgTG9nZ2VyRXZlbnQgPVxuICB8IHtcbiAgICAgICtldmVudF9uYW1lOiAnbG9hZGVkLWRldi10b29scycsXG4gICAgfVxuICB8IHtcbiAgICAgICtldmVudF9uYW1lOiAnZXJyb3InLFxuICAgICAgK2Vycm9yX21lc3NhZ2U6IHN0cmluZyB8IG51bGwsXG4gICAgICArZXJyb3Jfc3RhY2s6IHN0cmluZyB8IG51bGwsXG4gICAgICArZXJyb3JfY29tcG9uZW50X3N0YWNrOiBzdHJpbmcgfCBudWxsLFxuICAgIH1cbiAgfCB7XG4gICAgICArZXZlbnRfbmFtZTogJ3NlbGVjdGVkLWNvbXBvbmVudHMtdGFiJyxcbiAgICB9XG4gIHwge1xuICAgICAgK2V2ZW50X25hbWU6ICdzZWxlY3RlZC1wcm9maWxlci10YWInLFxuICAgIH1cbiAgfCB7XG4gICAgICArZXZlbnRfbmFtZTogJ2xvYWQtaG9vay1uYW1lcycsXG4gICAgICArZXZlbnRfc3RhdHVzOiAnc3VjY2VzcycgfCAnZXJyb3InIHwgJ3RpbWVvdXQnIHwgJ3Vua25vd24nLFxuICAgICAgK2R1cmF0aW9uX21zOiBudW1iZXIsXG4gICAgICAraW5zcGVjdGVkX2VsZW1lbnRfZGlzcGxheV9uYW1lOiBzdHJpbmcgfCBudWxsLFxuICAgICAgK2luc3BlY3RlZF9lbGVtZW50X251bWJlcl9vZl9ob29rczogbnVtYmVyIHwgbnVsbCxcbiAgICB9XG4gIHwge1xuICAgICAgK2V2ZW50X25hbWU6ICdzZWxlY3QtZWxlbWVudCcsXG4gICAgICArbWV0YWRhdGE6IHtcbiAgICAgICAgK3NvdXJjZTogc3RyaW5nLFxuICAgICAgfSxcbiAgICB9XG4gIHwge1xuICAgICAgK2V2ZW50X25hbWU6ICdpbnNwZWN0LWVsZW1lbnQtYnV0dG9uLWNsaWNrZWQnLFxuICAgIH1cbiAgfCB7XG4gICAgICArZXZlbnRfbmFtZTogJ3Byb2ZpbGluZy1zdGFydCcsXG4gICAgICArbWV0YWRhdGE6IHtcbiAgICAgICAgK2N1cnJlbnRfdGFiOiBzdHJpbmcsXG4gICAgICB9LFxuICAgIH1cbiAgfCB7XG4gICAgICArZXZlbnRfbmFtZTogJ3Byb2ZpbGVyLXRhYi1jaGFuZ2VkJyxcbiAgICAgICttZXRhZGF0YToge1xuICAgICAgICArdGFiSWQ6IHN0cmluZyxcbiAgICAgIH0sXG4gICAgfVxuICB8IHtcbiAgICAgICtldmVudF9uYW1lOiAnc2V0dGluZ3MtY2hhbmdlZCcsXG4gICAgICArbWV0YWRhdGE6IHtcbiAgICAgICAgK2tleTogc3RyaW5nLFxuICAgICAgICArdmFsdWU6IGFueSxcbiAgICAgICAgLi4uXG4gICAgICB9LFxuICAgIH07XG5cbmV4cG9ydCB0eXBlIExvZ0Z1bmN0aW9uID0gTG9nZ2VyRXZlbnQgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG5cbmxldCBsb2dGdW5jdGlvbnM6IEFycmF5PExvZ0Z1bmN0aW9uPiA9IFtdO1xuZXhwb3J0IGNvbnN0IGxvZ0V2ZW50OiBMb2dGdW5jdGlvbiA9XG4gIGVuYWJsZUxvZ2dlciA9PT0gdHJ1ZVxuICAgID8gZnVuY3Rpb24gbG9nRXZlbnQoZXZlbnQ6IExvZ2dlckV2ZW50KTogdm9pZCB7XG4gICAgICAgIGxvZ0Z1bmN0aW9ucy5mb3JFYWNoKGxvZyA9PiB7XG4gICAgICAgICAgbG9nKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgOiBmdW5jdGlvbiBsb2dFdmVudCgpIHt9O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJFdmVudExvZ2dlcjogKGxvZ0Z1bmN0aW9uOiBMb2dGdW5jdGlvbikgPT4gKCkgPT4gdm9pZCA9XG4gIGVuYWJsZUxvZ2dlciA9PT0gdHJ1ZVxuICAgID8gZnVuY3Rpb24gcmVnaXN0ZXJFdmVudExvZ2dlcihsb2dGdW5jdGlvbjogTG9nRnVuY3Rpb24pOiAoKSA9PiB2b2lkIHtcbiAgICAgICAgaWYgKGVuYWJsZUxvZ2dlcikge1xuICAgICAgICAgIGxvZ0Z1bmN0aW9ucy5wdXNoKGxvZ0Z1bmN0aW9uKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gdW5yZWdpc3RlckV2ZW50TG9nZ2VyKCkge1xuICAgICAgICAgICAgbG9nRnVuY3Rpb25zID0gbG9nRnVuY3Rpb25zLmZpbHRlcihsb2cgPT4gbG9nICE9PSBsb2dGdW5jdGlvbik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICB9XG4gICAgOiBmdW5jdGlvbiByZWdpc3RlckV2ZW50TG9nZ2VyKGxvZ0Z1bmN0aW9uOiBMb2dGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/Logger.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/PerformanceLoggingUtils.js":
/*!***************************************************************!*\
  !*** ../react-devtools-shared/src/PerformanceLoggingUtils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"withAsyncPerfMeasurements\": () => (/* binding */ withAsyncPerfMeasurements),\n/* harmony export */   \"withCallbackPerfMeasurements\": () => (/* binding */ withCallbackPerfMeasurements),\n/* harmony export */   \"withSyncPerfMeasurements\": () => (/* binding */ withSyncPerfMeasurements)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"../react-devtools-shared/src/constants.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst supportsUserTiming = typeof performance !== 'undefined' && // $FlowFixMe[method-unbinding]\ntypeof performance.mark === 'function' && // $FlowFixMe[method-unbinding]\ntypeof performance.clearMarks === 'function';\nconst supportsPerformanceNow = // $FlowFixMe[method-unbinding]\ntypeof performance !== 'undefined' && typeof performance.now === 'function';\n\nfunction mark(markName) {\n  if (supportsUserTiming) {\n    performance.mark(markName + '-start');\n  }\n}\n\nfunction measure(markName) {\n  if (supportsUserTiming) {\n    performance.mark(markName + '-end');\n    performance.measure(markName, markName + '-start', markName + '-end');\n    performance.clearMarks(markName + '-start');\n    performance.clearMarks(markName + '-end');\n  }\n}\n\nfunction now() {\n  if (supportsPerformanceNow) {\n    return performance.now();\n  }\n\n  return Date.now();\n}\n\nasync function withAsyncPerfMeasurements(markName, callback, onComplete) {\n  const start = now();\n\n  if (_constants__WEBPACK_IMPORTED_MODULE_0__.__PERFORMANCE_PROFILE__) {\n    mark(markName);\n  }\n\n  const result = await callback();\n\n  if (_constants__WEBPACK_IMPORTED_MODULE_0__.__PERFORMANCE_PROFILE__) {\n    measure(markName);\n  }\n\n  if (onComplete != null) {\n    const duration = now() - start;\n    onComplete(duration);\n  }\n\n  return result;\n}\nfunction withSyncPerfMeasurements(markName, callback, onComplete) {\n  const start = now();\n\n  if (_constants__WEBPACK_IMPORTED_MODULE_0__.__PERFORMANCE_PROFILE__) {\n    mark(markName);\n  }\n\n  const result = callback();\n\n  if (_constants__WEBPACK_IMPORTED_MODULE_0__.__PERFORMANCE_PROFILE__) {\n    measure(markName);\n  }\n\n  if (onComplete != null) {\n    const duration = now() - start;\n    onComplete(duration);\n  }\n\n  return result;\n}\nfunction withCallbackPerfMeasurements(markName, callback, onComplete) {\n  const start = now();\n\n  if (_constants__WEBPACK_IMPORTED_MODULE_0__.__PERFORMANCE_PROFILE__) {\n    mark(markName);\n  }\n\n  const done = () => {\n    if (_constants__WEBPACK_IMPORTED_MODULE_0__.__PERFORMANCE_PROFILE__) {\n      measure(markName);\n    }\n\n    if (onComplete != null) {\n      const duration = now() - start;\n      onComplete(duration);\n    }\n  };\n\n  return callback(done);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9QZXJmb3JtYW5jZUxvZ2dpbmdVdGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFFQTtBQUdBO0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBS0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvUGVyZm9ybWFuY2VMb2dnaW5nVXRpbHMuanM/YjMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3cgc3RyaWN0LWxvY2FsXG4gKi9cblxuaW1wb3J0IHtfX1BFUkZPUk1BTkNFX1BST0ZJTEVfX30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5jb25zdCBzdXBwb3J0c1VzZXJUaW1pbmcgPVxuICB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmXG4gIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJztcblxuY29uc3Qgc3VwcG9ydHNQZXJmb3JtYW5jZU5vdyA9XG4gIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBtYXJrKG1hcmtOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgIHBlcmZvcm1hbmNlLm1hcmsobWFya05hbWUgKyAnLXN0YXJ0Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVhc3VyZShtYXJrTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKG1hcmtOYW1lICsgJy1lbmQnKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1hcmtOYW1lLCBtYXJrTmFtZSArICctc3RhcnQnLCBtYXJrTmFtZSArICctZW5kJyk7XG4gICAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrTmFtZSArICctc3RhcnQnKTtcbiAgICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmtOYW1lICsgJy1lbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3coKTogbnVtYmVyIHtcbiAgaWYgKHN1cHBvcnRzUGVyZm9ybWFuY2VOb3cpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH1cbiAgcmV0dXJuIERhdGUubm93KCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoQXN5bmNQZXJmTWVhc3VyZW1lbnRzPFRSZXR1cm4+KFxuICBtYXJrTmFtZTogc3RyaW5nLFxuICBjYWxsYmFjazogKCkgPT4gUHJvbWlzZTxUUmV0dXJuPixcbiAgb25Db21wbGV0ZT86IG51bWJlciA9PiB2b2lkLFxuKTogUHJvbWlzZTxUUmV0dXJuPiB7XG4gIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gIGlmIChfX1BFUkZPUk1BTkNFX1BST0ZJTEVfXykge1xuICAgIG1hcmsobWFya05hbWUpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxiYWNrKCk7XG5cbiAgaWYgKF9fUEVSRk9STUFOQ0VfUFJPRklMRV9fKSB7XG4gICAgbWVhc3VyZShtYXJrTmFtZSk7XG4gIH1cblxuICBpZiAob25Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBub3coKSAtIHN0YXJ0O1xuICAgIG9uQ29tcGxldGUoZHVyYXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhTeW5jUGVyZk1lYXN1cmVtZW50czxUUmV0dXJuPihcbiAgbWFya05hbWU6IHN0cmluZyxcbiAgY2FsbGJhY2s6ICgpID0+IFRSZXR1cm4sXG4gIG9uQ29tcGxldGU/OiBudW1iZXIgPT4gdm9pZCxcbik6IFRSZXR1cm4ge1xuICBjb25zdCBzdGFydCA9IG5vdygpO1xuICBpZiAoX19QRVJGT1JNQU5DRV9QUk9GSUxFX18pIHtcbiAgICBtYXJrKG1hcmtOYW1lKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBjYWxsYmFjaygpO1xuXG4gIGlmIChfX1BFUkZPUk1BTkNFX1BST0ZJTEVfXykge1xuICAgIG1lYXN1cmUobWFya05hbWUpO1xuICB9XG5cbiAgaWYgKG9uQ29tcGxldGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gbm93KCkgLSBzdGFydDtcbiAgICBvbkNvbXBsZXRlKGR1cmF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQ2FsbGJhY2tQZXJmTWVhc3VyZW1lbnRzPFRSZXR1cm4+KFxuICBtYXJrTmFtZTogc3RyaW5nLFxuICBjYWxsYmFjazogKGRvbmU6ICgpID0+IHZvaWQpID0+IFRSZXR1cm4sXG4gIG9uQ29tcGxldGU/OiBudW1iZXIgPT4gdm9pZCxcbik6IFRSZXR1cm4ge1xuICBjb25zdCBzdGFydCA9IG5vdygpO1xuICBpZiAoX19QRVJGT1JNQU5DRV9QUk9GSUxFX18pIHtcbiAgICBtYXJrKG1hcmtOYW1lKTtcbiAgfVxuXG4gIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgaWYgKF9fUEVSRk9STUFOQ0VfUFJPRklMRV9fKSB7XG4gICAgICBtZWFzdXJlKG1hcmtOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAob25Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IG5vdygpIC0gc3RhcnQ7XG4gICAgICBvbkNvbXBsZXRlKGR1cmF0aW9uKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBjYWxsYmFjayhkb25lKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/PerformanceLoggingUtils.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/UnsupportedBridgeOperationError.js":
/*!***********************************************************************!*\
  !*** ../react-devtools-shared/src/UnsupportedBridgeOperationError.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UnsupportedBridgeOperationError)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass UnsupportedBridgeOperationError extends Error {\n  constructor(message) {\n    super(message); // Maintains proper stack trace for where our error was thrown (only available on V8)\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnsupportedBridgeOperationError);\n    }\n\n    this.name = 'UnsupportedBridgeOperationError';\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9VbnN1cHBvcnRlZEJyaWRnZU9wZXJhdGlvbkVycm9yLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBVkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvVW5zdXBwb3J0ZWRCcmlkZ2VPcGVyYXRpb25FcnJvci5qcz84MjdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVuc3VwcG9ydGVkQnJpZGdlT3BlcmF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVW5zdXBwb3J0ZWRCcmlkZ2VPcGVyYXRpb25FcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gJ1Vuc3VwcG9ydGVkQnJpZGdlT3BlcmF0aW9uRXJyb3InO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/UnsupportedBridgeOperationError.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/utils/formatConsoleArguments.js":
/*!****************************************************************************!*\
  !*** ../react-devtools-shared/src/backend/utils/formatConsoleArguments.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ formatConsoleArguments)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Do not add / import anything to this file.\n// This function could be used from multiple places, including hook.\n// Skips CSS and object arguments, inlines other in the first argument as a template string\nfunction formatConsoleArguments(maybeMessage, ...inputArgs) {\n  if (inputArgs.length === 0 || typeof maybeMessage !== 'string') {\n    return [maybeMessage, ...inputArgs];\n  }\n\n  const args = inputArgs.slice();\n  let template = '';\n  let argumentsPointer = 0;\n\n  for (let i = 0; i < maybeMessage.length; ++i) {\n    const currentChar = maybeMessage[i];\n\n    if (currentChar !== '%') {\n      template += currentChar;\n      continue;\n    }\n\n    const nextChar = maybeMessage[i + 1];\n    ++i; // Only keep CSS and objects, inline other arguments\n\n    switch (nextChar) {\n      case 'c':\n      case 'O':\n      case 'o':\n        {\n          ++argumentsPointer;\n          template += `%${nextChar}`;\n          break;\n        }\n\n      case 'd':\n      case 'i':\n        {\n          const [arg] = args.splice(argumentsPointer, 1);\n          template += parseInt(arg, 10).toString();\n          break;\n        }\n\n      case 'f':\n        {\n          const [arg] = args.splice(argumentsPointer, 1);\n          template += parseFloat(arg).toString();\n          break;\n        }\n\n      case 's':\n        {\n          const [arg] = args.splice(argumentsPointer, 1);\n          template += arg.toString();\n          break;\n        }\n\n      default:\n        template += `%${nextChar}`;\n    }\n  }\n\n  return [template, ...args];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2Zvcm1hdENvbnNvbGVBcmd1bWVudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQTlCQTtBQWdDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdXRpbHMvZm9ybWF0Q29uc29sZUFyZ3VtZW50cy5qcz81OTBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIERvIG5vdCBhZGQgLyBpbXBvcnQgYW55dGhpbmcgdG8gdGhpcyBmaWxlLlxuLy8gVGhpcyBmdW5jdGlvbiBjb3VsZCBiZSB1c2VkIGZyb20gbXVsdGlwbGUgcGxhY2VzLCBpbmNsdWRpbmcgaG9vay5cblxuLy8gU2tpcHMgQ1NTIGFuZCBvYmplY3QgYXJndW1lbnRzLCBpbmxpbmVzIG90aGVyIGluIHRoZSBmaXJzdCBhcmd1bWVudCBhcyBhIHRlbXBsYXRlIHN0cmluZ1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0Q29uc29sZUFyZ3VtZW50cyhcbiAgbWF5YmVNZXNzYWdlOiBhbnksXG4gIC4uLmlucHV0QXJnczogJFJlYWRPbmx5QXJyYXk8YW55PlxuKTogJFJlYWRPbmx5QXJyYXk8YW55PiB7XG4gIGlmIChpbnB1dEFyZ3MubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBtYXliZU1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFttYXliZU1lc3NhZ2UsIC4uLmlucHV0QXJnc107XG4gIH1cblxuICBjb25zdCBhcmdzID0gaW5wdXRBcmdzLnNsaWNlKCk7XG5cbiAgbGV0IHRlbXBsYXRlID0gJyc7XG4gIGxldCBhcmd1bWVudHNQb2ludGVyID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXliZU1lc3NhZ2UubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjdXJyZW50Q2hhciA9IG1heWJlTWVzc2FnZVtpXTtcbiAgICBpZiAoY3VycmVudENoYXIgIT09ICclJykge1xuICAgICAgdGVtcGxhdGUgKz0gY3VycmVudENoYXI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0Q2hhciA9IG1heWJlTWVzc2FnZVtpICsgMV07XG4gICAgKytpO1xuXG4gICAgLy8gT25seSBrZWVwIENTUyBhbmQgb2JqZWN0cywgaW5saW5lIG90aGVyIGFyZ3VtZW50c1xuICAgIHN3aXRjaCAobmV4dENoYXIpIHtcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgY2FzZSAnTyc6XG4gICAgICBjYXNlICdvJzoge1xuICAgICAgICArK2FyZ3VtZW50c1BvaW50ZXI7XG4gICAgICAgIHRlbXBsYXRlICs9IGAlJHtuZXh0Q2hhcn1gO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZCc6XG4gICAgICBjYXNlICdpJzoge1xuICAgICAgICBjb25zdCBbYXJnXSA9IGFyZ3Muc3BsaWNlKGFyZ3VtZW50c1BvaW50ZXIsIDEpO1xuICAgICAgICB0ZW1wbGF0ZSArPSBwYXJzZUludChhcmcsIDEwKS50b1N0cmluZygpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnZic6IHtcbiAgICAgICAgY29uc3QgW2FyZ10gPSBhcmdzLnNwbGljZShhcmd1bWVudHNQb2ludGVyLCAxKTtcbiAgICAgICAgdGVtcGxhdGUgKz0gcGFyc2VGbG9hdChhcmcpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdzJzoge1xuICAgICAgICBjb25zdCBbYXJnXSA9IGFyZ3Muc3BsaWNlKGFyZ3VtZW50c1BvaW50ZXIsIDEpO1xuICAgICAgICB0ZW1wbGF0ZSArPSBhcmcudG9TdHJpbmcoKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGVtcGxhdGUgKz0gYCUke25leHRDaGFyfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFt0ZW1wbGF0ZSwgLi4uYXJnc107XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/utils/formatConsoleArguments.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/utils/formatWithStyles.js":
/*!**********************************************************************!*\
  !*** ../react-devtools-shared/src/backend/utils/formatWithStyles.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ formatWithStyles)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// Do not add / import anything to this file.\n// This function could be used from multiple places, including hook.\n// Formats an array of args with a style for console methods, using\n// the following algorithm:\n//     1. The first param is a string that contains %c\n//          - Bail out and return the args without modifying the styles.\n//            We don't want to affect styles that the developer deliberately set.\n//     2. The first param is a string that doesn't contain %c but contains\n//        string formatting\n//          - [`%c${args[0]}`, style, ...args.slice(1)]\n//          - Note: we assume that the string formatting that the developer uses\n//            is correct.\n//     3. The first param is a string that doesn't contain string formatting\n//        OR is not a string\n//          - Create a formatting string where:\n//                 boolean, string, symbol -> %s\n//                 number -> %f OR %i depending on if it's an int or float\n//                 default -> %o\nfunction formatWithStyles(inputArgs, style) {\n  if (inputArgs === undefined || inputArgs === null || inputArgs.length === 0 || // Matches any of %c but not %%c\n  typeof inputArgs[0] === 'string' && inputArgs[0].match(/([^%]|^)(%c)/g) || style === undefined) {\n    return inputArgs;\n  } // Matches any of %(o|O|d|i|s|f), but not %%(o|O|d|i|s|f)\n\n\n  const REGEXP = /([^%]|^)((%%)*)(%([oOdisf]))/g;\n\n  if (typeof inputArgs[0] === 'string' && inputArgs[0].match(REGEXP)) {\n    return [`%c${inputArgs[0]}`, style, ...inputArgs.slice(1)];\n  } else {\n    const firstArg = inputArgs.reduce((formatStr, elem, i) => {\n      if (i > 0) {\n        formatStr += ' ';\n      }\n\n      switch (typeof elem) {\n        case 'string':\n        case 'boolean':\n        case 'symbol':\n          return formatStr += '%s';\n\n        case 'number':\n          const formatting = Number.isInteger(elem) ? '%i' : '%f';\n          return formatStr += formatting;\n\n        default:\n          return formatStr += '%o';\n      }\n    }, '%c');\n    return [firstArg, style, ...inputArgs];\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2Zvcm1hdFdpdGhTdHlsZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUdBO0FBQ0E7OztBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdXRpbHMvZm9ybWF0V2l0aFN0eWxlcy5qcz85YzBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbi8vIERvIG5vdCBhZGQgLyBpbXBvcnQgYW55dGhpbmcgdG8gdGhpcyBmaWxlLlxuLy8gVGhpcyBmdW5jdGlvbiBjb3VsZCBiZSB1c2VkIGZyb20gbXVsdGlwbGUgcGxhY2VzLCBpbmNsdWRpbmcgaG9vay5cblxuLy8gRm9ybWF0cyBhbiBhcnJheSBvZiBhcmdzIHdpdGggYSBzdHlsZSBmb3IgY29uc29sZSBtZXRob2RzLCB1c2luZ1xuLy8gdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4vLyAgICAgMS4gVGhlIGZpcnN0IHBhcmFtIGlzIGEgc3RyaW5nIHRoYXQgY29udGFpbnMgJWNcbi8vICAgICAgICAgIC0gQmFpbCBvdXQgYW5kIHJldHVybiB0aGUgYXJncyB3aXRob3V0IG1vZGlmeWluZyB0aGUgc3R5bGVzLlxuLy8gICAgICAgICAgICBXZSBkb24ndCB3YW50IHRvIGFmZmVjdCBzdHlsZXMgdGhhdCB0aGUgZGV2ZWxvcGVyIGRlbGliZXJhdGVseSBzZXQuXG4vLyAgICAgMi4gVGhlIGZpcnN0IHBhcmFtIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCBjb250YWluICVjIGJ1dCBjb250YWluc1xuLy8gICAgICAgIHN0cmluZyBmb3JtYXR0aW5nXG4vLyAgICAgICAgICAtIFtgJWMke2FyZ3NbMF19YCwgc3R5bGUsIC4uLmFyZ3Muc2xpY2UoMSldXG4vLyAgICAgICAgICAtIE5vdGU6IHdlIGFzc3VtZSB0aGF0IHRoZSBzdHJpbmcgZm9ybWF0dGluZyB0aGF0IHRoZSBkZXZlbG9wZXIgdXNlc1xuLy8gICAgICAgICAgICBpcyBjb3JyZWN0LlxuLy8gICAgIDMuIFRoZSBmaXJzdCBwYXJhbSBpcyBhIHN0cmluZyB0aGF0IGRvZXNuJ3QgY29udGFpbiBzdHJpbmcgZm9ybWF0dGluZ1xuLy8gICAgICAgIE9SIGlzIG5vdCBhIHN0cmluZ1xuLy8gICAgICAgICAgLSBDcmVhdGUgYSBmb3JtYXR0aW5nIHN0cmluZyB3aGVyZTpcbi8vICAgICAgICAgICAgICAgICBib29sZWFuLCBzdHJpbmcsIHN5bWJvbCAtPiAlc1xuLy8gICAgICAgICAgICAgICAgIG51bWJlciAtPiAlZiBPUiAlaSBkZXBlbmRpbmcgb24gaWYgaXQncyBhbiBpbnQgb3IgZmxvYXRcbi8vICAgICAgICAgICAgICAgICBkZWZhdWx0IC0+ICVvXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRXaXRoU3R5bGVzKFxuICBpbnB1dEFyZ3M6ICRSZWFkT25seUFycmF5PGFueT4sXG4gIHN0eWxlPzogc3RyaW5nLFxuKTogJFJlYWRPbmx5QXJyYXk8YW55PiB7XG4gIGlmIChcbiAgICBpbnB1dEFyZ3MgPT09IHVuZGVmaW5lZCB8fFxuICAgIGlucHV0QXJncyA9PT0gbnVsbCB8fFxuICAgIGlucHV0QXJncy5sZW5ndGggPT09IDAgfHxcbiAgICAvLyBNYXRjaGVzIGFueSBvZiAlYyBidXQgbm90ICUlY1xuICAgICh0eXBlb2YgaW5wdXRBcmdzWzBdID09PSAnc3RyaW5nJyAmJiBpbnB1dEFyZ3NbMF0ubWF0Y2goLyhbXiVdfF4pKCVjKS9nKSkgfHxcbiAgICBzdHlsZSA9PT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiBpbnB1dEFyZ3M7XG4gIH1cblxuICAvLyBNYXRjaGVzIGFueSBvZiAlKG98T3xkfGl8c3xmKSwgYnV0IG5vdCAlJShvfE98ZHxpfHN8ZilcbiAgY29uc3QgUkVHRVhQID0gLyhbXiVdfF4pKCglJSkqKSglKFtvT2Rpc2ZdKSkvZztcbiAgaWYgKHR5cGVvZiBpbnB1dEFyZ3NbMF0gPT09ICdzdHJpbmcnICYmIGlucHV0QXJnc1swXS5tYXRjaChSRUdFWFApKSB7XG4gICAgcmV0dXJuIFtgJWMke2lucHV0QXJnc1swXX1gLCBzdHlsZSwgLi4uaW5wdXRBcmdzLnNsaWNlKDEpXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmaXJzdEFyZyA9IGlucHV0QXJncy5yZWR1Y2UoKGZvcm1hdFN0ciwgZWxlbSwgaSkgPT4ge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGZvcm1hdFN0ciArPSAnICc7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBlbGVtKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgIHJldHVybiAoZm9ybWF0U3RyICs9ICclcycpO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIGNvbnN0IGZvcm1hdHRpbmcgPSBOdW1iZXIuaXNJbnRlZ2VyKGVsZW0pID8gJyVpJyA6ICclZic7XG4gICAgICAgICAgcmV0dXJuIChmb3JtYXRTdHIgKz0gZm9ybWF0dGluZyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIChmb3JtYXRTdHIgKz0gJyVvJyk7XG4gICAgICB9XG4gICAgfSwgJyVjJyk7XG4gICAgcmV0dXJuIFtmaXJzdEFyZywgc3R5bGUsIC4uLmlucHV0QXJnc107XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/utils/formatWithStyles.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/backend/utils/index.js":
/*!***********************************************************!*\
  !*** ../react-devtools-shared/src/backend/utils/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cleanForBridge\": () => (/* binding */ cleanForBridge),\n/* harmony export */   \"copyWithDelete\": () => (/* binding */ copyWithDelete),\n/* harmony export */   \"copyWithRename\": () => (/* binding */ copyWithRename),\n/* harmony export */   \"copyWithSet\": () => (/* binding */ copyWithSet),\n/* harmony export */   \"formatConsoleArguments\": () => (/* reexport safe */ _formatConsoleArguments__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"formatConsoleArgumentsToSingleString\": () => (/* binding */ formatConsoleArgumentsToSingleString),\n/* harmony export */   \"formatDurationToMicrosecondsGranularity\": () => (/* binding */ formatDurationToMicrosecondsGranularity),\n/* harmony export */   \"formatWithStyles\": () => (/* reexport safe */ _formatWithStyles__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   \"getEffectDurations\": () => (/* binding */ getEffectDurations),\n/* harmony export */   \"gt\": () => (/* binding */ gt),\n/* harmony export */   \"gte\": () => (/* binding */ gte),\n/* harmony export */   \"hasAssignedBackend\": () => (/* binding */ hasAssignedBackend),\n/* harmony export */   \"isReactNativeEnvironment\": () => (/* binding */ isReactNativeEnvironment),\n/* harmony export */   \"isSynchronousXHRSupported\": () => (/* binding */ isSynchronousXHRSupported),\n/* harmony export */   \"parseSourceFromComponentStack\": () => (/* binding */ parseSourceFromComponentStack),\n/* harmony export */   \"serializeToString\": () => (/* binding */ serializeToString)\n/* harmony export */ });\n/* harmony import */ var compare_versions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! compare-versions */ \"../../node_modules/compare-versions/lib/esm/index.js\");\n/* harmony import */ var react_devtools_shared_src_hydration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/hydration */ \"../react-devtools-shared/src/hydration.js\");\n/* harmony import */ var shared_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/isArray */ \"../shared/isArray.js\");\n/* harmony import */ var _formatWithStyles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatWithStyles */ \"../react-devtools-shared/src/backend/utils/formatWithStyles.js\");\n/* harmony import */ var _formatConsoleArguments__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatConsoleArguments */ \"../react-devtools-shared/src/backend/utils/formatConsoleArguments.js\");\n/**\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n // TODO: update this to the first React version that has a corresponding DevTools backend\n\nconst FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER = '999.9.9';\nfunction hasAssignedBackend(version) {\n  if (version == null || version === '') {\n    return false;\n  }\n\n  return gte(version, FIRST_DEVTOOLS_BACKEND_LOCKSTEP_VER);\n}\nfunction cleanForBridge(data, isPathAllowed, path = []) {\n  if (data !== null) {\n    const cleanedPaths = [];\n    const unserializablePaths = [];\n    const cleanedData = (0,react_devtools_shared_src_hydration__WEBPACK_IMPORTED_MODULE_0__.dehydrate)(data, cleanedPaths, unserializablePaths, path, isPathAllowed);\n    return {\n      data: cleanedData,\n      cleaned: cleanedPaths,\n      unserializable: unserializablePaths\n    };\n  } else {\n    return null;\n  }\n}\nfunction copyWithDelete(obj, path, index = 0) {\n  const key = path[index];\n  const updated = (0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(obj) ? obj.slice() : { ...obj\n  };\n\n  if (index + 1 === path.length) {\n    if ((0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(updated)) {\n      updated.splice(key, 1);\n    } else {\n      delete updated[key];\n    }\n  } else {\n    // $FlowFixMe[incompatible-use] number or string is fine here\n    updated[key] = copyWithDelete(obj[key], path, index + 1);\n  }\n\n  return updated;\n} // This function expects paths to be the same except for the final value.\n// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']\n\nfunction copyWithRename(obj, oldPath, newPath, index = 0) {\n  const oldKey = oldPath[index];\n  const updated = (0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(obj) ? obj.slice() : { ...obj\n  };\n\n  if (index + 1 === oldPath.length) {\n    const newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here\n\n    updated[newKey] = updated[oldKey];\n\n    if ((0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(updated)) {\n      updated.splice(oldKey, 1);\n    } else {\n      delete updated[oldKey];\n    }\n  } else {\n    // $FlowFixMe[incompatible-use] number or string is fine here\n    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);\n  }\n\n  return updated;\n}\nfunction copyWithSet(obj, path, value, index = 0) {\n  if (index >= path.length) {\n    return value;\n  }\n\n  const key = path[index];\n  const updated = (0,shared_isArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(obj) ? obj.slice() : { ...obj\n  }; // $FlowFixMe[incompatible-use] number or string is fine here\n\n  updated[key] = copyWithSet(obj[key], path, value, index + 1);\n  return updated;\n}\nfunction getEffectDurations(root) {\n  // Profiling durations are only available for certain builds.\n  // If available, they'll be stored on the HostRoot.\n  let effectDuration = null;\n  let passiveEffectDuration = null;\n  const hostRoot = root.current;\n\n  if (hostRoot != null) {\n    const stateNode = hostRoot.stateNode;\n\n    if (stateNode != null) {\n      effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;\n      passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;\n    }\n  }\n\n  return {\n    effectDuration,\n    passiveEffectDuration\n  };\n}\nfunction serializeToString(data) {\n  if (data === undefined) {\n    return 'undefined';\n  }\n\n  if (typeof data === 'function') {\n    return data.toString();\n  }\n\n  const cache = new Set(); // Use a custom replacer function to protect against circular references.\n\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.has(value)) {\n        return;\n      }\n\n      cache.add(value);\n    }\n\n    if (typeof value === 'bigint') {\n      return value.toString() + 'n';\n    }\n\n    return value;\n  }, 2);\n}\n\nfunction safeToString(val) {\n  try {\n    return String(val);\n  } catch (err) {\n    if (typeof val === 'object') {\n      // An object with no prototype and no `[Symbol.toPrimitive]()`, `toString()`, and `valueOf()` methods would throw.\n      // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_coercion\n      return '[object Object]';\n    }\n\n    throw err;\n  }\n} // based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1\n// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions\n// Implements s, d, i and f placeholders\n\n\nfunction formatConsoleArgumentsToSingleString(maybeMessage, ...inputArgs) {\n  const args = inputArgs.slice();\n  let formatted = safeToString(maybeMessage); // If the first argument is a string, check for substitutions.\n\n  if (typeof maybeMessage === 'string') {\n    if (args.length) {\n      const REGEXP = /(%?)(%([jds]))/g; // $FlowFixMe[incompatible-call]\n\n      formatted = formatted.replace(REGEXP, (match, escaped, ptn, flag) => {\n        let arg = args.shift();\n\n        switch (flag) {\n          case 's':\n            // $FlowFixMe[unsafe-addition]\n            arg += '';\n            break;\n\n          case 'd':\n          case 'i':\n            arg = parseInt(arg, 10).toString();\n            break;\n\n          case 'f':\n            arg = parseFloat(arg).toString();\n            break;\n        }\n\n        if (!escaped) {\n          return arg;\n        }\n\n        args.unshift(arg);\n        return match;\n      });\n    }\n  } // Arguments that remain after formatting.\n\n\n  if (args.length) {\n    for (let i = 0; i < args.length; i++) {\n      formatted += ' ' + safeToString(args[i]);\n    }\n  } // Update escaped %% values.\n\n\n  formatted = formatted.replace(/%{2,2}/g, '%');\n  return String(formatted);\n}\nfunction isSynchronousXHRSupported() {\n  return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature('sync-xhr'));\n}\nfunction gt(a = '', b = '') {\n  return (0,compare_versions__WEBPACK_IMPORTED_MODULE_4__.compareVersions)(a, b) === 1;\n}\nfunction gte(a = '', b = '') {\n  return (0,compare_versions__WEBPACK_IMPORTED_MODULE_4__.compareVersions)(a, b) > -1;\n}\nconst isReactNativeEnvironment = () => {\n  // We've been relying on this for such a long time\n  // We should probably define the client for DevTools on the backend side and share it with the frontend\n  return window.document == null;\n};\n\nfunction extractLocation(url) {\n  if (url.indexOf(':') === -1) {\n    return null;\n  } // remove any parentheses from start and end\n\n\n  const withoutParentheses = url.replace(/^\\(+/, '').replace(/\\)+$/, '');\n  const locationParts = /(at )?(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(withoutParentheses);\n\n  if (locationParts == null) {\n    return null;\n  }\n\n  const [,, sourceURL, line, column] = locationParts;\n  return {\n    sourceURL,\n    line,\n    column\n  };\n}\n\nconst CHROME_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n\nfunction parseSourceFromChromeStack(stack) {\n  const frames = stack.split('\\n'); // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n  for (const frame of frames) {\n    const sanitizedFrame = frame.trim();\n    const locationInParenthesesMatch = sanitizedFrame.match(/ (\\(.+\\)$)/);\n    const possibleLocation = locationInParenthesesMatch ? locationInParenthesesMatch[1] : sanitizedFrame;\n    const location = extractLocation(possibleLocation); // Continue the search until at least sourceURL is found\n\n    if (location == null) {\n      continue;\n    }\n\n    const {\n      sourceURL,\n      line = '1',\n      column = '1'\n    } = location;\n    return {\n      sourceURL,\n      line: parseInt(line, 10),\n      column: parseInt(column, 10)\n    };\n  }\n\n  return null;\n}\n\nfunction parseSourceFromFirefoxStack(stack) {\n  const frames = stack.split('\\n'); // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n  for (const frame of frames) {\n    const sanitizedFrame = frame.trim();\n    const frameWithoutFunctionName = sanitizedFrame.replace(/((.*\".+\"[^@]*)?[^@]*)(?:@)/, '');\n    const location = extractLocation(frameWithoutFunctionName); // Continue the search until at least sourceURL is found\n\n    if (location == null) {\n      continue;\n    }\n\n    const {\n      sourceURL,\n      line = '1',\n      column = '1'\n    } = location;\n    return {\n      sourceURL,\n      line: parseInt(line, 10),\n      column: parseInt(column, 10)\n    };\n  }\n\n  return null;\n}\n\nfunction parseSourceFromComponentStack(componentStack) {\n  if (componentStack.match(CHROME_STACK_REGEXP)) {\n    return parseSourceFromChromeStack(componentStack);\n  }\n\n  return parseSourceFromFirefoxStack(componentStack);\n} // 0.123456789 => 0.123\n// Expects high-resolution timestamp in milliseconds, like from performance.now()\n// Mainly used for optimizing the size of serialized profiling payload\n\nfunction formatDurationToMicrosecondsGranularity(duration) {\n  return Math.round(duration * 1000) / 1000;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFLQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFNQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBSUE7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQVhBOztBQWFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUVBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdXRpbHMvaW5kZXguanM/ZDcxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7Y29tcGFyZVZlcnNpb25zfSBmcm9tICdjb21wYXJlLXZlcnNpb25zJztcbmltcG9ydCB7ZGVoeWRyYXRlfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2h5ZHJhdGlvbic7XG5pbXBvcnQgaXNBcnJheSBmcm9tICdzaGFyZWQvaXNBcnJheSc7XG5cbmltcG9ydCB0eXBlIHtTb3VyY2V9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvc2hhcmVkL3R5cGVzJztcbmltcG9ydCB0eXBlIHtEZWh5ZHJhdGVkRGF0YX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBmb3JtYXRXaXRoU3R5bGVzfSBmcm9tICcuL2Zvcm1hdFdpdGhTdHlsZXMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGZvcm1hdENvbnNvbGVBcmd1bWVudHN9IGZyb20gJy4vZm9ybWF0Q29uc29sZUFyZ3VtZW50cyc7XG5cbi8vIFRPRE86IHVwZGF0ZSB0aGlzIHRvIHRoZSBmaXJzdCBSZWFjdCB2ZXJzaW9uIHRoYXQgaGFzIGEgY29ycmVzcG9uZGluZyBEZXZUb29scyBiYWNrZW5kXG5jb25zdCBGSVJTVF9ERVZUT09MU19CQUNLRU5EX0xPQ0tTVEVQX1ZFUiA9ICc5OTkuOS45JztcbmV4cG9ydCBmdW5jdGlvbiBoYXNBc3NpZ25lZEJhY2tlbmQodmVyc2lvbj86IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodmVyc2lvbiA9PSBudWxsIHx8IHZlcnNpb24gPT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBndGUodmVyc2lvbiwgRklSU1RfREVWVE9PTFNfQkFDS0VORF9MT0NLU1RFUF9WRVIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5Gb3JCcmlkZ2UoXG4gIGRhdGE6IE9iamVjdCB8IG51bGwsXG4gIGlzUGF0aEFsbG93ZWQ6IChwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+KSA9PiBib29sZWFuLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+ID0gW10sXG4pOiBEZWh5ZHJhdGVkRGF0YSB8IG51bGwge1xuICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGNsZWFuZWRQYXRoczogQXJyYXk8QXJyYXk8c3RyaW5nIHwgbnVtYmVyPj4gPSBbXTtcbiAgICBjb25zdCB1bnNlcmlhbGl6YWJsZVBhdGhzOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PiA9IFtdO1xuICAgIGNvbnN0IGNsZWFuZWREYXRhID0gZGVoeWRyYXRlKFxuICAgICAgZGF0YSxcbiAgICAgIGNsZWFuZWRQYXRocyxcbiAgICAgIHVuc2VyaWFsaXphYmxlUGF0aHMsXG4gICAgICBwYXRoLFxuICAgICAgaXNQYXRoQWxsb3dlZCxcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGNsZWFuZWREYXRhLFxuICAgICAgY2xlYW5lZDogY2xlYW5lZFBhdGhzLFxuICAgICAgdW5zZXJpYWxpemFibGU6IHVuc2VyaWFsaXphYmxlUGF0aHMsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weVdpdGhEZWxldGUoXG4gIG9iajogT2JqZWN0IHwgQXJyYXk8YW55PixcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgaW5kZXg6IG51bWJlciA9IDAsXG4pOiBPYmplY3QgfCBBcnJheTxhbnk+IHtcbiAgY29uc3Qga2V5ID0gcGF0aFtpbmRleF07XG4gIGNvbnN0IHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IHsuLi5vYmp9O1xuICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICB1cGRhdGVkLnNwbGljZSgoKGtleTogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZShvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGZpbmFsIHZhbHVlLlxuLy8gZS5nLiBbJ3BhdGgnLCAndG8nLCAnZm9vJ10gYW5kIFsncGF0aCcsICd0bycsICdiYXInXVxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lKFxuICBvYmo6IE9iamVjdCB8IEFycmF5PGFueT4sXG4gIG9sZFBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIG5ld1BhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIGluZGV4OiBudW1iZXIgPSAwLFxuKTogT2JqZWN0IHwgQXJyYXk8YW55PiB7XG4gIGNvbnN0IG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdO1xuICBjb25zdCB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiB7Li4ub2JqfTtcbiAgaWYgKGluZGV4ICsgMSA9PT0gb2xkUGF0aC5sZW5ndGgpIHtcbiAgICBjb25zdCBuZXdLZXkgPSBuZXdQYXRoW2luZGV4XTtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgdXBkYXRlZFtuZXdLZXldID0gdXBkYXRlZFtvbGRLZXldO1xuICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICB1cGRhdGVkLnNwbGljZSgoKG9sZEtleTogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZShvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlXaXRoU2V0KFxuICBvYmo6IE9iamVjdCB8IEFycmF5PGFueT4sXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG4gIHZhbHVlOiBhbnksXG4gIGluZGV4OiBudW1iZXIgPSAwLFxuKTogT2JqZWN0IHwgQXJyYXk8YW55PiB7XG4gIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25zdCBrZXkgPSBwYXRoW2luZGV4XTtcbiAgY29uc3QgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogey4uLm9ian07XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXQob2JqW2tleV0sIHBhdGgsIHZhbHVlLCBpbmRleCArIDEpO1xuICByZXR1cm4gdXBkYXRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVmZmVjdER1cmF0aW9ucyhyb290OiBPYmplY3QpOiB7XG4gIGVmZmVjdER1cmF0aW9uOiBhbnkgfCBudWxsLFxuICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IGFueSB8IG51bGwsXG59IHtcbiAgLy8gUHJvZmlsaW5nIGR1cmF0aW9ucyBhcmUgb25seSBhdmFpbGFibGUgZm9yIGNlcnRhaW4gYnVpbGRzLlxuICAvLyBJZiBhdmFpbGFibGUsIHRoZXknbGwgYmUgc3RvcmVkIG9uIHRoZSBIb3N0Um9vdC5cbiAgbGV0IGVmZmVjdER1cmF0aW9uID0gbnVsbDtcbiAgbGV0IHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IG51bGw7XG4gIGNvbnN0IGhvc3RSb290ID0gcm9vdC5jdXJyZW50O1xuICBpZiAoaG9zdFJvb3QgIT0gbnVsbCkge1xuICAgIGNvbnN0IHN0YXRlTm9kZSA9IGhvc3RSb290LnN0YXRlTm9kZTtcbiAgICBpZiAoc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgIGVmZmVjdER1cmF0aW9uID1cbiAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICE9IG51bGwgPyBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gOiBudWxsO1xuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID1cbiAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiAhPSBudWxsXG4gICAgICAgICAgPyBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2VmZmVjdER1cmF0aW9uLCBwYXNzaXZlRWZmZWN0RHVyYXRpb259O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplVG9TdHJpbmcoZGF0YTogYW55KTogc3RyaW5nIHtcbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gIH1cblxuICBjb25zdCBjYWNoZSA9IG5ldyBTZXQ8bWl4ZWQ+KCk7XG4gIC8vIFVzZSBhIGN1c3RvbSByZXBsYWNlciBmdW5jdGlvbiB0byBwcm90ZWN0IGFnYWluc3QgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIGRhdGEsXG4gICAgKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FjaGUuaGFzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZS5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyAnbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICAyLFxuICApO1xufVxuXG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcodmFsOiBhbnkpOiBzdHJpbmcge1xuICB0cnkge1xuICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBBbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUgYW5kIG5vIGBbU3ltYm9sLnRvUHJpbWl0aXZlXSgpYCwgYHRvU3RyaW5nKClgLCBhbmQgYHZhbHVlT2YoKWAgbWV0aG9kcyB3b3VsZCB0aHJvdy5cbiAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcjc3RyaW5nX2NvZXJjaW9uXG4gICAgICByZXR1cm4gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdG1wZnMvZm9ybWF0LXV0aWwvYmxvYi8wZTYyZDQzMGVmYjBhMWM1MTQ0ODcwOWFiZDNlMjQwNmMxNGQ4NDAxL2Zvcm1hdC5qcyNMMVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2NvbnNvbGUjVXNpbmdfc3RyaW5nX3N1YnN0aXR1dGlvbnNcbi8vIEltcGxlbWVudHMgcywgZCwgaSBhbmQgZiBwbGFjZWhvbGRlcnNcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRDb25zb2xlQXJndW1lbnRzVG9TaW5nbGVTdHJpbmcoXG4gIG1heWJlTWVzc2FnZTogYW55LFxuICAuLi5pbnB1dEFyZ3M6ICRSZWFkT25seUFycmF5PGFueT5cbik6IHN0cmluZyB7XG4gIGNvbnN0IGFyZ3MgPSBpbnB1dEFyZ3Muc2xpY2UoKTtcblxuICBsZXQgZm9ybWF0dGVkOiBzdHJpbmcgPSBzYWZlVG9TdHJpbmcobWF5YmVNZXNzYWdlKTtcblxuICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIGNoZWNrIGZvciBzdWJzdGl0dXRpb25zLlxuICBpZiAodHlwZW9mIG1heWJlTWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFJFR0VYUCA9IC8oJT8pKCUoW2pkc10pKS9nO1xuXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoUkVHRVhQLCAobWF0Y2gsIGVzY2FwZWQsIHB0biwgZmxhZykgPT4ge1xuICAgICAgICBsZXQgYXJnID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXVxuICAgICAgICAgICAgYXJnICs9ICcnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZUludChhcmcsIDEwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZUZsb2F0KGFyZykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy51bnNoaWZ0KGFyZyk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFyZ3VtZW50cyB0aGF0IHJlbWFpbiBhZnRlciBmb3JtYXR0aW5nLlxuICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvcm1hdHRlZCArPSAnICcgKyBzYWZlVG9TdHJpbmcoYXJnc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIGVzY2FwZWQgJSUgdmFsdWVzLlxuICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZSgvJXsyLDJ9L2csICclJyk7XG5cbiAgcmV0dXJuIFN0cmluZyhmb3JtYXR0ZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTeW5jaHJvbm91c1hIUlN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhKFxuICAgIHdpbmRvdy5kb2N1bWVudCAmJlxuICAgIHdpbmRvdy5kb2N1bWVudC5mZWF0dXJlUG9saWN5ICYmXG4gICAgd2luZG93LmRvY3VtZW50LmZlYXR1cmVQb2xpY3kuYWxsb3dzRmVhdHVyZSgnc3luYy14aHInKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3QoYTogc3RyaW5nID0gJycsIGI6IHN0cmluZyA9ICcnKTogYm9vbGVhbiB7XG4gIHJldHVybiBjb21wYXJlVmVyc2lvbnMoYSwgYikgPT09IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBndGUoYTogc3RyaW5nID0gJycsIGI6IHN0cmluZyA9ICcnKTogYm9vbGVhbiB7XG4gIHJldHVybiBjb21wYXJlVmVyc2lvbnMoYSwgYikgPiAtMTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzUmVhY3ROYXRpdmVFbnZpcm9ubWVudCA9ICgpOiBib29sZWFuID0+IHtcbiAgLy8gV2UndmUgYmVlbiByZWx5aW5nIG9uIHRoaXMgZm9yIHN1Y2ggYSBsb25nIHRpbWVcbiAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRlZmluZSB0aGUgY2xpZW50IGZvciBEZXZUb29scyBvbiB0aGUgYmFja2VuZCBzaWRlIGFuZCBzaGFyZSBpdCB3aXRoIHRoZSBmcm9udGVuZFxuICByZXR1cm4gd2luZG93LmRvY3VtZW50ID09IG51bGw7XG59O1xuXG5mdW5jdGlvbiBleHRyYWN0TG9jYXRpb24oXG4gIHVybDogc3RyaW5nLFxuKTogbnVsbCB8IHtzb3VyY2VVUkw6IHN0cmluZywgbGluZT86IHN0cmluZywgY29sdW1uPzogc3RyaW5nfSB7XG4gIGlmICh1cmwuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFueSBwYXJlbnRoZXNlcyBmcm9tIHN0YXJ0IGFuZCBlbmRcbiAgY29uc3Qgd2l0aG91dFBhcmVudGhlc2VzID0gdXJsLnJlcGxhY2UoL15cXCgrLywgJycpLnJlcGxhY2UoL1xcKSskLywgJycpO1xuICBjb25zdCBsb2NhdGlvblBhcnRzID0gLyhhdCApPyguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC8uZXhlYyhcbiAgICB3aXRob3V0UGFyZW50aGVzZXMsXG4gICk7XG5cbiAgaWYgKGxvY2F0aW9uUGFydHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgWywgLCBzb3VyY2VVUkwsIGxpbmUsIGNvbHVtbl0gPSBsb2NhdGlvblBhcnRzO1xuICByZXR1cm4ge3NvdXJjZVVSTCwgbGluZSwgY29sdW1ufTtcbn1cblxuY29uc3QgQ0hST01FX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL207XG5mdW5jdGlvbiBwYXJzZVNvdXJjZUZyb21DaHJvbWVTdGFjayhzdGFjazogc3RyaW5nKTogU291cmNlIHwgbnVsbCB7XG4gIGNvbnN0IGZyYW1lcyA9IHN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcbiAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWRGcmFtZSA9IGZyYW1lLnRyaW0oKTtcblxuICAgIGNvbnN0IGxvY2F0aW9uSW5QYXJlbnRoZXNlc01hdGNoID0gc2FuaXRpemVkRnJhbWUubWF0Y2goLyAoXFwoLitcXCkkKS8pO1xuICAgIGNvbnN0IHBvc3NpYmxlTG9jYXRpb24gPSBsb2NhdGlvbkluUGFyZW50aGVzZXNNYXRjaFxuICAgICAgPyBsb2NhdGlvbkluUGFyZW50aGVzZXNNYXRjaFsxXVxuICAgICAgOiBzYW5pdGl6ZWRGcmFtZTtcblxuICAgIGNvbnN0IGxvY2F0aW9uID0gZXh0cmFjdExvY2F0aW9uKHBvc3NpYmxlTG9jYXRpb24pO1xuICAgIC8vIENvbnRpbnVlIHRoZSBzZWFyY2ggdW50aWwgYXQgbGVhc3Qgc291cmNlVVJMIGlzIGZvdW5kXG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHtzb3VyY2VVUkwsIGxpbmUgPSAnMScsIGNvbHVtbiA9ICcxJ30gPSBsb2NhdGlvbjtcblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2VVUkwsXG4gICAgICBsaW5lOiBwYXJzZUludChsaW5lLCAxMCksXG4gICAgICBjb2x1bW46IHBhcnNlSW50KGNvbHVtbiwgMTApLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VTb3VyY2VGcm9tRmlyZWZveFN0YWNrKHN0YWNrOiBzdHJpbmcpOiBTb3VyY2UgfCBudWxsIHtcbiAgY29uc3QgZnJhbWVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICBmb3IgKGNvbnN0IGZyYW1lIG9mIGZyYW1lcykge1xuICAgIGNvbnN0IHNhbml0aXplZEZyYW1lID0gZnJhbWUudHJpbSgpO1xuICAgIGNvbnN0IGZyYW1lV2l0aG91dEZ1bmN0aW9uTmFtZSA9IHNhbml0aXplZEZyYW1lLnJlcGxhY2UoXG4gICAgICAvKCguKlwiLitcIlteQF0qKT9bXkBdKikoPzpAKS8sXG4gICAgICAnJyxcbiAgICApO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPSBleHRyYWN0TG9jYXRpb24oZnJhbWVXaXRob3V0RnVuY3Rpb25OYW1lKTtcbiAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIHVudGlsIGF0IGxlYXN0IHNvdXJjZVVSTCBpcyBmb3VuZFxuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7c291cmNlVVJMLCBsaW5lID0gJzEnLCBjb2x1bW4gPSAnMSd9ID0gbG9jYXRpb247XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlVVJMLFxuICAgICAgbGluZTogcGFyc2VJbnQobGluZSwgMTApLFxuICAgICAgY29sdW1uOiBwYXJzZUludChjb2x1bW4sIDEwKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNvdXJjZUZyb21Db21wb25lbnRTdGFjayhcbiAgY29tcG9uZW50U3RhY2s6IHN0cmluZyxcbik6IFNvdXJjZSB8IG51bGwge1xuICBpZiAoY29tcG9uZW50U3RhY2subWF0Y2goQ0hST01FX1NUQUNLX1JFR0VYUCkpIHtcbiAgICByZXR1cm4gcGFyc2VTb3VyY2VGcm9tQ2hyb21lU3RhY2soY29tcG9uZW50U3RhY2spO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlU291cmNlRnJvbUZpcmVmb3hTdGFjayhjb21wb25lbnRTdGFjayk7XG59XG5cbi8vIDAuMTIzNDU2Nzg5ID0+IDAuMTIzXG4vLyBFeHBlY3RzIGhpZ2gtcmVzb2x1dGlvbiB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzLCBsaWtlIGZyb20gcGVyZm9ybWFuY2Uubm93KClcbi8vIE1haW5seSB1c2VkIGZvciBvcHRpbWl6aW5nIHRoZSBzaXplIG9mIHNlcmlhbGl6ZWQgcHJvZmlsaW5nIHBheWxvYWRcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREdXJhdGlvblRvTWljcm9zZWNvbmRzR3JhbnVsYXJpdHkoXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4pOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5yb3VuZChkdXJhdGlvbiAqIDEwMDApIC8gMTAwMDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/backend/utils/index.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/bridge.js":
/*!**********************************************!*\
  !*** ../react-devtools-shared/src/bridge.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BRIDGE_PROTOCOL\": () => (/* binding */ BRIDGE_PROTOCOL),\n/* harmony export */   \"currentBridgeProtocol\": () => (/* binding */ currentBridgeProtocol),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ \"../react-devtools-shared/src/events.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n// Bump protocol version whenever a backwards breaking change is made\n// in the messages sent between BackendBridge and FrontendBridge.\n// This mapping is embedded in both frontend and backend builds.\n//\n// The backend protocol will always be the latest entry in the BRIDGE_PROTOCOL array.\n//\n// When an older frontend connects to a newer backend,\n// the backend can send the minNpmVersion and the frontend can display an NPM upgrade prompt.\n//\n// When a newer frontend connects with an older protocol version,\n// the frontend can use the embedded minNpmVersion/maxNpmVersion values to display a downgrade prompt.\nconst BRIDGE_PROTOCOL = [// This version technically never existed,\n// but a backwards breaking change was added in 4.11,\n// so the safest guess to downgrade the frontend would be to version 4.10.\n{\n  version: 0,\n  minNpmVersion: '\"<4.11.0\"',\n  maxNpmVersion: '\"<4.11.0\"'\n}, // Versions 4.11.x  4.12.x contained the backwards breaking change,\n// but we didn't add the \"fix\" of checking the protocol version until 4.13,\n// so we don't recommend downgrading to 4.11 or 4.12.\n{\n  version: 1,\n  minNpmVersion: '4.13.0',\n  maxNpmVersion: '4.21.0'\n}, // Version 2 adds a StrictMode-enabled and supports-StrictMode bits to add-root operation.\n{\n  version: 2,\n  minNpmVersion: '4.22.0',\n  maxNpmVersion: null\n}];\nconst currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];\n\nclass Bridge extends _events__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(wall) {\n    super();\n\n    _defineProperty(this, \"_isShutdown\", false);\n\n    _defineProperty(this, \"_messageQueue\", []);\n\n    _defineProperty(this, \"_scheduledFlush\", false);\n\n    _defineProperty(this, \"_wallUnlisten\", null);\n\n    _defineProperty(this, \"_flush\", () => {\n      // This method is used after the bridge is marked as destroyed in shutdown sequence,\n      // so we do not bail out if the bridge marked as destroyed.\n      // It is a private method that the bridge ensures is only called at the right times.\n      try {\n        if (this._messageQueue.length) {\n          for (let i = 0; i < this._messageQueue.length; i += 2) {\n            this._wall.send(this._messageQueue[i], ...this._messageQueue[i + 1]);\n          }\n\n          this._messageQueue.length = 0;\n        }\n      } finally {\n        // We set this at the end in case new messages are added synchronously above.\n        // They're already handled so they shouldn't queue more flushes.\n        this._scheduledFlush = false;\n      }\n    });\n\n    _defineProperty(this, \"overrideValueAtPath\", ({\n      id,\n      path,\n      rendererID,\n      type,\n      value\n    }) => {\n      switch (type) {\n        case 'context':\n          this.send('overrideContext', {\n            id,\n            path,\n            rendererID,\n            wasForwarded: true,\n            value\n          });\n          break;\n\n        case 'hooks':\n          this.send('overrideHookState', {\n            id,\n            path,\n            rendererID,\n            wasForwarded: true,\n            value\n          });\n          break;\n\n        case 'props':\n          this.send('overrideProps', {\n            id,\n            path,\n            rendererID,\n            wasForwarded: true,\n            value\n          });\n          break;\n\n        case 'state':\n          this.send('overrideState', {\n            id,\n            path,\n            rendererID,\n            wasForwarded: true,\n            value\n          });\n          break;\n      }\n    });\n\n    this._wall = wall;\n    this._wallUnlisten = wall.listen(message => {\n      if (message && message.event) {\n        this.emit(message.event, message.payload);\n      }\n    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.\n    // We do this because React Native embeds the React DevTools backend,\n    // but cannot control which version of the frontend users use.\n\n    this.addListener('overrideValueAtPath', this.overrideValueAtPath);\n  } // Listening directly to the wall isn't advised.\n  // It can be used to listen for legacy (v3) messages (since they use a different format).\n\n\n  get wall() {\n    return this._wall;\n  }\n\n  send(event, ...payload) {\n    if (this._isShutdown) {\n      console.warn(`Cannot send message \"${event}\" through a Bridge that has been shutdown.`);\n      return;\n    } // When we receive a message:\n    // - we add it to our queue of messages to be sent\n    // - if there hasn't been a message recently, we set a timer for 0 ms in\n    //   the future, allowing all messages created in the same tick to be sent\n    //   together\n    // - if there *has* been a message flushed in the last BATCH_DURATION ms\n    //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will\n    //   be set, and we'll simply add to the queue and wait for that\n\n\n    this._messageQueue.push(event, payload);\n\n    if (!this._scheduledFlush) {\n      this._scheduledFlush = true; // $FlowFixMe\n\n      if (typeof devtoolsJestTestScheduler === 'function') {\n        // This exists just for our own jest tests.\n        // They're written in such a way that we can neither mock queueMicrotask\n        // because then we break React DOM and we can't not mock it because then\n        // we can't synchronously flush it. So they need to be rewritten.\n        // $FlowFixMe\n        devtoolsJestTestScheduler(this._flush); // eslint-disable-line no-undef\n      } else {\n        queueMicrotask(this._flush);\n      }\n    }\n  }\n\n  shutdown() {\n    if (this._isShutdown) {\n      console.warn('Bridge was already shutdown.');\n      return;\n    } // Queue the shutdown outgoing message for subscribers.\n\n\n    this.emit('shutdown');\n    this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.\n\n    this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.\n    // $FlowFixMe[cannot-write] This property is not writable.\n\n    this.addListener = function () {}; // $FlowFixMe[cannot-write] This property is not writable.\n\n\n    this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.\n    // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.\n\n\n    this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.\n\n    const wallUnlisten = this._wallUnlisten;\n\n    if (wallUnlisten) {\n      wallUnlisten();\n    } // Synchronously flush all queued outgoing messages.\n    // At this step the subscribers' code may run in this call stack.\n\n\n    do {\n      this._flush();\n    } while (this._messageQueue.length);\n  }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Bridge);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9icmlkZ2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFPQTs7QUEyTUE7QUFhQTtBQUNBOztBQURBOztBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBaUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoSEE7QUFxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFwQ0E7QUFzQ0E7O0FBOUpBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUdBO0FBR0E7O0FBQ0E7OztBQUVBO0FBR0E7OztBQUNBOztBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyR0E7O0FBOEtBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JyaWRnZS5qcz8xNzkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi9ldmVudHMnO1xuXG5pbXBvcnQgdHlwZSB7Q29tcG9uZW50RmlsdGVyLCBXYWxsfSBmcm9tICcuL2Zyb250ZW5kL3R5cGVzJztcbmltcG9ydCB0eXBlIHtcbiAgSW5zcGVjdGVkRWxlbWVudFBheWxvYWQsXG4gIE93bmVyc0xpc3QsXG4gIFByb2ZpbGluZ0RhdGFCYWNrZW5kLFxuICBSZW5kZXJlcklELFxuICBEZXZUb29sc0hvb2tTZXR0aW5ncyxcbiAgUHJvZmlsaW5nU2V0dGluZ3MsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7U3R5bGVBbmRMYXlvdXQgYXMgU3R5bGVBbmRMYXlvdXRQYXlsb2FkfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvTmF0aXZlU3R5bGVFZGl0b3IvdHlwZXMnO1xuXG4vLyBUaGlzIG1lc3NhZ2Ugc3BlY2lmaWVzIHRoZSB2ZXJzaW9uIG9mIHRoZSBEZXZUb29scyBwcm90b2NvbCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSBiYWNrZW5kLFxuLy8gYXMgd2VsbCBhcyB0aGUgZWFybGllc3QgTlBNIHZlcnNpb24gKGUuZy4gXCI0LjEzLjBcIikgdGhhdCBwcm90b2NvbCBpcyBzdXBwb3J0ZWQgYnkgb24gdGhlIGZyb250ZW5kLlxuLy8gVGhpcyBlbmFibGVzIGFuIG9sZGVyIGZyb250ZW5kIHRvIGRpc3BsYXkgYW4gdXBncmFkZSBtZXNzYWdlIHRvIHVzZXJzIGZvciBhIG5ld2VyLCB1bnN1cHBvcnRlZCBiYWNrZW5kLlxuZXhwb3J0IHR5cGUgQnJpZGdlUHJvdG9jb2wgPSB7XG4gIC8vIFZlcnNpb24gc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGZyb250ZW5kL2JhY2tlbmQuXG4gIHZlcnNpb246IG51bWJlcixcblxuICAvLyBOUE0gdmVyc2lvbiByYW5nZSB0aGF0IGFsc28gc3VwcG9ydHMgdGhpcyB2ZXJzaW9uLlxuICAvLyBOb3RlIHRoYXQgJ21heE5wbVZlcnNpb24nIGlzIG9ubHkgc2V0IHdoZW4gdGhlIHZlcnNpb24gaXMgYnVtcGVkLlxuICBtaW5OcG1WZXJzaW9uOiBzdHJpbmcsXG4gIG1heE5wbVZlcnNpb246IHN0cmluZyB8IG51bGwsXG59O1xuXG4vLyBCdW1wIHByb3RvY29sIHZlcnNpb24gd2hlbmV2ZXIgYSBiYWNrd2FyZHMgYnJlYWtpbmcgY2hhbmdlIGlzIG1hZGVcbi8vIGluIHRoZSBtZXNzYWdlcyBzZW50IGJldHdlZW4gQmFja2VuZEJyaWRnZSBhbmQgRnJvbnRlbmRCcmlkZ2UuXG4vLyBUaGlzIG1hcHBpbmcgaXMgZW1iZWRkZWQgaW4gYm90aCBmcm9udGVuZCBhbmQgYmFja2VuZCBidWlsZHMuXG4vL1xuLy8gVGhlIGJhY2tlbmQgcHJvdG9jb2wgd2lsbCBhbHdheXMgYmUgdGhlIGxhdGVzdCBlbnRyeSBpbiB0aGUgQlJJREdFX1BST1RPQ09MIGFycmF5LlxuLy9cbi8vIFdoZW4gYW4gb2xkZXIgZnJvbnRlbmQgY29ubmVjdHMgdG8gYSBuZXdlciBiYWNrZW5kLFxuLy8gdGhlIGJhY2tlbmQgY2FuIHNlbmQgdGhlIG1pbk5wbVZlcnNpb24gYW5kIHRoZSBmcm9udGVuZCBjYW4gZGlzcGxheSBhbiBOUE0gdXBncmFkZSBwcm9tcHQuXG4vL1xuLy8gV2hlbiBhIG5ld2VyIGZyb250ZW5kIGNvbm5lY3RzIHdpdGggYW4gb2xkZXIgcHJvdG9jb2wgdmVyc2lvbixcbi8vIHRoZSBmcm9udGVuZCBjYW4gdXNlIHRoZSBlbWJlZGRlZCBtaW5OcG1WZXJzaW9uL21heE5wbVZlcnNpb24gdmFsdWVzIHRvIGRpc3BsYXkgYSBkb3duZ3JhZGUgcHJvbXB0LlxuZXhwb3J0IGNvbnN0IEJSSURHRV9QUk9UT0NPTDogQXJyYXk8QnJpZGdlUHJvdG9jb2w+ID0gW1xuICAvLyBUaGlzIHZlcnNpb24gdGVjaG5pY2FsbHkgbmV2ZXIgZXhpc3RlZCxcbiAgLy8gYnV0IGEgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZSB3YXMgYWRkZWQgaW4gNC4xMSxcbiAgLy8gc28gdGhlIHNhZmVzdCBndWVzcyB0byBkb3duZ3JhZGUgdGhlIGZyb250ZW5kIHdvdWxkIGJlIHRvIHZlcnNpb24gNC4xMC5cbiAge1xuICAgIHZlcnNpb246IDAsXG4gICAgbWluTnBtVmVyc2lvbjogJ1wiPDQuMTEuMFwiJyxcbiAgICBtYXhOcG1WZXJzaW9uOiAnXCI8NC4xMS4wXCInLFxuICB9LFxuICAvLyBWZXJzaW9ucyA0LjExLngg4oCTIDQuMTIueCBjb250YWluZWQgdGhlIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2UsXG4gIC8vIGJ1dCB3ZSBkaWRuJ3QgYWRkIHRoZSBcImZpeFwiIG9mIGNoZWNraW5nIHRoZSBwcm90b2NvbCB2ZXJzaW9uIHVudGlsIDQuMTMsXG4gIC8vIHNvIHdlIGRvbid0IHJlY29tbWVuZCBkb3duZ3JhZGluZyB0byA0LjExIG9yIDQuMTIuXG4gIHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIG1pbk5wbVZlcnNpb246ICc0LjEzLjAnLFxuICAgIG1heE5wbVZlcnNpb246ICc0LjIxLjAnLFxuICB9LFxuICAvLyBWZXJzaW9uIDIgYWRkcyBhIFN0cmljdE1vZGUtZW5hYmxlZCBhbmQgc3VwcG9ydHMtU3RyaWN0TW9kZSBiaXRzIHRvIGFkZC1yb290IG9wZXJhdGlvbi5cbiAge1xuICAgIHZlcnNpb246IDIsXG4gICAgbWluTnBtVmVyc2lvbjogJzQuMjIuMCcsXG4gICAgbWF4TnBtVmVyc2lvbjogbnVsbCxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBjdXJyZW50QnJpZGdlUHJvdG9jb2w6IEJyaWRnZVByb3RvY29sID1cbiAgQlJJREdFX1BST1RPQ09MW0JSSURHRV9QUk9UT0NPTC5sZW5ndGggLSAxXTtcblxudHlwZSBFbGVtZW50QW5kUmVuZGVyZXJJRCA9IHtpZDogbnVtYmVyLCByZW5kZXJlcklEOiBSZW5kZXJlcklEfTtcblxudHlwZSBNZXNzYWdlID0ge1xuICBldmVudDogc3RyaW5nLFxuICBwYXlsb2FkOiBhbnksXG59O1xuXG50eXBlIEhpZ2hsaWdodEhvc3RJbnN0YW5jZSA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsLFxuICBoaWRlQWZ0ZXJUaW1lb3V0OiBib29sZWFuLFxuICBvcGVuQnVpbHRpbkVsZW1lbnRzUGFuZWw6IGJvb2xlYW4sXG4gIHNjcm9sbEludG9WaWV3OiBib29sZWFuLFxufTtcblxudHlwZSBPdmVycmlkZVZhbHVlID0ge1xuICAuLi5FbGVtZW50QW5kUmVuZGVyZXJJRCxcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgd2FzRm9yd2FyZGVkPzogYm9vbGVhbixcbiAgdmFsdWU6IGFueSxcbn07XG5cbnR5cGUgT3ZlcnJpZGVIb29rU3RhdGUgPSB7XG4gIC4uLk92ZXJyaWRlVmFsdWUsXG4gIGhvb2tJRDogbnVtYmVyLFxufTtcblxudHlwZSBQYXRoVHlwZSA9ICdwcm9wcycgfCAnaG9va3MnIHwgJ3N0YXRlJyB8ICdjb250ZXh0JztcblxudHlwZSBEZWxldGVQYXRoID0ge1xuICAuLi5FbGVtZW50QW5kUmVuZGVyZXJJRCxcbiAgdHlwZTogUGF0aFR5cGUsXG4gIGhvb2tJRD86ID9udW1iZXIsXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG59O1xuXG50eXBlIFJlbmFtZVBhdGggPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICB0eXBlOiBQYXRoVHlwZSxcbiAgaG9va0lEPzogP251bWJlcixcbiAgb2xkUGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgbmV3UGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbn07XG5cbnR5cGUgT3ZlcnJpZGVWYWx1ZUF0UGF0aCA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIHR5cGU6IFBhdGhUeXBlLFxuICBob29rSUQ/OiA/bnVtYmVyLFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICB2YWx1ZTogYW55LFxufTtcblxudHlwZSBPdmVycmlkZUVycm9yID0ge1xuICAuLi5FbGVtZW50QW5kUmVuZGVyZXJJRCxcbiAgZm9yY2VFcnJvcjogYm9vbGVhbixcbn07XG5cbnR5cGUgT3ZlcnJpZGVTdXNwZW5zZSA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIGZvcmNlRmFsbGJhY2s6IGJvb2xlYW4sXG59O1xuXG50eXBlIENvcHlFbGVtZW50UGF0aFBhcmFtcyA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG59O1xuXG50eXBlIFZpZXdBdHRyaWJ1dGVTb3VyY2VQYXJhbXMgPSB7XG4gIC4uLkVsZW1lbnRBbmRSZW5kZXJlcklELFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxufTtcblxudHlwZSBJbnNwZWN0RWxlbWVudFBhcmFtcyA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIGZvcmNlRnVsbERhdGE6IGJvb2xlYW4sXG4gIHBhdGg6IEFycmF5PG51bWJlciB8IHN0cmluZz4gfCBudWxsLFxuICByZXF1ZXN0SUQ6IG51bWJlcixcbn07XG5cbnR5cGUgU3RvcmVBc0dsb2JhbFBhcmFtcyA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIGNvdW50OiBudW1iZXIsXG4gIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4sXG59O1xuXG50eXBlIE5hdGl2ZVN0eWxlRWRpdG9yX1JlbmFtZUF0dHJpYnV0ZVBhcmFtcyA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIG9sZE5hbWU6IHN0cmluZyxcbiAgbmV3TmFtZTogc3RyaW5nLFxuICB2YWx1ZTogc3RyaW5nLFxufTtcblxudHlwZSBOYXRpdmVTdHlsZUVkaXRvcl9TZXRWYWx1ZVBhcmFtcyA9IHtcbiAgLi4uRWxlbWVudEFuZFJlbmRlcmVySUQsXG4gIG5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyxcbn07XG5cbnR5cGUgU2F2ZWRQcmVmZXJlbmNlc1BhcmFtcyA9IHtcbiAgY29tcG9uZW50RmlsdGVyczogQXJyYXk8Q29tcG9uZW50RmlsdGVyPixcbn07XG5cbmV4cG9ydCB0eXBlIEJhY2tlbmRFdmVudHMgPSB7XG4gIGJhY2tlbmRJbml0aWFsaXplZDogW10sXG4gIGJhY2tlbmRWZXJzaW9uOiBbc3RyaW5nXSxcbiAgYnJpZGdlUHJvdG9jb2w6IFtCcmlkZ2VQcm90b2NvbF0sXG4gIGV4dGVuc2lvbkJhY2tlbmRJbml0aWFsaXplZDogW10sXG4gIGZhc3RSZWZyZXNoU2NoZWR1bGVkOiBbXSxcbiAgZ2V0U2F2ZWRQcmVmZXJlbmNlczogW10sXG4gIGluc3BlY3RlZEVsZW1lbnQ6IFtJbnNwZWN0ZWRFbGVtZW50UGF5bG9hZF0sXG4gIGlzUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZEJ5QmFja2VuZDogW2Jvb2xlYW5dLFxuICBvcGVyYXRpb25zOiBbQXJyYXk8bnVtYmVyPl0sXG4gIG93bmVyc0xpc3Q6IFtPd25lcnNMaXN0XSxcbiAgb3ZlcnJpZGVDb21wb25lbnRGaWx0ZXJzOiBbQXJyYXk8Q29tcG9uZW50RmlsdGVyPl0sXG4gIGVudmlyb25tZW50TmFtZXM6IFtBcnJheTxzdHJpbmc+XSxcbiAgcHJvZmlsaW5nRGF0YTogW1Byb2ZpbGluZ0RhdGFCYWNrZW5kXSxcbiAgcHJvZmlsaW5nU3RhdHVzOiBbYm9vbGVhbl0sXG4gIHJlbG9hZEFwcEZvclByb2ZpbGluZzogW10sXG4gIHNhdmVUb0NsaXBib2FyZDogW3N0cmluZ10sXG4gIHNlbGVjdEVsZW1lbnQ6IFtudW1iZXJdLFxuICBzaHV0ZG93bjogW10sXG4gIHN0b3BJbnNwZWN0aW5nSG9zdDogW2Jvb2xlYW5dLFxuICBzeW5jU2VsZWN0aW9uRnJvbUJ1aWx0aW5FbGVtZW50c1BhbmVsOiBbXSxcbiAgc3luY1NlbGVjdGlvblRvQnVpbHRpbkVsZW1lbnRzUGFuZWw6IFtdLFxuICB1bnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbjogW10sXG5cbiAgLy8gUmVhY3QgTmF0aXZlIHN0eWxlIGVkaXRvciBwbHVnLWluLlxuICBpc05hdGl2ZVN0eWxlRWRpdG9yU3VwcG9ydGVkOiBbXG4gICAge2lzU3VwcG9ydGVkOiBib29sZWFuLCB2YWxpZEF0dHJpYnV0ZXM6ID8kUmVhZE9ubHlBcnJheTxzdHJpbmc+fSxcbiAgXSxcbiAgTmF0aXZlU3R5bGVFZGl0b3Jfc3R5bGVBbmRMYXlvdXQ6IFtTdHlsZUFuZExheW91dFBheWxvYWRdLFxuXG4gIGhvb2tTZXR0aW5nczogWyRSZWFkT25seTxEZXZUb29sc0hvb2tTZXR0aW5ncz5dLFxufTtcblxudHlwZSBTdGFydFByb2ZpbGluZ1BhcmFtcyA9IFByb2ZpbGluZ1NldHRpbmdzO1xudHlwZSBSZWxvYWRBbmRQcm9maWxpbmdQYXJhbXMgPSBQcm9maWxpbmdTZXR0aW5ncztcblxudHlwZSBGcm9udGVuZEV2ZW50cyA9IHtcbiAgY2xlYXJFcnJvcnNBbmRXYXJuaW5nczogW3tyZW5kZXJlcklEOiBSZW5kZXJlcklEfV0sXG4gIGNsZWFyRXJyb3JzRm9yRWxlbWVudElEOiBbRWxlbWVudEFuZFJlbmRlcmVySURdLFxuICBjbGVhckhvc3RJbnN0YW5jZUhpZ2hsaWdodDogW10sXG4gIGNsZWFyV2FybmluZ3NGb3JFbGVtZW50SUQ6IFtFbGVtZW50QW5kUmVuZGVyZXJJRF0sXG4gIGNvcHlFbGVtZW50UGF0aDogW0NvcHlFbGVtZW50UGF0aFBhcmFtc10sXG4gIGRlbGV0ZVBhdGg6IFtEZWxldGVQYXRoXSxcbiAgZ2V0QmFja2VuZFZlcnNpb246IFtdLFxuICBnZXRCcmlkZ2VQcm90b2NvbDogW10sXG4gIGdldElmSGFzVW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb246IFtdLFxuICBnZXRPd25lcnNMaXN0OiBbRWxlbWVudEFuZFJlbmRlcmVySURdLFxuICBnZXRQcm9maWxpbmdEYXRhOiBbe3JlbmRlcmVySUQ6IFJlbmRlcmVySUR9XSxcbiAgZ2V0UHJvZmlsaW5nU3RhdHVzOiBbXSxcbiAgaGlnaGxpZ2h0SG9zdEluc3RhbmNlOiBbSGlnaGxpZ2h0SG9zdEluc3RhbmNlXSxcbiAgaW5zcGVjdEVsZW1lbnQ6IFtJbnNwZWN0RWxlbWVudFBhcmFtc10sXG4gIGxvZ0VsZW1lbnRUb0NvbnNvbGU6IFtFbGVtZW50QW5kUmVuZGVyZXJJRF0sXG4gIG92ZXJyaWRlRXJyb3I6IFtPdmVycmlkZUVycm9yXSxcbiAgb3ZlcnJpZGVTdXNwZW5zZTogW092ZXJyaWRlU3VzcGVuc2VdLFxuICBvdmVycmlkZVZhbHVlQXRQYXRoOiBbT3ZlcnJpZGVWYWx1ZUF0UGF0aF0sXG4gIHByb2ZpbGluZ0RhdGE6IFtQcm9maWxpbmdEYXRhQmFja2VuZF0sXG4gIHJlbG9hZEFuZFByb2ZpbGU6IFtSZWxvYWRBbmRQcm9maWxpbmdQYXJhbXNdLFxuICByZW5hbWVQYXRoOiBbUmVuYW1lUGF0aF0sXG4gIHNhdmVkUHJlZmVyZW5jZXM6IFtTYXZlZFByZWZlcmVuY2VzUGFyYW1zXSxcbiAgc2V0VHJhY2VVcGRhdGVzRW5hYmxlZDogW2Jvb2xlYW5dLFxuICBzaHV0ZG93bjogW10sXG4gIHN0YXJ0SW5zcGVjdGluZ0hvc3Q6IFtdLFxuICBzdGFydFByb2ZpbGluZzogW1N0YXJ0UHJvZmlsaW5nUGFyYW1zXSxcbiAgc3RvcEluc3BlY3RpbmdIb3N0OiBbYm9vbGVhbl0sXG4gIHN0b3BQcm9maWxpbmc6IFtdLFxuICBzdG9yZUFzR2xvYmFsOiBbU3RvcmVBc0dsb2JhbFBhcmFtc10sXG4gIHVwZGF0ZUNvbXBvbmVudEZpbHRlcnM6IFtBcnJheTxDb21wb25lbnRGaWx0ZXI+XSxcbiAgZ2V0RW52aXJvbm1lbnROYW1lczogW10sXG4gIHVwZGF0ZUhvb2tTZXR0aW5nczogWyRSZWFkT25seTxEZXZUb29sc0hvb2tTZXR0aW5ncz5dLFxuICB2aWV3QXR0cmlidXRlU291cmNlOiBbVmlld0F0dHJpYnV0ZVNvdXJjZVBhcmFtc10sXG4gIHZpZXdFbGVtZW50U291cmNlOiBbRWxlbWVudEFuZFJlbmRlcmVySURdLFxuXG4gIC8vIFJlYWN0IE5hdGl2ZSBzdHlsZSBlZGl0b3IgcGx1Zy1pbi5cbiAgTmF0aXZlU3R5bGVFZGl0b3JfbWVhc3VyZTogW0VsZW1lbnRBbmRSZW5kZXJlcklEXSxcbiAgTmF0aXZlU3R5bGVFZGl0b3JfcmVuYW1lQXR0cmlidXRlOiBbTmF0aXZlU3R5bGVFZGl0b3JfUmVuYW1lQXR0cmlidXRlUGFyYW1zXSxcbiAgTmF0aXZlU3R5bGVFZGl0b3Jfc2V0VmFsdWU6IFtOYXRpdmVTdHlsZUVkaXRvcl9TZXRWYWx1ZVBhcmFtc10sXG5cbiAgLy8gVGVtcG9yYXJpbHkgc3VwcG9ydCBuZXdlciBzdGFuZGFsb25lIGZyb250LWVuZHMgc2VuZGluZyBjb21tYW5kcyB0byBvbGRlciBlbWJlZGRlZCBiYWNrZW5kcy5cbiAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIFJlYWN0IE5hdGl2ZSBlbWJlZHMgdGhlIFJlYWN0IERldlRvb2xzIGJhY2tlbmQsXG4gIC8vIGJ1dCBjYW5ub3QgY29udHJvbCB3aGljaCB2ZXJzaW9uIG9mIHRoZSBmcm9udGVuZCB1c2VycyB1c2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCBub3RoaW5nIGluIHRoZSBuZXdlciBiYWNrZW5kIGFjdHVhbGx5IGxpc3RlbnMgdG8gdGhlc2UgZXZlbnRzLFxuICAvLyBidXQgdGhlIG5ldyBmcm9udGVuZCBzdGlsbCBkaXNwYXRjaGVzIHRoZW0gKGluIGNhc2Ugb2xkZXIgYmFja2VuZHMgYXJlIGxpc3RlbmluZyB0byB0aGVtIGluc3RlYWQpLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgdGhpcyBhcHByb2FjaCBkb2VzIG5vIHN1cHBvcnQgdGhlIGNvbWJpbmF0aW9uIG9mIGEgbmV3ZXIgYmFja2VuZCB3aXRoIGFuIG9sZGVyIGZyb250ZW5kLlxuICAvLyBJdCB3b3VsZCBiZSBtb3JlIHdvcmsgdG8gc3VwcG9ydCBib3RoIGFwcHJvYWNoZXMgKGFuZCBub3QgcnVuIGhhbmRsZXJzIHR3aWNlKVxuICAvLyBzbyBJIGNob3NlIHRvIHN1cHBvcnQgdGhlIG1vcmUgbGlrZWx5L2NvbW1vbiBzY2VuYXJpbyAoYW5kIHRoZSBvbmUgbW9yZSBkaWZmaWN1bHQgZm9yIGFuIGVuZCB1c2VyIHRvIFwiZml4XCIpLlxuICBvdmVycmlkZUNvbnRleHQ6IFtPdmVycmlkZVZhbHVlXSxcbiAgb3ZlcnJpZGVIb29rU3RhdGU6IFtPdmVycmlkZUhvb2tTdGF0ZV0sXG4gIG92ZXJyaWRlUHJvcHM6IFtPdmVycmlkZVZhbHVlXSxcbiAgb3ZlcnJpZGVTdGF0ZTogW092ZXJyaWRlVmFsdWVdLFxuXG4gIHJlc3VtZUVsZW1lbnRQb2xsaW5nOiBbXSxcbiAgcGF1c2VFbGVtZW50UG9sbGluZzogW10sXG5cbiAgZ2V0SG9va1NldHRpbmdzOiBbXSxcbn07XG5cbmNsYXNzIEJyaWRnZTxcbiAgT3V0Z29pbmdFdmVudHM6IE9iamVjdCxcbiAgSW5jb21pbmdFdmVudHM6IE9iamVjdCxcbj4gZXh0ZW5kcyBFdmVudEVtaXR0ZXI8e1xuICAuLi5JbmNvbWluZ0V2ZW50cyxcbiAgLi4uT3V0Z29pbmdFdmVudHMsXG59PiB7XG4gIF9pc1NodXRkb3duOiBib29sZWFuID0gZmFsc2U7XG4gIF9tZXNzYWdlUXVldWU6IEFycmF5PGFueT4gPSBbXTtcbiAgX3NjaGVkdWxlZEZsdXNoOiBib29sZWFuID0gZmFsc2U7XG4gIF93YWxsOiBXYWxsO1xuICBfd2FsbFVubGlzdGVuOiBGdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHdhbGw6IFdhbGwpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fd2FsbCA9IHdhbGw7XG5cbiAgICB0aGlzLl93YWxsVW5saXN0ZW4gPVxuICAgICAgd2FsbC5saXN0ZW4oKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgbWVzc2FnZS5ldmVudCkge1xuICAgICAgICAgICh0aGlzOiBhbnkpLmVtaXQobWVzc2FnZS5ldmVudCwgbWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfSkgfHwgbnVsbDtcblxuICAgIC8vIFRlbXBvcmFyaWx5IHN1cHBvcnQgb2xkZXIgc3RhbmRhbG9uZSBmcm9udC1lbmRzIHNlbmRpbmcgY29tbWFuZHMgdG8gbmV3ZXIgZW1iZWRkZWQgYmFja2VuZHMuXG4gICAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIFJlYWN0IE5hdGl2ZSBlbWJlZHMgdGhlIFJlYWN0IERldlRvb2xzIGJhY2tlbmQsXG4gICAgLy8gYnV0IGNhbm5vdCBjb250cm9sIHdoaWNoIHZlcnNpb24gb2YgdGhlIGZyb250ZW5kIHVzZXJzIHVzZS5cbiAgICB0aGlzLmFkZExpc3RlbmVyKCdvdmVycmlkZVZhbHVlQXRQYXRoJywgdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKTtcbiAgfVxuXG4gIC8vIExpc3RlbmluZyBkaXJlY3RseSB0byB0aGUgd2FsbCBpc24ndCBhZHZpc2VkLlxuICAvLyBJdCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gZm9yIGxlZ2FjeSAodjMpIG1lc3NhZ2VzIChzaW5jZSB0aGV5IHVzZSBhIGRpZmZlcmVudCBmb3JtYXQpLlxuICBnZXQgd2FsbCgpOiBXYWxsIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbDtcbiAgfVxuXG4gIHNlbmQ8RXZlbnROYW1lOiAkS2V5czxPdXRnb2luZ0V2ZW50cz4+KFxuICAgIGV2ZW50OiBFdmVudE5hbWUsXG4gICAgLi4ucGF5bG9hZDogJEVsZW1lbnRUeXBlPE91dGdvaW5nRXZlbnRzLCBFdmVudE5hbWU+XG4gICkge1xuICAgIGlmICh0aGlzLl9pc1NodXRkb3duKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBDYW5ub3Qgc2VuZCBtZXNzYWdlIFwiJHtldmVudH1cIiB0aHJvdWdoIGEgQnJpZGdlIHRoYXQgaGFzIGJlZW4gc2h1dGRvd24uYCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2hlbiB3ZSByZWNlaXZlIGEgbWVzc2FnZTpcbiAgICAvLyAtIHdlIGFkZCBpdCB0byBvdXIgcXVldWUgb2YgbWVzc2FnZXMgdG8gYmUgc2VudFxuICAgIC8vIC0gaWYgdGhlcmUgaGFzbid0IGJlZW4gYSBtZXNzYWdlIHJlY2VudGx5LCB3ZSBzZXQgYSB0aW1lciBmb3IgMCBtcyBpblxuICAgIC8vICAgdGhlIGZ1dHVyZSwgYWxsb3dpbmcgYWxsIG1lc3NhZ2VzIGNyZWF0ZWQgaW4gdGhlIHNhbWUgdGljayB0byBiZSBzZW50XG4gICAgLy8gICB0b2dldGhlclxuICAgIC8vIC0gaWYgdGhlcmUgKmhhcyogYmVlbiBhIG1lc3NhZ2UgZmx1c2hlZCBpbiB0aGUgbGFzdCBCQVRDSF9EVVJBVElPTiBtc1xuICAgIC8vICAgKG9yIHdlJ3JlIHdhaXRpbmcgZm9yIG91ciBzZXRUaW1lb3V0LTAgdG8gZmlyZSksIHRoZW4gX3RpbWVvdXRJRCB3aWxsXG4gICAgLy8gICBiZSBzZXQsIGFuZCB3ZSdsbCBzaW1wbHkgYWRkIHRvIHRoZSBxdWV1ZSBhbmQgd2FpdCBmb3IgdGhhdFxuICAgIHRoaXMuX21lc3NhZ2VRdWV1ZS5wdXNoKGV2ZW50LCBwYXlsb2FkKTtcbiAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZEZsdXNoKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZWRGbHVzaCA9IHRydWU7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBpZiAodHlwZW9mIGRldnRvb2xzSmVzdFRlc3RTY2hlZHVsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVGhpcyBleGlzdHMganVzdCBmb3Igb3VyIG93biBqZXN0IHRlc3RzLlxuICAgICAgICAvLyBUaGV5J3JlIHdyaXR0ZW4gaW4gc3VjaCBhIHdheSB0aGF0IHdlIGNhbiBuZWl0aGVyIG1vY2sgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVuIHdlIGJyZWFrIFJlYWN0IERPTSBhbmQgd2UgY2FuJ3Qgbm90IG1vY2sgaXQgYmVjYXVzZSB0aGVuXG4gICAgICAgIC8vIHdlIGNhbid0IHN5bmNocm9ub3VzbHkgZmx1c2ggaXQuIFNvIHRoZXkgbmVlZCB0byBiZSByZXdyaXR0ZW4uXG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgZGV2dG9vbHNKZXN0VGVzdFNjaGVkdWxlcih0aGlzLl9mbHVzaCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKHRoaXMuX2ZsdXNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzaHV0ZG93bigpIHtcbiAgICBpZiAodGhpcy5faXNTaHV0ZG93bikge1xuICAgICAgY29uc29sZS53YXJuKCdCcmlkZ2Ugd2FzIGFscmVhZHkgc2h1dGRvd24uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUXVldWUgdGhlIHNodXRkb3duIG91dGdvaW5nIG1lc3NhZ2UgZm9yIHN1YnNjcmliZXJzLlxuICAgIHRoaXMuZW1pdCgnc2h1dGRvd24nKTtcbiAgICB0aGlzLnNlbmQoJ3NodXRkb3duJyk7XG5cbiAgICAvLyBNYXJrIHRoaXMgYnJpZGdlIGFzIGRlc3Ryb3llZCwgaS5lLiBkaXNhYmxlIGl0cyBwdWJsaWMgQVBJLlxuICAgIHRoaXMuX2lzU2h1dGRvd24gPSB0cnVlO1xuXG4gICAgLy8gRGlzYWJsZSB0aGUgQVBJIGluaGVyaXRlZCBmcm9tIEV2ZW50RW1pdHRlciB0aGF0IGNhbiBhZGQgbW9yZSBsaXN0ZW5lcnMgYW5kIHNlbmQgbW9yZSBtZXNzYWdlcy5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gVGhpcyBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuXG4gICAgdGhpcy5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBUaGlzIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cbiAgICB0aGlzLmVtaXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAvLyBOT1RFOiBUaGVyZSdzIGFsc28gRXZlbnRFbWl0dGVyIEFQSSBsaWtlIGBvbmAgYW5kIGBwcmVwZW5kTGlzdGVuZXJgIHRoYXQgd2UgZGlkbid0IGFkZCB0byBvdXIgRmxvdyB0eXBlIG9mIEV2ZW50RW1pdHRlci5cblxuICAgIC8vIFVuc3Vic2NyaWJlIHRoaXMgYnJpZGdlIGluY29taW5nIG1lc3NhZ2UgbGlzdGVuZXJzIHRvIGJlIHN1cmUsIGFuZCBzbyB0aGV5IGRvbid0IGhhdmUgdG8gZG8gdGhhdC5cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gU3RvcCBhY2NlcHRpbmcgYW5kIGVtaXR0aW5nIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIHdhbGwuXG4gICAgY29uc3Qgd2FsbFVubGlzdGVuID0gdGhpcy5fd2FsbFVubGlzdGVuO1xuICAgIGlmICh3YWxsVW5saXN0ZW4pIHtcbiAgICAgIHdhbGxVbmxpc3RlbigpO1xuICAgIH1cblxuICAgIC8vIFN5bmNocm9ub3VzbHkgZmx1c2ggYWxsIHF1ZXVlZCBvdXRnb2luZyBtZXNzYWdlcy5cbiAgICAvLyBBdCB0aGlzIHN0ZXAgdGhlIHN1YnNjcmliZXJzJyBjb2RlIG1heSBydW4gaW4gdGhpcyBjYWxsIHN0YWNrLlxuICAgIGRvIHtcbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfSB3aGlsZSAodGhpcy5fbWVzc2FnZVF1ZXVlLmxlbmd0aCk7XG4gIH1cblxuICBfZmx1c2g6ICgpID0+IHZvaWQgPSAoKSA9PiB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgdXNlZCBhZnRlciB0aGUgYnJpZGdlIGlzIG1hcmtlZCBhcyBkZXN0cm95ZWQgaW4gc2h1dGRvd24gc2VxdWVuY2UsXG4gICAgLy8gc28gd2UgZG8gbm90IGJhaWwgb3V0IGlmIHRoZSBicmlkZ2UgbWFya2VkIGFzIGRlc3Ryb3llZC5cbiAgICAvLyBJdCBpcyBhIHByaXZhdGUgbWV0aG9kIHRoYXQgdGhlIGJyaWRnZSBlbnN1cmVzIGlzIG9ubHkgY2FsbGVkIGF0IHRoZSByaWdodCB0aW1lcy5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tZXNzYWdlUXVldWUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICB0aGlzLl93YWxsLnNlbmQodGhpcy5fbWVzc2FnZVF1ZXVlW2ldLCAuLi50aGlzLl9tZXNzYWdlUXVldWVbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXNzYWdlUXVldWUubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gV2Ugc2V0IHRoaXMgYXQgdGhlIGVuZCBpbiBjYXNlIG5ldyBtZXNzYWdlcyBhcmUgYWRkZWQgc3luY2hyb25vdXNseSBhYm92ZS5cbiAgICAgIC8vIFRoZXkncmUgYWxyZWFkeSBoYW5kbGVkIHNvIHRoZXkgc2hvdWxkbid0IHF1ZXVlIG1vcmUgZmx1c2hlcy5cbiAgICAgIHRoaXMuX3NjaGVkdWxlZEZsdXNoID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRlbXBvcmFyaWx5IHN1cHBvcnQgb2xkZXIgc3RhbmRhbG9uZSBiYWNrZW5kcyBieSBmb3J3YXJkaW5nIFwib3ZlcnJpZGVWYWx1ZUF0UGF0aFwiIGNvbW1hbmRzXG4gIC8vIHRvIHRoZSBvbGRlciBtZXNzYWdlIHR5cGVzIHRoZXkgbWF5IGJlIGxpc3RlbmluZyB0by5cbiAgb3ZlcnJpZGVWYWx1ZUF0UGF0aDogT3ZlcnJpZGVWYWx1ZUF0UGF0aCA9PiB2b2lkID0gKHtcbiAgICBpZCxcbiAgICBwYXRoLFxuICAgIHJlbmRlcmVySUQsXG4gICAgdHlwZSxcbiAgICB2YWx1ZSxcbiAgfTogT3ZlcnJpZGVWYWx1ZUF0UGF0aCkgPT4ge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgIHRoaXMuc2VuZCgnb3ZlcnJpZGVDb250ZXh0Jywge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRCxcbiAgICAgICAgICB3YXNGb3J3YXJkZWQ6IHRydWUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgdGhpcy5zZW5kKCdvdmVycmlkZUhvb2tTdGF0ZScsIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgICAgd2FzRm9yd2FyZGVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgIHRoaXMuc2VuZCgnb3ZlcnJpZGVQcm9wcycsIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgICAgd2FzRm9yd2FyZGVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgIHRoaXMuc2VuZCgnb3ZlcnJpZGVTdGF0ZScsIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgICAgd2FzRm9yd2FyZGVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgdHlwZSBCYWNrZW5kQnJpZGdlID0gQnJpZGdlPEJhY2tlbmRFdmVudHMsIEZyb250ZW5kRXZlbnRzPjtcbmV4cG9ydCB0eXBlIEZyb250ZW5kQnJpZGdlID0gQnJpZGdlPEZyb250ZW5kRXZlbnRzLCBCYWNrZW5kRXZlbnRzPjtcblxuZXhwb3J0IGRlZmF1bHQgQnJpZGdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/bridge.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js":
/*!****************************************************************************!*\
  !*** ../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"enableLogger\": () => (/* binding */ enableLogger),\n/* harmony export */   \"enableStyleXFeatures\": () => (/* binding */ enableStyleXFeatures),\n/* harmony export */   \"isInternalFacebookBuild\": () => (/* binding */ isInternalFacebookBuild)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/************************************************************************\n * This file is forked between different DevTools implementations.\n * It should never be imported directly!\n * It should always be imported from \"react-devtools-feature-flags\".\n ************************************************************************/\nconst enableLogger = false;\nconst enableStyleXFeatures = false;\nconst isInternalFacebookBuild = false;\n/************************************************************************\n * Do not edit the code below.\n * It ensures this fork exports the same types as the default flags file.\n ************************************************************************/\n\n// Flow magic to verify the exports of this file match the original version.\nnull;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25maWcvRGV2VG9vbHNGZWF0dXJlRmxhZ3MuY29yZS1vc3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7OztBQVNBOzs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7OztBQVFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvY29uZmlnL0RldlRvb2xzRmVhdHVyZUZsYWdzLmNvcmUtb3NzLmpzPzBhZTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogVGhpcyBmaWxlIGlzIGZvcmtlZCBiZXR3ZWVuIGRpZmZlcmVudCBEZXZUb29scyBpbXBsZW1lbnRhdGlvbnMuXG4gKiBJdCBzaG91bGQgbmV2ZXIgYmUgaW1wb3J0ZWQgZGlyZWN0bHkhXG4gKiBJdCBzaG91bGQgYWx3YXlzIGJlIGltcG9ydGVkIGZyb20gXCJyZWFjdC1kZXZ0b29scy1mZWF0dXJlLWZsYWdzXCIuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5leHBvcnQgY29uc3QgZW5hYmxlTG9nZ2VyID0gZmFsc2U7XG5leHBvcnQgY29uc3QgZW5hYmxlU3R5bGVYRmVhdHVyZXMgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBpc0ludGVybmFsRmFjZWJvb2tCdWlsZCA9IGZhbHNlO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBEbyBub3QgZWRpdCB0aGUgY29kZSBiZWxvdy5cbiAqIEl0IGVuc3VyZXMgdGhpcyBmb3JrIGV4cG9ydHMgdGhlIHNhbWUgdHlwZXMgYXMgdGhlIGRlZmF1bHQgZmxhZ3MgZmlsZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmltcG9ydCB0eXBlb2YgKiBhcyBGZWF0dXJlRmxhZ3NUeXBlIGZyb20gJy4vRGV2VG9vbHNGZWF0dXJlRmxhZ3MuZGVmYXVsdCc7XG5pbXBvcnQgdHlwZW9mICogYXMgRXhwb3J0c1R5cGUgZnJvbSAnLi9EZXZUb29sc0ZlYXR1cmVGbGFncy5jb3JlLW9zcyc7XG5cbi8vIEZsb3cgbWFnaWMgdG8gdmVyaWZ5IHRoZSBleHBvcnRzIG9mIHRoaXMgZmlsZSBtYXRjaCB0aGUgb3JpZ2luYWwgdmVyc2lvbi5cbigoKChudWxsOiBhbnkpOiBFeHBvcnRzVHlwZSk6IEZlYXR1cmVGbGFnc1R5cGUpOiBFeHBvcnRzVHlwZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/constants.js":
/*!*************************************************!*\
  !*** ../react-devtools-shared/src/constants.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ANSI_STYLE_DIMMING_TEMPLATE\": () => (/* binding */ ANSI_STYLE_DIMMING_TEMPLATE),\n/* harmony export */   \"ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK\": () => (/* binding */ ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK),\n/* harmony export */   \"CHROME_WEBSTORE_EXTENSION_ID\": () => (/* binding */ CHROME_WEBSTORE_EXTENSION_ID),\n/* harmony export */   \"FIREFOX_CONSOLE_DIMMING_COLOR\": () => (/* binding */ FIREFOX_CONSOLE_DIMMING_COLOR),\n/* harmony export */   \"INTERNAL_EXTENSION_ID\": () => (/* binding */ INTERNAL_EXTENSION_ID),\n/* harmony export */   \"LOCAL_EXTENSION_ID\": () => (/* binding */ LOCAL_EXTENSION_ID),\n/* harmony export */   \"LOCAL_STORAGE_BROWSER_THEME\": () => (/* binding */ LOCAL_STORAGE_BROWSER_THEME),\n/* harmony export */   \"LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY\": () => (/* binding */ LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY),\n/* harmony export */   \"LOCAL_STORAGE_DEFAULT_TAB_KEY\": () => (/* binding */ LOCAL_STORAGE_DEFAULT_TAB_KEY),\n/* harmony export */   \"LOCAL_STORAGE_OPEN_IN_EDITOR_URL\": () => (/* binding */ LOCAL_STORAGE_OPEN_IN_EDITOR_URL),\n/* harmony export */   \"LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET\": () => (/* binding */ LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET),\n/* harmony export */   \"LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY\": () => (/* binding */ LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY),\n/* harmony export */   \"LOCAL_STORAGE_SUPPORTS_PROFILING_KEY\": () => (/* binding */ LOCAL_STORAGE_SUPPORTS_PROFILING_KEY),\n/* harmony export */   \"LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY\": () => (/* binding */ LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY),\n/* harmony export */   \"PROFILER_EXPORT_VERSION\": () => (/* binding */ PROFILER_EXPORT_VERSION),\n/* harmony export */   \"PROFILING_FLAG_BASIC_SUPPORT\": () => (/* binding */ PROFILING_FLAG_BASIC_SUPPORT),\n/* harmony export */   \"PROFILING_FLAG_TIMELINE_SUPPORT\": () => (/* binding */ PROFILING_FLAG_TIMELINE_SUPPORT),\n/* harmony export */   \"SESSION_STORAGE_LAST_SELECTION_KEY\": () => (/* binding */ SESSION_STORAGE_LAST_SELECTION_KEY),\n/* harmony export */   \"SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY\": () => (/* binding */ SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY),\n/* harmony export */   \"SESSION_STORAGE_RECORD_TIMELINE_KEY\": () => (/* binding */ SESSION_STORAGE_RECORD_TIMELINE_KEY),\n/* harmony export */   \"SESSION_STORAGE_RELOAD_AND_PROFILE_KEY\": () => (/* binding */ SESSION_STORAGE_RELOAD_AND_PROFILE_KEY),\n/* harmony export */   \"TREE_OPERATION_ADD\": () => (/* binding */ TREE_OPERATION_ADD),\n/* harmony export */   \"TREE_OPERATION_REMOVE\": () => (/* binding */ TREE_OPERATION_REMOVE),\n/* harmony export */   \"TREE_OPERATION_REMOVE_ROOT\": () => (/* binding */ TREE_OPERATION_REMOVE_ROOT),\n/* harmony export */   \"TREE_OPERATION_REORDER_CHILDREN\": () => (/* binding */ TREE_OPERATION_REORDER_CHILDREN),\n/* harmony export */   \"TREE_OPERATION_SET_SUBTREE_MODE\": () => (/* binding */ TREE_OPERATION_SET_SUBTREE_MODE),\n/* harmony export */   \"TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS\": () => (/* binding */ TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS),\n/* harmony export */   \"TREE_OPERATION_UPDATE_TREE_BASE_DURATION\": () => (/* binding */ TREE_OPERATION_UPDATE_TREE_BASE_DURATION),\n/* harmony export */   \"__DEBUG__\": () => (/* binding */ __DEBUG__),\n/* harmony export */   \"__PERFORMANCE_PROFILE__\": () => (/* binding */ __PERFORMANCE_PROFILE__)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst CHROME_WEBSTORE_EXTENSION_ID = 'fmkadmapgofadopljbjfkapdkoienihi';\nconst INTERNAL_EXTENSION_ID = 'dnjnjgbfilfphmojnmhliehogmojhclc';\nconst LOCAL_EXTENSION_ID = 'ikiahnapldjmdmpkmfhjdjilojjhgcbf'; // Flip this flag to true to enable verbose console debug logging.\n\nconst __DEBUG__ = false; // Flip this flag to true to enable performance.mark() and performance.measure() timings.\n\nconst __PERFORMANCE_PROFILE__ = false;\nconst TREE_OPERATION_ADD = 1;\nconst TREE_OPERATION_REMOVE = 2;\nconst TREE_OPERATION_REORDER_CHILDREN = 3;\nconst TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;\nconst TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;\nconst TREE_OPERATION_REMOVE_ROOT = 6;\nconst TREE_OPERATION_SET_SUBTREE_MODE = 7;\nconst PROFILING_FLAG_BASIC_SUPPORT = 0b01;\nconst PROFILING_FLAG_TIMELINE_SUPPORT = 0b10;\nconst LOCAL_STORAGE_DEFAULT_TAB_KEY = 'React::DevTools::defaultTab';\nconst LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';\nconst SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';\nconst LOCAL_STORAGE_OPEN_IN_EDITOR_URL = 'React::DevTools::openInEditorUrl';\nconst LOCAL_STORAGE_OPEN_IN_EDITOR_URL_PRESET = 'React::DevTools::openInEditorUrlPreset';\nconst LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = 'React::DevTools::parseHookNames';\nconst SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';\nconst SESSION_STORAGE_RECORD_TIMELINE_KEY = 'React::DevTools::recordTimeline';\nconst SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';\nconst LOCAL_STORAGE_BROWSER_THEME = 'React::DevTools::theme';\nconst LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';\nconst LOCAL_STORAGE_SUPPORTS_PROFILING_KEY = 'React::DevTools::supportsProfiling';\nconst PROFILER_EXPORT_VERSION = 5;\nconst FIREFOX_CONSOLE_DIMMING_COLOR = 'color: rgba(124, 124, 124, 0.75)';\nconst ANSI_STYLE_DIMMING_TEMPLATE = '\\x1b[2;38;2;124;124;124m%s\\x1b[0m';\nconst ANSI_STYLE_DIMMING_TEMPLATE_WITH_COMPONENT_STACK = '\\x1b[2;38;2;124;124;124m%s %o\\x1b[0m';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUdBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvY29uc3RhbnRzLmpzP2EzMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuZXhwb3J0IGNvbnN0IENIUk9NRV9XRUJTVE9SRV9FWFRFTlNJT05fSUQgPSAnZm1rYWRtYXBnb2ZhZG9wbGpiamZrYXBka29pZW5paGknO1xuZXhwb3J0IGNvbnN0IElOVEVSTkFMX0VYVEVOU0lPTl9JRCA9ICdkbmpuamdiZmlsZnBobW9qbm1obGllaG9nbW9qaGNsYyc7XG5leHBvcnQgY29uc3QgTE9DQUxfRVhURU5TSU9OX0lEID0gJ2lraWFobmFwbGRqbWRtcGttZmhqZGppbG9qamhnY2JmJztcblxuLy8gRmxpcCB0aGlzIGZsYWcgdG8gdHJ1ZSB0byBlbmFibGUgdmVyYm9zZSBjb25zb2xlIGRlYnVnIGxvZ2dpbmcuXG5leHBvcnQgY29uc3QgX19ERUJVR19fID0gZmFsc2U7XG5cbi8vIEZsaXAgdGhpcyBmbGFnIHRvIHRydWUgdG8gZW5hYmxlIHBlcmZvcm1hbmNlLm1hcmsoKSBhbmQgcGVyZm9ybWFuY2UubWVhc3VyZSgpIHRpbWluZ3MuXG5leHBvcnQgY29uc3QgX19QRVJGT1JNQU5DRV9QUk9GSUxFX18gPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IFRSRUVfT1BFUkFUSU9OX0FERCA9IDE7XG5leHBvcnQgY29uc3QgVFJFRV9PUEVSQVRJT05fUkVNT1ZFID0gMjtcbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOID0gMztcbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9VUERBVEVfVFJFRV9CQVNFX0RVUkFUSU9OID0gNDtcbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTID0gNTtcbmV4cG9ydCBjb25zdCBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCA9IDY7XG5leHBvcnQgY29uc3QgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSA9IDc7XG5cbmV4cG9ydCBjb25zdCBQUk9GSUxJTkdfRkxBR19CQVNJQ19TVVBQT1JUID0gMGIwMTtcbmV4cG9ydCBjb25zdCBQUk9GSUxJTkdfRkxBR19USU1FTElORV9TVVBQT1JUID0gMGIxMDtcblxuZXhwb3J0IGNvbnN0IExPQ0FMX1NUT1JBR0VfREVGQVVMVF9UQUJfS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6ZGVmYXVsdFRhYic7XG5leHBvcnQgY29uc3QgTE9DQUxfU1RPUkFHRV9DT01QT05FTlRfRklMVEVSX1BSRUZFUkVOQ0VTX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OmNvbXBvbmVudEZpbHRlcnMnO1xuZXhwb3J0IGNvbnN0IFNFU1NJT05fU1RPUkFHRV9MQVNUX1NFTEVDVElPTl9LRVkgPVxuICAnUmVhY3Q6OkRldlRvb2xzOjpsYXN0U2VsZWN0aW9uJztcbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX09QRU5fSU5fRURJVE9SX1VSTCA9XG4gICdSZWFjdDo6RGV2VG9vbHM6Om9wZW5JbkVkaXRvclVybCc7XG5leHBvcnQgY29uc3QgTE9DQUxfU1RPUkFHRV9PUEVOX0lOX0VESVRPUl9VUkxfUFJFU0VUID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6b3BlbkluRWRpdG9yVXJsUHJlc2V0JztcbmV4cG9ydCBjb25zdCBMT0NBTF9TVE9SQUdFX1BBUlNFX0hPT0tfTkFNRVNfS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6cGFyc2VIb29rTmFtZXMnO1xuZXhwb3J0IGNvbnN0IFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVkgPVxuICAnUmVhY3Q6OkRldlRvb2xzOjpyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMnO1xuZXhwb3J0IGNvbnN0IFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfVElNRUxJTkVfS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6cmVjb3JkVGltZWxpbmUnO1xuZXhwb3J0IGNvbnN0IFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6cmVsb2FkQW5kUHJvZmlsZSc7XG5leHBvcnQgY29uc3QgTE9DQUxfU1RPUkFHRV9CUk9XU0VSX1RIRU1FID0gJ1JlYWN0OjpEZXZUb29sczo6dGhlbWUnO1xuZXhwb3J0IGNvbnN0IExPQ0FMX1NUT1JBR0VfVFJBQ0VfVVBEQVRFU19FTkFCTEVEX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OnRyYWNlVXBkYXRlc0VuYWJsZWQnO1xuZXhwb3J0IGNvbnN0IExPQ0FMX1NUT1JBR0VfU1VQUE9SVFNfUFJPRklMSU5HX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OnN1cHBvcnRzUHJvZmlsaW5nJztcblxuZXhwb3J0IGNvbnN0IFBST0ZJTEVSX0VYUE9SVF9WRVJTSU9OID0gNTtcblxuZXhwb3J0IGNvbnN0IEZJUkVGT1hfQ09OU09MRV9ESU1NSU5HX0NPTE9SID0gJ2NvbG9yOiByZ2JhKDEyNCwgMTI0LCAxMjQsIDAuNzUpJztcbmV4cG9ydCBjb25zdCBBTlNJX1NUWUxFX0RJTU1JTkdfVEVNUExBVEUgPSAnXFx4MWJbMjszODsyOzEyNDsxMjQ7MTI0bSVzXFx4MWJbMG0nO1xuZXhwb3J0IGNvbnN0IEFOU0lfU1RZTEVfRElNTUlOR19URU1QTEFURV9XSVRIX0NPTVBPTkVOVF9TVEFDSyA9XG4gICdcXHgxYlsyOzM4OzI7MTI0OzEyNDsxMjRtJXMgJW9cXHgxYlswbSc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/constants.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/ProfilerStore.js":
/*!**************************************************************!*\
  !*** ../react-devtools-shared/src/devtools/ProfilerStore.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ProfilerStore)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events */ \"../react-devtools-shared/src/events.js\");\n/* harmony import */ var _views_Profiler_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./views/Profiler/utils */ \"../react-devtools-shared/src/devtools/views/Profiler/utils.js\");\n/* harmony import */ var _ProfilingCache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ProfilingCache */ \"../react-devtools-shared/src/devtools/ProfilingCache.js\");\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./store */ \"../react-devtools-shared/src/devtools/store.js\");\n/* harmony import */ var react_devtools_shared_src_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-devtools-shared/src/Logger */ \"../react-devtools-shared/src/Logger.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\nclass ProfilerStore extends _events__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  // Suspense cache for lazily calculating derived profiling data.\n  // Temporary store of profiling data from the backend renderer(s).\n  // This data will be converted to the ProfilingDataFrontend format after being collected from all renderers.\n  // Data from the most recently completed profiling session,\n  // or data that has been imported from a previously exported session.\n  // This object contains all necessary data to drive the Profiler UI interface,\n  // even though some of it is lazily parsed/derived via the ProfilingCache.\n  // Snapshot of all attached renderer IDs.\n  // Once profiling is finished, this snapshot will be used to query renderers for profiling data.\n  //\n  // This map is initialized when profiling starts and updated when a new root is added while profiling;\n  // Upon completion, it is converted into the exportable ProfilingDataFrontend format.\n  // Snapshot of the state of the main Store (including all roots) when profiling started.\n  // Once profiling is finished, this snapshot can be used along with \"operations\" messages emitted during profiling,\n  // to reconstruct the state of each root for each commit.\n  // It's okay to use a single root to store this information because node IDs are unique across all roots.\n  //\n  // This map is initialized when profiling starts and updated when a new root is added while profiling;\n  // Upon completion, it is converted into the exportable ProfilingDataFrontend format.\n  // Map of root (id) to a list of tree mutation that occur during profiling.\n  // Once profiling is finished, these mutations can be used, along with the initial tree snapshots,\n  // to reconstruct the state of each root for each commit.\n  //\n  // This map is only updated while profiling is in progress;\n  // Upon completion, it is converted into the exportable ProfilingDataFrontend format.\n  // The backend is currently profiling.\n  // When profiling is in progress, operations are stored so that we can later reconstruct past commit trees.\n  // Mainly used for optimistic UI.\n  // This could be false, but at the same time _isBackendProfiling could be true\n  // for cases when Backend is busy serializing a chunky payload.\n  // Tracks whether a specific renderer logged any profiling data during the most recent session.\n  // After profiling, data is requested from each attached renderer using this queue.\n  // So long as this queue is not empty, the store is retrieving and processing profiling data from the backend.\n  constructor(bridge, store, defaultIsProfiling) {\n    super();\n\n    _defineProperty(this, \"_dataBackends\", []);\n\n    _defineProperty(this, \"_dataFrontend\", null);\n\n    _defineProperty(this, \"_initialRendererIDs\", new Set());\n\n    _defineProperty(this, \"_initialSnapshotsByRootID\", new Map());\n\n    _defineProperty(this, \"_inProgressOperationsByRootID\", new Map());\n\n    _defineProperty(this, \"_isBackendProfiling\", false);\n\n    _defineProperty(this, \"_isProfilingBasedOnUserInput\", false);\n\n    _defineProperty(this, \"_rendererIDsThatReportedProfilingData\", new Set());\n\n    _defineProperty(this, \"_rendererQueue\", new Set());\n\n    _defineProperty(this, \"_takeProfilingSnapshotRecursive\", (elementID, profilingSnapshots) => {\n      const element = this._store.getElementByID(elementID);\n\n      if (element !== null) {\n        const snapshotNode = {\n          id: elementID,\n          children: element.children.slice(0),\n          displayName: element.displayName,\n          hocDisplayNames: element.hocDisplayNames,\n          key: element.key,\n          type: element.type,\n          compiledWithForget: element.compiledWithForget\n        };\n        profilingSnapshots.set(elementID, snapshotNode);\n        element.children.forEach(childID => this._takeProfilingSnapshotRecursive(childID, profilingSnapshots));\n      }\n    });\n\n    _defineProperty(this, \"onBridgeOperations\", operations => {\n      // The first two values are always rendererID and rootID\n      const rendererID = operations[0];\n      const rootID = operations[1];\n\n      if (this._isBackendProfiling) {\n        let profilingOperations = this._inProgressOperationsByRootID.get(rootID);\n\n        if (profilingOperations == null) {\n          profilingOperations = [operations];\n\n          this._inProgressOperationsByRootID.set(rootID, profilingOperations);\n        } else {\n          profilingOperations.push(operations);\n        }\n\n        if (!this._initialRendererIDs.has(rendererID)) {\n          this._initialRendererIDs.add(rendererID);\n        }\n\n        if (!this._initialSnapshotsByRootID.has(rootID)) {\n          this._initialSnapshotsByRootID.set(rootID, new Map());\n        }\n\n        this._rendererIDsThatReportedProfilingData.add(rendererID);\n      }\n    });\n\n    _defineProperty(this, \"onBridgeProfilingData\", dataBackend => {\n      if (this._isBackendProfiling) {\n        // This should never happen, but if it does, then ignore previous profiling data.\n        return;\n      }\n\n      const {\n        rendererID\n      } = dataBackend;\n\n      if (!this._rendererQueue.has(rendererID)) {\n        throw Error(`Unexpected profiling data update from renderer \"${rendererID}\"`);\n      }\n\n      this._dataBackends.push(dataBackend);\n\n      this._rendererQueue.delete(rendererID);\n\n      if (this._rendererQueue.size === 0) {\n        this._dataFrontend = (0,_views_Profiler_utils__WEBPACK_IMPORTED_MODULE_1__.prepareProfilingDataFrontendFromBackendAndStore)(this._dataBackends, this._inProgressOperationsByRootID, this._initialSnapshotsByRootID);\n\n        this._dataBackends.splice(0);\n\n        this.emit('isProcessingData');\n      }\n    });\n\n    _defineProperty(this, \"onBridgeShutdown\", () => {\n      this._bridge.removeListener('operations', this.onBridgeOperations);\n\n      this._bridge.removeListener('profilingData', this.onBridgeProfilingData);\n\n      this._bridge.removeListener('profilingStatus', this.onProfilingStatus);\n\n      this._bridge.removeListener('shutdown', this.onBridgeShutdown);\n    });\n\n    _defineProperty(this, \"onProfilingStatus\", isProfiling => {\n      if (this._isBackendProfiling === isProfiling) {\n        return;\n      }\n\n      if (isProfiling) {\n        this._dataBackends.splice(0);\n\n        this._dataFrontend = null;\n\n        this._initialRendererIDs.clear();\n\n        this._initialSnapshotsByRootID.clear();\n\n        this._inProgressOperationsByRootID.clear();\n\n        this._rendererIDsThatReportedProfilingData.clear();\n\n        this._rendererQueue.clear(); // Record all renderer IDs initially too (in case of unmount)\n        // eslint-disable-next-line no-for-of-loops/no-for-of-loops\n\n\n        for (const rendererID of this._store.rootIDToRendererID.values()) {\n          if (!this._initialRendererIDs.has(rendererID)) {\n            this._initialRendererIDs.add(rendererID);\n          }\n        } // Record snapshot of tree at the time profiling is started.\n        // This info is required to handle cases of e.g. nodes being removed during profiling.\n\n\n        this._store.roots.forEach(rootID => {\n          const profilingSnapshots = new Map();\n\n          this._initialSnapshotsByRootID.set(rootID, profilingSnapshots);\n\n          this._takeProfilingSnapshotRecursive(rootID, profilingSnapshots);\n        });\n      }\n\n      this._isBackendProfiling = isProfiling; // _isProfilingBasedOnUserInput should already be updated from startProfiling, stopProfiling, or constructor.\n\n      if (this._isProfilingBasedOnUserInput !== isProfiling) {\n        (0,react_devtools_shared_src_Logger__WEBPACK_IMPORTED_MODULE_4__.logEvent)({\n          event_name: 'error',\n          error_message: `Unexpected profiling status. Expected ${this._isProfilingBasedOnUserInput.toString()}, but received ${isProfiling.toString()}.`,\n          error_stack: new Error().stack,\n          error_component_stack: null\n        }); // If happened, fallback to displaying the value from Backend\n\n        this._isProfilingBasedOnUserInput = isProfiling;\n      } // Invalidate suspense cache if profiling data is being (re-)recorded.\n      // Note that we clear again, in case any views read from the cache while profiling.\n      // (That would have resolved a now-stale value without any profiling data.)\n\n\n      this._cache.invalidate(); // If we've just finished a profiling session, we need to fetch data stored in each renderer interface\n      // and re-assemble it on the front-end into a format (ProfilingDataFrontend) that can power the Profiler UI.\n      // During this time, DevTools UI should probably not be interactive.\n\n\n      if (!isProfiling) {\n        this._dataBackends.splice(0);\n\n        this._rendererQueue.clear(); // Only request data from renderers that actually logged it.\n        // This avoids unnecessary bridge requests and also avoids edge case mixed renderer bugs.\n        // (e.g. when v15 and v16 are both present)\n\n\n        this._rendererIDsThatReportedProfilingData.forEach(rendererID => {\n          if (!this._rendererQueue.has(rendererID)) {\n            this._rendererQueue.add(rendererID);\n\n            this._bridge.send('getProfilingData', {\n              rendererID\n            });\n          }\n        });\n\n        this.emit('isProcessingData');\n      }\n    });\n\n    this._bridge = bridge;\n    this._isBackendProfiling = defaultIsProfiling;\n    this._isProfilingBasedOnUserInput = defaultIsProfiling;\n    this._store = store;\n    bridge.addListener('operations', this.onBridgeOperations);\n    bridge.addListener('profilingData', this.onBridgeProfilingData);\n    bridge.addListener('profilingStatus', this.onProfilingStatus);\n    bridge.addListener('shutdown', this.onBridgeShutdown); // It's possible that profiling has already started (e.g. \"reload and start profiling\")\n    // so the frontend needs to ask the backend for its status after mounting.\n\n    bridge.send('getProfilingStatus');\n    this._cache = new _ProfilingCache__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n  }\n\n  getCommitData(rootID, commitIndex) {\n    if (this._dataFrontend !== null) {\n      const dataForRoot = this._dataFrontend.dataForRoots.get(rootID);\n\n      if (dataForRoot != null) {\n        const commitDatum = dataForRoot.commitData[commitIndex];\n\n        if (commitDatum != null) {\n          return commitDatum;\n        }\n      }\n    }\n\n    throw Error(`Could not find commit data for root \"${rootID}\" and commit \"${commitIndex}\"`);\n  }\n\n  getDataForRoot(rootID) {\n    if (this._dataFrontend !== null) {\n      const dataForRoot = this._dataFrontend.dataForRoots.get(rootID);\n\n      if (dataForRoot != null) {\n        return dataForRoot;\n      }\n    }\n\n    throw Error(`Could not find commit data for root \"${rootID}\"`);\n  } // Profiling data has been recorded for at least one root.\n\n\n  get didRecordCommits() {\n    return this._dataFrontend !== null && this._dataFrontend.dataForRoots.size > 0;\n  }\n\n  get isProcessingData() {\n    return this._rendererQueue.size > 0 || this._dataBackends.length > 0;\n  }\n\n  get isProfilingBasedOnUserInput() {\n    return this._isProfilingBasedOnUserInput;\n  }\n\n  get profilingCache() {\n    return this._cache;\n  }\n\n  get profilingData() {\n    return this._dataFrontend;\n  }\n\n  set profilingData(value) {\n    if (this._isBackendProfiling) {\n      console.warn('Profiling data cannot be updated while profiling is in progress.');\n      return;\n    }\n\n    this._dataBackends.splice(0);\n\n    this._dataFrontend = value;\n\n    this._initialRendererIDs.clear();\n\n    this._initialSnapshotsByRootID.clear();\n\n    this._inProgressOperationsByRootID.clear();\n\n    this._cache.invalidate();\n\n    this.emit('profilingData');\n  }\n\n  clear() {\n    this._dataBackends.splice(0);\n\n    this._dataFrontend = null;\n\n    this._initialRendererIDs.clear();\n\n    this._initialSnapshotsByRootID.clear();\n\n    this._inProgressOperationsByRootID.clear();\n\n    this._rendererQueue.clear(); // Invalidate suspense cache if profiling data is being (re-)recorded.\n    // Note that we clear now because any existing data is \"stale\".\n\n\n    this._cache.invalidate();\n\n    this.emit('profilingData');\n  }\n\n  startProfiling() {\n    this._bridge.send('startProfiling', {\n      recordChangeDescriptions: this._store.recordChangeDescriptions,\n      recordTimeline: this._store.supportsTimeline\n    });\n\n    this._isProfilingBasedOnUserInput = true;\n    this.emit('isProfiling'); // Don't actually update the local profiling boolean yet!\n    // Wait for onProfilingStatus() to confirm the status has changed.\n    // This ensures the frontend and backend are in sync wrt which commits were profiled.\n    // We do this to avoid mismatches on e.g. CommitTreeBuilder that would cause errors.\n  }\n\n  stopProfiling() {\n    this._bridge.send('stopProfiling'); // Backend might be busy serializing the payload, so we are going to display\n    // optimistic UI to the user that profiling is stopping.\n\n\n    this._isProfilingBasedOnUserInput = false;\n    this.emit('isProfiling'); // Wait for onProfilingStatus() to confirm the status has changed, this will update _isBackendProfiling.\n    // This ensures the frontend and backend are in sync wrt which commits were profiled.\n    // We do this to avoid mismatches on e.g. CommitTreeBuilder that would cause errors.\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy9Qcm9maWxlclN0b3JlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBT0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBS0E7QUFLQTs7QUFEQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTtBQXNJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBRUE7QUFHQTtBQUNBOztBQXZKQTtBQTBKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQWpMQTtBQXFMQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUdBOztBQUVBOztBQUNBOztBQUVBO0FBQ0E7O0FBTUE7O0FBRUE7QUFDQTtBQUNBOztBQWhOQTtBQW1OQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQXZOQTtBQTBOQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQVFBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUdBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBNVJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBR0E7OztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQTlMQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy9Qcm9maWxlclN0b3JlLmpzP2Q4Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHtwcmVwYXJlUHJvZmlsaW5nRGF0YUZyb250ZW5kRnJvbUJhY2tlbmRBbmRTdG9yZX0gZnJvbSAnLi92aWV3cy9Qcm9maWxlci91dGlscyc7XG5pbXBvcnQgUHJvZmlsaW5nQ2FjaGUgZnJvbSAnLi9Qcm9maWxpbmdDYWNoZSc7XG5pbXBvcnQgU3RvcmUgZnJvbSAnLi9zdG9yZSc7XG5pbXBvcnQge2xvZ0V2ZW50fSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL0xvZ2dlcic7XG5cbmltcG9ydCB0eXBlIHtGcm9udGVuZEJyaWRnZX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9icmlkZ2UnO1xuaW1wb3J0IHR5cGUge1Byb2ZpbGluZ0RhdGFCYWNrZW5kfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBDb21taXREYXRhRnJvbnRlbmQsXG4gIFByb2ZpbGluZ0RhdGFGb3JSb290RnJvbnRlbmQsXG4gIFByb2ZpbGluZ0RhdGFGcm9udGVuZCxcbiAgU25hcHNob3ROb2RlLFxufSBmcm9tICcuL3ZpZXdzL1Byb2ZpbGVyL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZmlsZXJTdG9yZSBleHRlbmRzIEV2ZW50RW1pdHRlcjx7XG4gIGlzUHJvY2Vzc2luZ0RhdGE6IFtdLFxuICBpc1Byb2ZpbGluZzogW10sXG4gIHByb2ZpbGluZ0RhdGE6IFtdLFxufT4ge1xuICBfYnJpZGdlOiBGcm9udGVuZEJyaWRnZTtcblxuICAvLyBTdXNwZW5zZSBjYWNoZSBmb3IgbGF6aWx5IGNhbGN1bGF0aW5nIGRlcml2ZWQgcHJvZmlsaW5nIGRhdGEuXG4gIF9jYWNoZTogUHJvZmlsaW5nQ2FjaGU7XG5cbiAgLy8gVGVtcG9yYXJ5IHN0b3JlIG9mIHByb2ZpbGluZyBkYXRhIGZyb20gdGhlIGJhY2tlbmQgcmVuZGVyZXIocykuXG4gIC8vIFRoaXMgZGF0YSB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgUHJvZmlsaW5nRGF0YUZyb250ZW5kIGZvcm1hdCBhZnRlciBiZWluZyBjb2xsZWN0ZWQgZnJvbSBhbGwgcmVuZGVyZXJzLlxuICBfZGF0YUJhY2tlbmRzOiBBcnJheTxQcm9maWxpbmdEYXRhQmFja2VuZD4gPSBbXTtcblxuICAvLyBEYXRhIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgY29tcGxldGVkIHByb2ZpbGluZyBzZXNzaW9uLFxuICAvLyBvciBkYXRhIHRoYXQgaGFzIGJlZW4gaW1wb3J0ZWQgZnJvbSBhIHByZXZpb3VzbHkgZXhwb3J0ZWQgc2Vzc2lvbi5cbiAgLy8gVGhpcyBvYmplY3QgY29udGFpbnMgYWxsIG5lY2Vzc2FyeSBkYXRhIHRvIGRyaXZlIHRoZSBQcm9maWxlciBVSSBpbnRlcmZhY2UsXG4gIC8vIGV2ZW4gdGhvdWdoIHNvbWUgb2YgaXQgaXMgbGF6aWx5IHBhcnNlZC9kZXJpdmVkIHZpYSB0aGUgUHJvZmlsaW5nQ2FjaGUuXG4gIF9kYXRhRnJvbnRlbmQ6IFByb2ZpbGluZ0RhdGFGcm9udGVuZCB8IG51bGwgPSBudWxsO1xuXG4gIC8vIFNuYXBzaG90IG9mIGFsbCBhdHRhY2hlZCByZW5kZXJlciBJRHMuXG4gIC8vIE9uY2UgcHJvZmlsaW5nIGlzIGZpbmlzaGVkLCB0aGlzIHNuYXBzaG90IHdpbGwgYmUgdXNlZCB0byBxdWVyeSByZW5kZXJlcnMgZm9yIHByb2ZpbGluZyBkYXRhLlxuICAvL1xuICAvLyBUaGlzIG1hcCBpcyBpbml0aWFsaXplZCB3aGVuIHByb2ZpbGluZyBzdGFydHMgYW5kIHVwZGF0ZWQgd2hlbiBhIG5ldyByb290IGlzIGFkZGVkIHdoaWxlIHByb2ZpbGluZztcbiAgLy8gVXBvbiBjb21wbGV0aW9uLCBpdCBpcyBjb252ZXJ0ZWQgaW50byB0aGUgZXhwb3J0YWJsZSBQcm9maWxpbmdEYXRhRnJvbnRlbmQgZm9ybWF0LlxuICBfaW5pdGlhbFJlbmRlcmVySURzOiBTZXQ8bnVtYmVyPiA9IG5ldyBTZXQoKTtcblxuICAvLyBTbmFwc2hvdCBvZiB0aGUgc3RhdGUgb2YgdGhlIG1haW4gU3RvcmUgKGluY2x1ZGluZyBhbGwgcm9vdHMpIHdoZW4gcHJvZmlsaW5nIHN0YXJ0ZWQuXG4gIC8vIE9uY2UgcHJvZmlsaW5nIGlzIGZpbmlzaGVkLCB0aGlzIHNuYXBzaG90IGNhbiBiZSB1c2VkIGFsb25nIHdpdGggXCJvcGVyYXRpb25zXCIgbWVzc2FnZXMgZW1pdHRlZCBkdXJpbmcgcHJvZmlsaW5nLFxuICAvLyB0byByZWNvbnN0cnVjdCB0aGUgc3RhdGUgb2YgZWFjaCByb290IGZvciBlYWNoIGNvbW1pdC5cbiAgLy8gSXQncyBva2F5IHRvIHVzZSBhIHNpbmdsZSByb290IHRvIHN0b3JlIHRoaXMgaW5mb3JtYXRpb24gYmVjYXVzZSBub2RlIElEcyBhcmUgdW5pcXVlIGFjcm9zcyBhbGwgcm9vdHMuXG4gIC8vXG4gIC8vIFRoaXMgbWFwIGlzIGluaXRpYWxpemVkIHdoZW4gcHJvZmlsaW5nIHN0YXJ0cyBhbmQgdXBkYXRlZCB3aGVuIGEgbmV3IHJvb3QgaXMgYWRkZWQgd2hpbGUgcHJvZmlsaW5nO1xuICAvLyBVcG9uIGNvbXBsZXRpb24sIGl0IGlzIGNvbnZlcnRlZCBpbnRvIHRoZSBleHBvcnRhYmxlIFByb2ZpbGluZ0RhdGFGcm9udGVuZCBmb3JtYXQuXG4gIF9pbml0aWFsU25hcHNob3RzQnlSb290SUQ6IE1hcDxudW1iZXIsIE1hcDxudW1iZXIsIFNuYXBzaG90Tm9kZT4+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIE1hcCBvZiByb290IChpZCkgdG8gYSBsaXN0IG9mIHRyZWUgbXV0YXRpb24gdGhhdCBvY2N1ciBkdXJpbmcgcHJvZmlsaW5nLlxuICAvLyBPbmNlIHByb2ZpbGluZyBpcyBmaW5pc2hlZCwgdGhlc2UgbXV0YXRpb25zIGNhbiBiZSB1c2VkLCBhbG9uZyB3aXRoIHRoZSBpbml0aWFsIHRyZWUgc25hcHNob3RzLFxuICAvLyB0byByZWNvbnN0cnVjdCB0aGUgc3RhdGUgb2YgZWFjaCByb290IGZvciBlYWNoIGNvbW1pdC5cbiAgLy9cbiAgLy8gVGhpcyBtYXAgaXMgb25seSB1cGRhdGVkIHdoaWxlIHByb2ZpbGluZyBpcyBpbiBwcm9ncmVzcztcbiAgLy8gVXBvbiBjb21wbGV0aW9uLCBpdCBpcyBjb252ZXJ0ZWQgaW50byB0aGUgZXhwb3J0YWJsZSBQcm9maWxpbmdEYXRhRnJvbnRlbmQgZm9ybWF0LlxuICBfaW5Qcm9ncmVzc09wZXJhdGlvbnNCeVJvb3RJRDogTWFwPG51bWJlciwgQXJyYXk8QXJyYXk8bnVtYmVyPj4+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRoZSBiYWNrZW5kIGlzIGN1cnJlbnRseSBwcm9maWxpbmcuXG4gIC8vIFdoZW4gcHJvZmlsaW5nIGlzIGluIHByb2dyZXNzLCBvcGVyYXRpb25zIGFyZSBzdG9yZWQgc28gdGhhdCB3ZSBjYW4gbGF0ZXIgcmVjb25zdHJ1Y3QgcGFzdCBjb21taXQgdHJlZXMuXG4gIF9pc0JhY2tlbmRQcm9maWxpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBNYWlubHkgdXNlZCBmb3Igb3B0aW1pc3RpYyBVSS5cbiAgLy8gVGhpcyBjb3VsZCBiZSBmYWxzZSwgYnV0IGF0IHRoZSBzYW1lIHRpbWUgX2lzQmFja2VuZFByb2ZpbGluZyBjb3VsZCBiZSB0cnVlXG4gIC8vIGZvciBjYXNlcyB3aGVuIEJhY2tlbmQgaXMgYnVzeSBzZXJpYWxpemluZyBhIGNodW5reSBwYXlsb2FkLlxuICBfaXNQcm9maWxpbmdCYXNlZE9uVXNlcklucHV0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gVHJhY2tzIHdoZXRoZXIgYSBzcGVjaWZpYyByZW5kZXJlciBsb2dnZWQgYW55IHByb2ZpbGluZyBkYXRhIGR1cmluZyB0aGUgbW9zdCByZWNlbnQgc2Vzc2lvbi5cbiAgX3JlbmRlcmVySURzVGhhdFJlcG9ydGVkUHJvZmlsaW5nRGF0YTogU2V0PG51bWJlcj4gPSBuZXcgU2V0KCk7XG5cbiAgLy8gQWZ0ZXIgcHJvZmlsaW5nLCBkYXRhIGlzIHJlcXVlc3RlZCBmcm9tIGVhY2ggYXR0YWNoZWQgcmVuZGVyZXIgdXNpbmcgdGhpcyBxdWV1ZS5cbiAgLy8gU28gbG9uZyBhcyB0aGlzIHF1ZXVlIGlzIG5vdCBlbXB0eSwgdGhlIHN0b3JlIGlzIHJldHJpZXZpbmcgYW5kIHByb2Nlc3NpbmcgcHJvZmlsaW5nIGRhdGEgZnJvbSB0aGUgYmFja2VuZC5cbiAgX3JlbmRlcmVyUXVldWU6IFNldDxudW1iZXI+ID0gbmV3IFNldCgpO1xuXG4gIF9zdG9yZTogU3RvcmU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgYnJpZGdlOiBGcm9udGVuZEJyaWRnZSxcbiAgICBzdG9yZTogU3RvcmUsXG4gICAgZGVmYXVsdElzUHJvZmlsaW5nOiBib29sZWFuLFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYnJpZGdlID0gYnJpZGdlO1xuICAgIHRoaXMuX2lzQmFja2VuZFByb2ZpbGluZyA9IGRlZmF1bHRJc1Byb2ZpbGluZztcbiAgICB0aGlzLl9pc1Byb2ZpbGluZ0Jhc2VkT25Vc2VySW5wdXQgPSBkZWZhdWx0SXNQcm9maWxpbmc7XG4gICAgdGhpcy5fc3RvcmUgPSBzdG9yZTtcblxuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3BlcmF0aW9ucycsIHRoaXMub25CcmlkZ2VPcGVyYXRpb25zKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3Byb2ZpbGluZ0RhdGEnLCB0aGlzLm9uQnJpZGdlUHJvZmlsaW5nRGF0YSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdwcm9maWxpbmdTdGF0dXMnLCB0aGlzLm9uUHJvZmlsaW5nU3RhdHVzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgdGhpcy5vbkJyaWRnZVNodXRkb3duKTtcblxuICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCBwcm9maWxpbmcgaGFzIGFscmVhZHkgc3RhcnRlZCAoZS5nLiBcInJlbG9hZCBhbmQgc3RhcnQgcHJvZmlsaW5nXCIpXG4gICAgLy8gc28gdGhlIGZyb250ZW5kIG5lZWRzIHRvIGFzayB0aGUgYmFja2VuZCBmb3IgaXRzIHN0YXR1cyBhZnRlciBtb3VudGluZy5cbiAgICBicmlkZ2Uuc2VuZCgnZ2V0UHJvZmlsaW5nU3RhdHVzJyk7XG5cbiAgICB0aGlzLl9jYWNoZSA9IG5ldyBQcm9maWxpbmdDYWNoZSh0aGlzKTtcbiAgfVxuXG4gIGdldENvbW1pdERhdGEocm9vdElEOiBudW1iZXIsIGNvbW1pdEluZGV4OiBudW1iZXIpOiBDb21taXREYXRhRnJvbnRlbmQge1xuICAgIGlmICh0aGlzLl9kYXRhRnJvbnRlbmQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGRhdGFGb3JSb290ID0gdGhpcy5fZGF0YUZyb250ZW5kLmRhdGFGb3JSb290cy5nZXQocm9vdElEKTtcbiAgICAgIGlmIChkYXRhRm9yUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbW1pdERhdHVtID0gZGF0YUZvclJvb3QuY29tbWl0RGF0YVtjb21taXRJbmRleF07XG4gICAgICAgIGlmIChjb21taXREYXR1bSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1pdERhdHVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBgQ291bGQgbm90IGZpbmQgY29tbWl0IGRhdGEgZm9yIHJvb3QgXCIke3Jvb3RJRH1cIiBhbmQgY29tbWl0IFwiJHtjb21taXRJbmRleH1cImAsXG4gICAgKTtcbiAgfVxuXG4gIGdldERhdGFGb3JSb290KHJvb3RJRDogbnVtYmVyKTogUHJvZmlsaW5nRGF0YUZvclJvb3RGcm9udGVuZCB7XG4gICAgaWYgKHRoaXMuX2RhdGFGcm9udGVuZCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZGF0YUZvclJvb3QgPSB0aGlzLl9kYXRhRnJvbnRlbmQuZGF0YUZvclJvb3RzLmdldChyb290SUQpO1xuICAgICAgaWYgKGRhdGFGb3JSb290ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFGb3JSb290O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgZmluZCBjb21taXQgZGF0YSBmb3Igcm9vdCBcIiR7cm9vdElEfVwiYCk7XG4gIH1cblxuICAvLyBQcm9maWxpbmcgZGF0YSBoYXMgYmVlbiByZWNvcmRlZCBmb3IgYXQgbGVhc3Qgb25lIHJvb3QuXG4gIGdldCBkaWRSZWNvcmRDb21taXRzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9kYXRhRnJvbnRlbmQgIT09IG51bGwgJiYgdGhpcy5fZGF0YUZyb250ZW5kLmRhdGFGb3JSb290cy5zaXplID4gMFxuICAgICk7XG4gIH1cblxuICBnZXQgaXNQcm9jZXNzaW5nRGF0YSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXJRdWV1ZS5zaXplID4gMCB8fCB0aGlzLl9kYXRhQmFja2VuZHMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIGdldCBpc1Byb2ZpbGluZ0Jhc2VkT25Vc2VySW5wdXQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUHJvZmlsaW5nQmFzZWRPblVzZXJJbnB1dDtcbiAgfVxuXG4gIGdldCBwcm9maWxpbmdDYWNoZSgpOiBQcm9maWxpbmdDYWNoZSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICB9XG5cbiAgZ2V0IHByb2ZpbGluZ0RhdGEoKTogUHJvZmlsaW5nRGF0YUZyb250ZW5kIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFGcm9udGVuZDtcbiAgfVxuICBzZXQgcHJvZmlsaW5nRGF0YSh2YWx1ZTogUHJvZmlsaW5nRGF0YUZyb250ZW5kIHwgbnVsbCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9pc0JhY2tlbmRQcm9maWxpbmcpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1Byb2ZpbGluZyBkYXRhIGNhbm5vdCBiZSB1cGRhdGVkIHdoaWxlIHByb2ZpbGluZyBpcyBpbiBwcm9ncmVzcy4nLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhQmFja2VuZHMuc3BsaWNlKDApO1xuICAgIHRoaXMuX2RhdGFGcm9udGVuZCA9IHZhbHVlO1xuICAgIHRoaXMuX2luaXRpYWxSZW5kZXJlcklEcy5jbGVhcigpO1xuICAgIHRoaXMuX2luaXRpYWxTbmFwc2hvdHNCeVJvb3RJRC5jbGVhcigpO1xuICAgIHRoaXMuX2luUHJvZ3Jlc3NPcGVyYXRpb25zQnlSb290SUQuY2xlYXIoKTtcbiAgICB0aGlzLl9jYWNoZS5pbnZhbGlkYXRlKCk7XG5cbiAgICB0aGlzLmVtaXQoJ3Byb2ZpbGluZ0RhdGEnKTtcbiAgfVxuXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuX2RhdGFCYWNrZW5kcy5zcGxpY2UoMCk7XG4gICAgdGhpcy5fZGF0YUZyb250ZW5kID0gbnVsbDtcbiAgICB0aGlzLl9pbml0aWFsUmVuZGVyZXJJRHMuY2xlYXIoKTtcbiAgICB0aGlzLl9pbml0aWFsU25hcHNob3RzQnlSb290SUQuY2xlYXIoKTtcbiAgICB0aGlzLl9pblByb2dyZXNzT3BlcmF0aW9uc0J5Um9vdElELmNsZWFyKCk7XG4gICAgdGhpcy5fcmVuZGVyZXJRdWV1ZS5jbGVhcigpO1xuXG4gICAgLy8gSW52YWxpZGF0ZSBzdXNwZW5zZSBjYWNoZSBpZiBwcm9maWxpbmcgZGF0YSBpcyBiZWluZyAocmUtKXJlY29yZGVkLlxuICAgIC8vIE5vdGUgdGhhdCB3ZSBjbGVhciBub3cgYmVjYXVzZSBhbnkgZXhpc3RpbmcgZGF0YSBpcyBcInN0YWxlXCIuXG4gICAgdGhpcy5fY2FjaGUuaW52YWxpZGF0ZSgpO1xuXG4gICAgdGhpcy5lbWl0KCdwcm9maWxpbmdEYXRhJyk7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnc3RhcnRQcm9maWxpbmcnLCB7XG4gICAgICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM6IHRoaXMuX3N0b3JlLnJlY29yZENoYW5nZURlc2NyaXB0aW9ucyxcbiAgICAgIHJlY29yZFRpbWVsaW5lOiB0aGlzLl9zdG9yZS5zdXBwb3J0c1RpbWVsaW5lLFxuICAgIH0pO1xuXG4gICAgdGhpcy5faXNQcm9maWxpbmdCYXNlZE9uVXNlcklucHV0ID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2lzUHJvZmlsaW5nJyk7XG5cbiAgICAvLyBEb24ndCBhY3R1YWxseSB1cGRhdGUgdGhlIGxvY2FsIHByb2ZpbGluZyBib29sZWFuIHlldCFcbiAgICAvLyBXYWl0IGZvciBvblByb2ZpbGluZ1N0YXR1cygpIHRvIGNvbmZpcm0gdGhlIHN0YXR1cyBoYXMgY2hhbmdlZC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIGZyb250ZW5kIGFuZCBiYWNrZW5kIGFyZSBpbiBzeW5jIHdydCB3aGljaCBjb21taXRzIHdlcmUgcHJvZmlsZWQuXG4gICAgLy8gV2UgZG8gdGhpcyB0byBhdm9pZCBtaXNtYXRjaGVzIG9uIGUuZy4gQ29tbWl0VHJlZUJ1aWxkZXIgdGhhdCB3b3VsZCBjYXVzZSBlcnJvcnMuXG4gIH1cblxuICBzdG9wUHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuX2JyaWRnZS5zZW5kKCdzdG9wUHJvZmlsaW5nJyk7XG5cbiAgICAvLyBCYWNrZW5kIG1pZ2h0IGJlIGJ1c3kgc2VyaWFsaXppbmcgdGhlIHBheWxvYWQsIHNvIHdlIGFyZSBnb2luZyB0byBkaXNwbGF5XG4gICAgLy8gb3B0aW1pc3RpYyBVSSB0byB0aGUgdXNlciB0aGF0IHByb2ZpbGluZyBpcyBzdG9wcGluZy5cbiAgICB0aGlzLl9pc1Byb2ZpbGluZ0Jhc2VkT25Vc2VySW5wdXQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2lzUHJvZmlsaW5nJyk7XG5cbiAgICAvLyBXYWl0IGZvciBvblByb2ZpbGluZ1N0YXR1cygpIHRvIGNvbmZpcm0gdGhlIHN0YXR1cyBoYXMgY2hhbmdlZCwgdGhpcyB3aWxsIHVwZGF0ZSBfaXNCYWNrZW5kUHJvZmlsaW5nLlxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgZnJvbnRlbmQgYW5kIGJhY2tlbmQgYXJlIGluIHN5bmMgd3J0IHdoaWNoIGNvbW1pdHMgd2VyZSBwcm9maWxlZC5cbiAgICAvLyBXZSBkbyB0aGlzIHRvIGF2b2lkIG1pc21hdGNoZXMgb24gZS5nLiBDb21taXRUcmVlQnVpbGRlciB0aGF0IHdvdWxkIGNhdXNlIGVycm9ycy5cbiAgfVxuXG4gIF90YWtlUHJvZmlsaW5nU25hcHNob3RSZWN1cnNpdmU6IChcbiAgICBlbGVtZW50SUQ6IG51bWJlcixcbiAgICBwcm9maWxpbmdTbmFwc2hvdHM6IE1hcDxudW1iZXIsIFNuYXBzaG90Tm9kZT4sXG4gICkgPT4gdm9pZCA9IChlbGVtZW50SUQsIHByb2ZpbGluZ1NuYXBzaG90cykgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9zdG9yZS5nZXRFbGVtZW50QnlJRChlbGVtZW50SUQpO1xuICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzbmFwc2hvdE5vZGU6IFNuYXBzaG90Tm9kZSA9IHtcbiAgICAgICAgaWQ6IGVsZW1lbnRJRCxcbiAgICAgICAgY2hpbGRyZW46IGVsZW1lbnQuY2hpbGRyZW4uc2xpY2UoMCksXG4gICAgICAgIGRpc3BsYXlOYW1lOiBlbGVtZW50LmRpc3BsYXlOYW1lLFxuICAgICAgICBob2NEaXNwbGF5TmFtZXM6IGVsZW1lbnQuaG9jRGlzcGxheU5hbWVzLFxuICAgICAgICBrZXk6IGVsZW1lbnQua2V5LFxuICAgICAgICB0eXBlOiBlbGVtZW50LnR5cGUsXG4gICAgICAgIGNvbXBpbGVkV2l0aEZvcmdldDogZWxlbWVudC5jb21waWxlZFdpdGhGb3JnZXQsXG4gICAgICB9O1xuICAgICAgcHJvZmlsaW5nU25hcHNob3RzLnNldChlbGVtZW50SUQsIHNuYXBzaG90Tm9kZSk7XG5cbiAgICAgIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaChjaGlsZElEID0+XG4gICAgICAgIHRoaXMuX3Rha2VQcm9maWxpbmdTbmFwc2hvdFJlY3Vyc2l2ZShjaGlsZElELCBwcm9maWxpbmdTbmFwc2hvdHMpLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgb25CcmlkZ2VPcGVyYXRpb25zOiAob3BlcmF0aW9uczogQXJyYXk8bnVtYmVyPikgPT4gdm9pZCA9IG9wZXJhdGlvbnMgPT4ge1xuICAgIC8vIFRoZSBmaXJzdCB0d28gdmFsdWVzIGFyZSBhbHdheXMgcmVuZGVyZXJJRCBhbmQgcm9vdElEXG4gICAgY29uc3QgcmVuZGVyZXJJRCA9IG9wZXJhdGlvbnNbMF07XG4gICAgY29uc3Qgcm9vdElEID0gb3BlcmF0aW9uc1sxXTtcblxuICAgIGlmICh0aGlzLl9pc0JhY2tlbmRQcm9maWxpbmcpIHtcbiAgICAgIGxldCBwcm9maWxpbmdPcGVyYXRpb25zID0gdGhpcy5faW5Qcm9ncmVzc09wZXJhdGlvbnNCeVJvb3RJRC5nZXQocm9vdElEKTtcbiAgICAgIGlmIChwcm9maWxpbmdPcGVyYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgcHJvZmlsaW5nT3BlcmF0aW9ucyA9IFtvcGVyYXRpb25zXTtcbiAgICAgICAgdGhpcy5faW5Qcm9ncmVzc09wZXJhdGlvbnNCeVJvb3RJRC5zZXQocm9vdElELCBwcm9maWxpbmdPcGVyYXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2ZpbGluZ09wZXJhdGlvbnMucHVzaChvcGVyYXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbml0aWFsUmVuZGVyZXJJRHMuaGFzKHJlbmRlcmVySUQpKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxSZW5kZXJlcklEcy5hZGQocmVuZGVyZXJJRCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5pdGlhbFNuYXBzaG90c0J5Um9vdElELmhhcyhyb290SUQpKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxTbmFwc2hvdHNCeVJvb3RJRC5zZXQocm9vdElELCBuZXcgTWFwKCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlcklEc1RoYXRSZXBvcnRlZFByb2ZpbGluZ0RhdGEuYWRkKHJlbmRlcmVySUQpO1xuICAgIH1cbiAgfTtcblxuICBvbkJyaWRnZVByb2ZpbGluZ0RhdGE6IChkYXRhQmFja2VuZDogUHJvZmlsaW5nRGF0YUJhY2tlbmQpID0+IHZvaWQgPVxuICAgIGRhdGFCYWNrZW5kID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc0JhY2tlbmRQcm9maWxpbmcpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgaWYgaXQgZG9lcywgdGhlbiBpZ25vcmUgcHJldmlvdXMgcHJvZmlsaW5nIGRhdGEuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge3JlbmRlcmVySUR9ID0gZGF0YUJhY2tlbmQ7XG5cbiAgICAgIGlmICghdGhpcy5fcmVuZGVyZXJRdWV1ZS5oYXMocmVuZGVyZXJJRCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgYFVuZXhwZWN0ZWQgcHJvZmlsaW5nIGRhdGEgdXBkYXRlIGZyb20gcmVuZGVyZXIgXCIke3JlbmRlcmVySUR9XCJgLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kYXRhQmFja2VuZHMucHVzaChkYXRhQmFja2VuZCk7XG4gICAgICB0aGlzLl9yZW5kZXJlclF1ZXVlLmRlbGV0ZShyZW5kZXJlcklEKTtcblxuICAgICAgaWYgKHRoaXMuX3JlbmRlcmVyUXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kYXRhRnJvbnRlbmQgPSBwcmVwYXJlUHJvZmlsaW5nRGF0YUZyb250ZW5kRnJvbUJhY2tlbmRBbmRTdG9yZShcbiAgICAgICAgICB0aGlzLl9kYXRhQmFja2VuZHMsXG4gICAgICAgICAgdGhpcy5faW5Qcm9ncmVzc09wZXJhdGlvbnNCeVJvb3RJRCxcbiAgICAgICAgICB0aGlzLl9pbml0aWFsU25hcHNob3RzQnlSb290SUQsXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fZGF0YUJhY2tlbmRzLnNwbGljZSgwKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ2lzUHJvY2Vzc2luZ0RhdGEnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIG9uQnJpZGdlU2h1dGRvd246ICgpID0+IHZvaWQgPSAoKSA9PiB7XG4gICAgdGhpcy5fYnJpZGdlLnJlbW92ZUxpc3RlbmVyKCdvcGVyYXRpb25zJywgdGhpcy5vbkJyaWRnZU9wZXJhdGlvbnMpO1xuICAgIHRoaXMuX2JyaWRnZS5yZW1vdmVMaXN0ZW5lcigncHJvZmlsaW5nRGF0YScsIHRoaXMub25CcmlkZ2VQcm9maWxpbmdEYXRhKTtcbiAgICB0aGlzLl9icmlkZ2UucmVtb3ZlTGlzdGVuZXIoJ3Byb2ZpbGluZ1N0YXR1cycsIHRoaXMub25Qcm9maWxpbmdTdGF0dXMpO1xuICAgIHRoaXMuX2JyaWRnZS5yZW1vdmVMaXN0ZW5lcignc2h1dGRvd24nLCB0aGlzLm9uQnJpZGdlU2h1dGRvd24pO1xuICB9O1xuXG4gIG9uUHJvZmlsaW5nU3RhdHVzOiAoaXNQcm9maWxpbmc6IGJvb2xlYW4pID0+IHZvaWQgPSBpc1Byb2ZpbGluZyA9PiB7XG4gICAgaWYgKHRoaXMuX2lzQmFja2VuZFByb2ZpbGluZyA9PT0gaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHRoaXMuX2RhdGFCYWNrZW5kcy5zcGxpY2UoMCk7XG4gICAgICB0aGlzLl9kYXRhRnJvbnRlbmQgPSBudWxsO1xuICAgICAgdGhpcy5faW5pdGlhbFJlbmRlcmVySURzLmNsZWFyKCk7XG4gICAgICB0aGlzLl9pbml0aWFsU25hcHNob3RzQnlSb290SUQuY2xlYXIoKTtcbiAgICAgIHRoaXMuX2luUHJvZ3Jlc3NPcGVyYXRpb25zQnlSb290SUQuY2xlYXIoKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVySURzVGhhdFJlcG9ydGVkUHJvZmlsaW5nRGF0YS5jbGVhcigpO1xuICAgICAgdGhpcy5fcmVuZGVyZXJRdWV1ZS5jbGVhcigpO1xuXG4gICAgICAvLyBSZWNvcmQgYWxsIHJlbmRlcmVyIElEcyBpbml0aWFsbHkgdG9vIChpbiBjYXNlIG9mIHVubW91bnQpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgICAgZm9yIChjb25zdCByZW5kZXJlcklEIG9mIHRoaXMuX3N0b3JlLnJvb3RJRFRvUmVuZGVyZXJJRC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxSZW5kZXJlcklEcy5oYXMocmVuZGVyZXJJRCkpIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsUmVuZGVyZXJJRHMuYWRkKHJlbmRlcmVySUQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlY29yZCBzbmFwc2hvdCBvZiB0cmVlIGF0IHRoZSB0aW1lIHByb2ZpbGluZyBpcyBzdGFydGVkLlxuICAgICAgLy8gVGhpcyBpbmZvIGlzIHJlcXVpcmVkIHRvIGhhbmRsZSBjYXNlcyBvZiBlLmcuIG5vZGVzIGJlaW5nIHJlbW92ZWQgZHVyaW5nIHByb2ZpbGluZy5cbiAgICAgIHRoaXMuX3N0b3JlLnJvb3RzLmZvckVhY2gocm9vdElEID0+IHtcbiAgICAgICAgY29uc3QgcHJvZmlsaW5nU25hcHNob3RzID0gbmV3IE1hcDxudW1iZXIsIFNuYXBzaG90Tm9kZT4oKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbFNuYXBzaG90c0J5Um9vdElELnNldChyb290SUQsIHByb2ZpbGluZ1NuYXBzaG90cyk7XG4gICAgICAgIHRoaXMuX3Rha2VQcm9maWxpbmdTbmFwc2hvdFJlY3Vyc2l2ZShyb290SUQsIHByb2ZpbGluZ1NuYXBzaG90cyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0JhY2tlbmRQcm9maWxpbmcgPSBpc1Byb2ZpbGluZztcbiAgICAvLyBfaXNQcm9maWxpbmdCYXNlZE9uVXNlcklucHV0IHNob3VsZCBhbHJlYWR5IGJlIHVwZGF0ZWQgZnJvbSBzdGFydFByb2ZpbGluZywgc3RvcFByb2ZpbGluZywgb3IgY29uc3RydWN0b3IuXG4gICAgaWYgKHRoaXMuX2lzUHJvZmlsaW5nQmFzZWRPblVzZXJJbnB1dCAhPT0gaXNQcm9maWxpbmcpIHtcbiAgICAgIGxvZ0V2ZW50KHtcbiAgICAgICAgZXZlbnRfbmFtZTogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3JfbWVzc2FnZTogYFVuZXhwZWN0ZWQgcHJvZmlsaW5nIHN0YXR1cy4gRXhwZWN0ZWQgJHt0aGlzLl9pc1Byb2ZpbGluZ0Jhc2VkT25Vc2VySW5wdXQudG9TdHJpbmcoKX0sIGJ1dCByZWNlaXZlZCAke2lzUHJvZmlsaW5nLnRvU3RyaW5nKCl9LmAsXG4gICAgICAgIGVycm9yX3N0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayxcbiAgICAgICAgZXJyb3JfY29tcG9uZW50X3N0YWNrOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIGhhcHBlbmVkLCBmYWxsYmFjayB0byBkaXNwbGF5aW5nIHRoZSB2YWx1ZSBmcm9tIEJhY2tlbmRcbiAgICAgIHRoaXMuX2lzUHJvZmlsaW5nQmFzZWRPblVzZXJJbnB1dCA9IGlzUHJvZmlsaW5nO1xuICAgIH1cblxuICAgIC8vIEludmFsaWRhdGUgc3VzcGVuc2UgY2FjaGUgaWYgcHJvZmlsaW5nIGRhdGEgaXMgYmVpbmcgKHJlLSlyZWNvcmRlZC5cbiAgICAvLyBOb3RlIHRoYXQgd2UgY2xlYXIgYWdhaW4sIGluIGNhc2UgYW55IHZpZXdzIHJlYWQgZnJvbSB0aGUgY2FjaGUgd2hpbGUgcHJvZmlsaW5nLlxuICAgIC8vIChUaGF0IHdvdWxkIGhhdmUgcmVzb2x2ZWQgYSBub3ctc3RhbGUgdmFsdWUgd2l0aG91dCBhbnkgcHJvZmlsaW5nIGRhdGEuKVxuICAgIHRoaXMuX2NhY2hlLmludmFsaWRhdGUoKTtcblxuICAgIC8vIElmIHdlJ3ZlIGp1c3QgZmluaXNoZWQgYSBwcm9maWxpbmcgc2Vzc2lvbiwgd2UgbmVlZCB0byBmZXRjaCBkYXRhIHN0b3JlZCBpbiBlYWNoIHJlbmRlcmVyIGludGVyZmFjZVxuICAgIC8vIGFuZCByZS1hc3NlbWJsZSBpdCBvbiB0aGUgZnJvbnQtZW5kIGludG8gYSBmb3JtYXQgKFByb2ZpbGluZ0RhdGFGcm9udGVuZCkgdGhhdCBjYW4gcG93ZXIgdGhlIFByb2ZpbGVyIFVJLlxuICAgIC8vIER1cmluZyB0aGlzIHRpbWUsIERldlRvb2xzIFVJIHNob3VsZCBwcm9iYWJseSBub3QgYmUgaW50ZXJhY3RpdmUuXG4gICAgaWYgKCFpc1Byb2ZpbGluZykge1xuICAgICAgdGhpcy5fZGF0YUJhY2tlbmRzLnNwbGljZSgwKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyUXVldWUuY2xlYXIoKTtcblxuICAgICAgLy8gT25seSByZXF1ZXN0IGRhdGEgZnJvbSByZW5kZXJlcnMgdGhhdCBhY3R1YWxseSBsb2dnZWQgaXQuXG4gICAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyeSBicmlkZ2UgcmVxdWVzdHMgYW5kIGFsc28gYXZvaWRzIGVkZ2UgY2FzZSBtaXhlZCByZW5kZXJlciBidWdzLlxuICAgICAgLy8gKGUuZy4gd2hlbiB2MTUgYW5kIHYxNiBhcmUgYm90aCBwcmVzZW50KVxuICAgICAgdGhpcy5fcmVuZGVyZXJJRHNUaGF0UmVwb3J0ZWRQcm9maWxpbmdEYXRhLmZvckVhY2gocmVuZGVyZXJJRCA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXJRdWV1ZS5oYXMocmVuZGVyZXJJRCkpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlclF1ZXVlLmFkZChyZW5kZXJlcklEKTtcblxuICAgICAgICAgIHRoaXMuX2JyaWRnZS5zZW5kKCdnZXRQcm9maWxpbmdEYXRhJywge3JlbmRlcmVySUR9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZW1pdCgnaXNQcm9jZXNzaW5nRGF0YScpO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/ProfilerStore.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/ProfilingCache.js":
/*!***************************************************************!*\
  !*** ../react-devtools-shared/src/devtools/ProfilingCache.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ProfilingCache)\n/* harmony export */ });\n/* harmony import */ var _ProfilerStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ProfilerStore */ \"../react-devtools-shared/src/devtools/ProfilerStore.js\");\n/* harmony import */ var react_devtools_shared_src_devtools_views_Profiler_CommitTreeBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/devtools/views/Profiler/CommitTreeBuilder */ \"../react-devtools-shared/src/devtools/views/Profiler/CommitTreeBuilder.js\");\n/* harmony import */ var react_devtools_shared_src_devtools_views_Profiler_FlamegraphChartBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/devtools/views/Profiler/FlamegraphChartBuilder */ \"../react-devtools-shared/src/devtools/views/Profiler/FlamegraphChartBuilder.js\");\n/* harmony import */ var react_devtools_shared_src_devtools_views_Profiler_RankedChartBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-shared/src/devtools/views/Profiler/RankedChartBuilder */ \"../react-devtools-shared/src/devtools/views/Profiler/RankedChartBuilder.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\nclass ProfilingCache {\n  constructor(profilerStore) {\n    _defineProperty(this, \"_fiberCommits\", new Map());\n\n    _defineProperty(this, \"getCommitTree\", ({\n      commitIndex,\n      rootID\n    }) => (0,react_devtools_shared_src_devtools_views_Profiler_CommitTreeBuilder__WEBPACK_IMPORTED_MODULE_1__.getCommitTree)({\n      commitIndex,\n      profilerStore: this._profilerStore,\n      rootID\n    }));\n\n    _defineProperty(this, \"getFiberCommits\", ({\n      fiberID,\n      rootID\n    }) => {\n      const cachedFiberCommits = this._fiberCommits.get(fiberID);\n\n      if (cachedFiberCommits != null) {\n        return cachedFiberCommits;\n      }\n\n      const fiberCommits = [];\n\n      const dataForRoot = this._profilerStore.getDataForRoot(rootID);\n\n      dataForRoot.commitData.forEach((commitDatum, commitIndex) => {\n        if (commitDatum.fiberActualDurations.has(fiberID)) {\n          fiberCommits.push(commitIndex);\n        }\n      });\n\n      this._fiberCommits.set(fiberID, fiberCommits);\n\n      return fiberCommits;\n    });\n\n    _defineProperty(this, \"getFlamegraphChartData\", ({\n      commitIndex,\n      commitTree,\n      rootID\n    }) => (0,react_devtools_shared_src_devtools_views_Profiler_FlamegraphChartBuilder__WEBPACK_IMPORTED_MODULE_2__.getChartData)({\n      commitIndex,\n      commitTree,\n      profilerStore: this._profilerStore,\n      rootID\n    }));\n\n    _defineProperty(this, \"getRankedChartData\", ({\n      commitIndex,\n      commitTree,\n      rootID\n    }) => (0,react_devtools_shared_src_devtools_views_Profiler_RankedChartBuilder__WEBPACK_IMPORTED_MODULE_3__.getChartData)({\n      commitIndex,\n      commitTree,\n      profilerStore: this._profilerStore,\n      rootID\n    }));\n\n    this._profilerStore = profilerStore;\n  }\n\n  invalidate() {\n    this._fiberCommits.clear();\n\n    (0,react_devtools_shared_src_devtools_views_Profiler_CommitTreeBuilder__WEBPACK_IMPORTED_MODULE_1__.invalidateCommitTrees)();\n    (0,react_devtools_shared_src_devtools_views_Profiler_FlamegraphChartBuilder__WEBPACK_IMPORTED_MODULE_2__.invalidateChartData)();\n    (0,react_devtools_shared_src_devtools_views_Profiler_RankedChartBuilder__WEBPACK_IMPORTED_MODULE_3__.invalidateChartData)();\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy9Qcm9maWxpbmdDYWNoZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUlBO0FBSUE7QUFTQTtBQUlBO0FBQUE7O0FBQUE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFIQTs7QUFSQTtBQWVBO0FBQ0E7QUFGQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBbENBO0FBd0NBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUF6Q0E7QUFvREE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQXBEQTtBQUNBOztBQTBEQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQXRFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy9Qcm9maWxpbmdDYWNoZS5qcz84MTJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCBQcm9maWxlclN0b3JlIGZyb20gJy4vUHJvZmlsZXJTdG9yZSc7XG5pbXBvcnQge1xuICBnZXRDb21taXRUcmVlLFxuICBpbnZhbGlkYXRlQ29tbWl0VHJlZXMsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvdmlld3MvUHJvZmlsZXIvQ29tbWl0VHJlZUJ1aWxkZXInO1xuaW1wb3J0IHtcbiAgZ2V0Q2hhcnREYXRhIGFzIGdldEZsYW1lZ3JhcGhDaGFydERhdGEsXG4gIGludmFsaWRhdGVDaGFydERhdGEgYXMgaW52YWxpZGF0ZUZsYW1lZ3JhcGhDaGFydERhdGEsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvdmlld3MvUHJvZmlsZXIvRmxhbWVncmFwaENoYXJ0QnVpbGRlcic7XG5pbXBvcnQge1xuICBnZXRDaGFydERhdGEgYXMgZ2V0UmFua2VkQ2hhcnREYXRhLFxuICBpbnZhbGlkYXRlQ2hhcnREYXRhIGFzIGludmFsaWRhdGVSYW5rZWRDaGFydERhdGEsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvdmlld3MvUHJvZmlsZXIvUmFua2VkQ2hhcnRCdWlsZGVyJztcblxuaW1wb3J0IHR5cGUge0NvbW1pdFRyZWV9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvdmlld3MvUHJvZmlsZXIvdHlwZXMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0RGF0YSBhcyBGbGFtZWdyYXBoQ2hhcnREYXRhfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL3ZpZXdzL1Byb2ZpbGVyL0ZsYW1lZ3JhcGhDaGFydEJ1aWxkZXInO1xuaW1wb3J0IHR5cGUge0NoYXJ0RGF0YSBhcyBSYW5rZWRDaGFydERhdGF9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvdmlld3MvUHJvZmlsZXIvUmFua2VkQ2hhcnRCdWlsZGVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZmlsaW5nQ2FjaGUge1xuICBfZmliZXJDb21taXRzOiBNYXA8bnVtYmVyLCBBcnJheTxudW1iZXI+PiA9IG5ldyBNYXAoKTtcbiAgX3Byb2ZpbGVyU3RvcmU6IFByb2ZpbGVyU3RvcmU7XG5cbiAgY29uc3RydWN0b3IocHJvZmlsZXJTdG9yZTogUHJvZmlsZXJTdG9yZSkge1xuICAgIHRoaXMuX3Byb2ZpbGVyU3RvcmUgPSBwcm9maWxlclN0b3JlO1xuICB9XG5cbiAgZ2V0Q29tbWl0VHJlZTogKHtjb21taXRJbmRleDogbnVtYmVyLCByb290SUQ6IG51bWJlcn0pID0+IENvbW1pdFRyZWUgPSAoe1xuICAgIGNvbW1pdEluZGV4LFxuICAgIHJvb3RJRCxcbiAgfSkgPT5cbiAgICBnZXRDb21taXRUcmVlKHtcbiAgICAgIGNvbW1pdEluZGV4LFxuICAgICAgcHJvZmlsZXJTdG9yZTogdGhpcy5fcHJvZmlsZXJTdG9yZSxcbiAgICAgIHJvb3RJRCxcbiAgICB9KTtcblxuICBnZXRGaWJlckNvbW1pdHM6ICh7ZmliZXJJRDogbnVtYmVyLCByb290SUQ6IG51bWJlcn0pID0+IEFycmF5PG51bWJlcj4gPSAoe1xuICAgIGZpYmVySUQsXG4gICAgcm9vdElELFxuICB9KSA9PiB7XG4gICAgY29uc3QgY2FjaGVkRmliZXJDb21taXRzID0gdGhpcy5fZmliZXJDb21taXRzLmdldChmaWJlcklEKTtcbiAgICBpZiAoY2FjaGVkRmliZXJDb21taXRzICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRGaWJlckNvbW1pdHM7XG4gICAgfVxuXG4gICAgY29uc3QgZmliZXJDb21taXRzID0gW107XG4gICAgY29uc3QgZGF0YUZvclJvb3QgPSB0aGlzLl9wcm9maWxlclN0b3JlLmdldERhdGFGb3JSb290KHJvb3RJRCk7XG4gICAgZGF0YUZvclJvb3QuY29tbWl0RGF0YS5mb3JFYWNoKChjb21taXREYXR1bSwgY29tbWl0SW5kZXgpID0+IHtcbiAgICAgIGlmIChjb21taXREYXR1bS5maWJlckFjdHVhbER1cmF0aW9ucy5oYXMoZmliZXJJRCkpIHtcbiAgICAgICAgZmliZXJDb21taXRzLnB1c2goY29tbWl0SW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fZmliZXJDb21taXRzLnNldChmaWJlcklELCBmaWJlckNvbW1pdHMpO1xuXG4gICAgcmV0dXJuIGZpYmVyQ29tbWl0cztcbiAgfTtcblxuICBnZXRGbGFtZWdyYXBoQ2hhcnREYXRhOiAoe1xuICAgIGNvbW1pdEluZGV4OiBudW1iZXIsXG4gICAgY29tbWl0VHJlZTogQ29tbWl0VHJlZSxcbiAgICByb290SUQ6IG51bWJlcixcbiAgfSkgPT4gRmxhbWVncmFwaENoYXJ0RGF0YSA9ICh7Y29tbWl0SW5kZXgsIGNvbW1pdFRyZWUsIHJvb3RJRH0pID0+XG4gICAgZ2V0RmxhbWVncmFwaENoYXJ0RGF0YSh7XG4gICAgICBjb21taXRJbmRleCxcbiAgICAgIGNvbW1pdFRyZWUsXG4gICAgICBwcm9maWxlclN0b3JlOiB0aGlzLl9wcm9maWxlclN0b3JlLFxuICAgICAgcm9vdElELFxuICAgIH0pO1xuXG4gIGdldFJhbmtlZENoYXJ0RGF0YTogKHtcbiAgICBjb21taXRJbmRleDogbnVtYmVyLFxuICAgIGNvbW1pdFRyZWU6IENvbW1pdFRyZWUsXG4gICAgcm9vdElEOiBudW1iZXIsXG4gIH0pID0+IFJhbmtlZENoYXJ0RGF0YSA9ICh7Y29tbWl0SW5kZXgsIGNvbW1pdFRyZWUsIHJvb3RJRH0pID0+XG4gICAgZ2V0UmFua2VkQ2hhcnREYXRhKHtcbiAgICAgIGNvbW1pdEluZGV4LFxuICAgICAgY29tbWl0VHJlZSxcbiAgICAgIHByb2ZpbGVyU3RvcmU6IHRoaXMuX3Byb2ZpbGVyU3RvcmUsXG4gICAgICByb290SUQsXG4gICAgfSk7XG5cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9maWJlckNvbW1pdHMuY2xlYXIoKTtcblxuICAgIGludmFsaWRhdGVDb21taXRUcmVlcygpO1xuICAgIGludmFsaWRhdGVGbGFtZWdyYXBoQ2hhcnREYXRhKCk7XG4gICAgaW52YWxpZGF0ZVJhbmtlZENoYXJ0RGF0YSgpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/ProfilingCache.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/store.js":
/*!******************************************************!*\
  !*** ../react-devtools-shared/src/devtools/store.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Store)\n/* harmony export */ });\n/* harmony import */ var clipboard_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clipboard-js */ \"../../node_modules/clipboard-js/clipboard.js\");\n/* harmony import */ var clipboard_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clipboard_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events */ \"../react-devtools-shared/src/events.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var _frontend_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-devtools-shared/src/frontend/types */ \"../react-devtools-shared/src/frontend/types.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils */ \"../react-devtools-shared/src/utils.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../storage */ \"../react-devtools-shared/src/storage.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ \"../react-devtools-shared/src/devtools/utils.js\");\n/* harmony import */ var _ProfilerStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ProfilerStore */ \"../react-devtools-shared/src/devtools/ProfilerStore.js\");\n/* harmony import */ var react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-devtools-shared/src/bridge */ \"../react-devtools-shared/src/bridge.js\");\n/* harmony import */ var react_devtools_shared_src_UnsupportedBridgeOperationError__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! react-devtools-shared/src/UnsupportedBridgeOperationError */ \"../react-devtools-shared/src/UnsupportedBridgeOperationError.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst debug = (methodName, ...args) => {\n  if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n    console.log(`%cStore %c${methodName}`, 'color: green; font-weight: bold;', 'font-weight: bold;', ...args);\n  }\n};\n\nconst LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY = 'React::DevTools::collapseNodesByDefault';\nconst LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';\n\n/**\n * The store is the single source of truth for updates from the backend.\n * ContextProviders can subscribe to the Store for specific things they want to provide.\n */\nclass Store extends _events__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  // If the backend version is new enough to report its (NPM) version, this is it.\n  // This version may be displayed by the frontend for debugging purposes.\n  // Computed whenever _errorsAndWarnings Map changes.\n  // Should new nodes be collapsed by default when added to the tree?\n  // Map of ID to number of recorded error and warning message IDs.\n  // At least one of the injected renderers contains (DEV only) owner metadata.\n  // Map of ID to (mutable) Element.\n  // Elements are mutated to avoid excessive cloning during tree updates.\n  // The InspectedElement Suspense cache also relies on this mutability for its WeakMap usage.\n  // Should the React Native style editor panel be shown?\n  // Older backends don't support an explicit bridge protocol,\n  // so we should timeout eventually and show a downgrade message.\n  // Map of element (id) to the set of elements (ids) it owns.\n  // This map enables getOwnersListForElement() to avoid traversing the entire tree.\n  // Incremented each time the store is mutated.\n  // This enables a passive effect to detect a mutation between render and commit phase.\n  // This Array must be treated as immutable!\n  // Passive effects will check it for changes between render and mount.\n  // Renderer ID is needed to support inspection fiber props, state, and hooks.\n  // These options may be initially set by a configuration option when constructing the Store.\n  // These options default to false but may be updated as roots are added and removed.\n  // Total number of visible elements (within all roots).\n  // Used for windowing purposes.\n  constructor(_bridge, config) {\n    super();\n\n    _defineProperty(this, \"_backendVersion\", null);\n\n    _defineProperty(this, \"_cachedComponentWithErrorCount\", 0);\n\n    _defineProperty(this, \"_cachedComponentWithWarningCount\", 0);\n\n    _defineProperty(this, \"_cachedErrorAndWarningTuples\", null);\n\n    _defineProperty(this, \"_collapseNodesByDefault\", true);\n\n    _defineProperty(this, \"_errorsAndWarnings\", new Map());\n\n    _defineProperty(this, \"_hasOwnerMetadata\", false);\n\n    _defineProperty(this, \"_idToElement\", new Map());\n\n    _defineProperty(this, \"_isNativeStyleEditorSupported\", false);\n\n    _defineProperty(this, \"_nativeStyleEditorValidAttributes\", null);\n\n    _defineProperty(this, \"_onBridgeProtocolTimeoutID\", null);\n\n    _defineProperty(this, \"_ownersMap\", new Map());\n\n    _defineProperty(this, \"_recordChangeDescriptions\", false);\n\n    _defineProperty(this, \"_revision\", 0);\n\n    _defineProperty(this, \"_roots\", []);\n\n    _defineProperty(this, \"_rootIDToCapabilities\", new Map());\n\n    _defineProperty(this, \"_rootIDToRendererID\", new Map());\n\n    _defineProperty(this, \"_supportsInspectMatchingDOMElement\", false);\n\n    _defineProperty(this, \"_supportsClickToInspect\", false);\n\n    _defineProperty(this, \"_supportsTimeline\", false);\n\n    _defineProperty(this, \"_supportsTraceUpdates\", false);\n\n    _defineProperty(this, \"_isReloadAndProfileFrontendSupported\", false);\n\n    _defineProperty(this, \"_isReloadAndProfileBackendSupported\", false);\n\n    _defineProperty(this, \"_rootSupportsBasicProfiling\", false);\n\n    _defineProperty(this, \"_rootSupportsTimelineProfiling\", false);\n\n    _defineProperty(this, \"_bridgeProtocol\", null);\n\n    _defineProperty(this, \"_unsupportedBridgeProtocolDetected\", false);\n\n    _defineProperty(this, \"_unsupportedRendererVersionDetected\", false);\n\n    _defineProperty(this, \"_weightAcrossRoots\", 0);\n\n    _defineProperty(this, \"_shouldCheckBridgeProtocolCompatibility\", false);\n\n    _defineProperty(this, \"_hookSettings\", null);\n\n    _defineProperty(this, \"_shouldShowWarningsAndErrors\", false);\n\n    _defineProperty(this, \"_adjustParentTreeWeight\", (parentElement, weightDelta) => {\n      let isInsideCollapsedSubTree = false;\n\n      while (parentElement != null) {\n        parentElement.weight += weightDelta; // Additions and deletions within a collapsed subtree should not bubble beyond the collapsed parent.\n        // Their weight will bubble up when the parent is expanded.\n\n        if (parentElement.isCollapsed) {\n          isInsideCollapsedSubTree = true;\n          break;\n        }\n\n        parentElement = this._idToElement.get(parentElement.parentID);\n      } // Additions and deletions within a collapsed subtree should not affect the overall number of elements.\n\n\n      if (!isInsideCollapsedSubTree) {\n        this._weightAcrossRoots += weightDelta;\n      }\n    });\n\n    _defineProperty(this, \"onBridgeNativeStyleEditorSupported\", ({\n      isSupported,\n      validAttributes\n    }) => {\n      this._isNativeStyleEditorSupported = isSupported;\n      this._nativeStyleEditorValidAttributes = validAttributes || null;\n      this.emit('supportsNativeStyleEditor');\n    });\n\n    _defineProperty(this, \"onBridgeOperations\", operations => {\n      if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n        console.groupCollapsed('onBridgeOperations');\n        debug('onBridgeOperations', operations.join(','));\n      }\n\n      let haveRootsChanged = false;\n      let haveErrorsOrWarningsChanged = false; // The first two values are always rendererID and rootID\n\n      const rendererID = operations[0];\n      const addedElementIDs = []; // This is a mapping of removed ID -> parent ID:\n\n      const removedElementIDs = new Map(); // We'll use the parent ID to adjust selection if it gets deleted.\n\n      let i = 2; // Reassemble the string table.\n\n      const stringTable = [null // ID = 0 corresponds to the null string.\n      ];\n      const stringTableSize = operations[i];\n      i++;\n      const stringTableEnd = i + stringTableSize;\n\n      while (i < stringTableEnd) {\n        const nextLength = operations[i];\n        i++;\n        const nextString = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.utfDecodeStringWithRanges)(operations, i, i + nextLength - 1);\n        stringTable.push(nextString);\n        i += nextLength;\n      }\n\n      while (i < operations.length) {\n        const operation = operations[i];\n\n        switch (operation) {\n          case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_ADD:\n            {\n              const id = operations[i + 1];\n              const type = operations[i + 2];\n              i += 3;\n\n              if (this._idToElement.has(id)) {\n                this._throwAndEmitError(Error(`Cannot add node \"${id}\" because a node with that id is already in the Store.`));\n              }\n\n              if (type === _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeRoot) {\n                if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n                  debug('Add', `new root node ${id}`);\n                }\n\n                const isStrictModeCompliant = operations[i] > 0;\n                i++;\n                const supportsBasicProfiling = (operations[i] & _constants__WEBPACK_IMPORTED_MODULE_3__.PROFILING_FLAG_BASIC_SUPPORT) !== 0;\n                const supportsTimeline = (operations[i] & _constants__WEBPACK_IMPORTED_MODULE_3__.PROFILING_FLAG_TIMELINE_SUPPORT) !== 0;\n                i++;\n                let supportsStrictMode = false;\n                let hasOwnerMetadata = false; // If we don't know the bridge protocol, guess that we're dealing with the latest.\n                // If we do know it, we can take it into consideration when parsing operations.\n\n                if (this._bridgeProtocol === null || this._bridgeProtocol.version >= 2) {\n                  supportsStrictMode = operations[i] > 0;\n                  i++;\n                  hasOwnerMetadata = operations[i] > 0;\n                  i++;\n                }\n\n                this._roots = this._roots.concat(id);\n\n                this._rootIDToRendererID.set(id, rendererID);\n\n                this._rootIDToCapabilities.set(id, {\n                  supportsBasicProfiling,\n                  hasOwnerMetadata,\n                  supportsStrictMode,\n                  supportsTimeline\n                }); // Not all roots support StrictMode;\n                // don't flag a root as non-compliant unless it also supports StrictMode.\n\n\n                const isStrictModeNonCompliant = !isStrictModeCompliant && supportsStrictMode;\n\n                this._idToElement.set(id, {\n                  children: [],\n                  depth: -1,\n                  displayName: null,\n                  hocDisplayNames: null,\n                  id,\n                  isCollapsed: false,\n                  // Never collapse roots; it would hide the entire tree.\n                  isStrictModeNonCompliant,\n                  key: null,\n                  ownerID: 0,\n                  parentID: 0,\n                  type,\n                  weight: 0,\n                  compiledWithForget: false\n                });\n\n                haveRootsChanged = true;\n              } else {\n                const parentID = operations[i];\n                i++;\n                const ownerID = operations[i];\n                i++;\n                const displayNameStringID = operations[i];\n                const displayName = stringTable[displayNameStringID];\n                i++;\n                const keyStringID = operations[i];\n                const key = stringTable[keyStringID];\n                i++;\n\n                if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n                  debug('Add', `node ${id} (${displayName || 'null'}) as child of ${parentID}`);\n                }\n\n                const parentElement = this._idToElement.get(parentID);\n\n                if (parentElement === undefined) {\n                  this._throwAndEmitError(Error(`Cannot add child \"${id}\" to parent \"${parentID}\" because parent node was not found in the Store.`));\n\n                  break;\n                }\n\n                parentElement.children.push(id);\n                const {\n                  formattedDisplayName: displayNameWithoutHOCs,\n                  hocDisplayNames,\n                  compiledWithForget\n                } = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.parseElementDisplayNameFromBackend)(displayName, type);\n                const element = {\n                  children: [],\n                  depth: parentElement.depth + 1,\n                  displayName: displayNameWithoutHOCs,\n                  hocDisplayNames,\n                  id,\n                  isCollapsed: this._collapseNodesByDefault,\n                  isStrictModeNonCompliant: parentElement.isStrictModeNonCompliant,\n                  key,\n                  ownerID,\n                  parentID,\n                  type,\n                  weight: 1,\n                  compiledWithForget\n                };\n\n                this._idToElement.set(id, element);\n\n                addedElementIDs.push(id);\n\n                this._adjustParentTreeWeight(parentElement, 1);\n\n                if (ownerID > 0) {\n                  let set = this._ownersMap.get(ownerID);\n\n                  if (set === undefined) {\n                    set = new Set();\n\n                    this._ownersMap.set(ownerID, set);\n                  }\n\n                  set.add(id);\n                }\n              }\n\n              break;\n            }\n\n          case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REMOVE:\n            {\n              const removeLength = operations[i + 1];\n              i += 2;\n\n              for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {\n                const id = operations[i];\n\n                const element = this._idToElement.get(id);\n\n                if (element === undefined) {\n                  this._throwAndEmitError(Error(`Cannot remove node \"${id}\" because no matching node was found in the Store.`));\n\n                  break;\n                }\n\n                i += 1;\n                const {\n                  children,\n                  ownerID,\n                  parentID,\n                  weight\n                } = element;\n\n                if (children.length > 0) {\n                  this._throwAndEmitError(Error(`Node \"${id}\" was removed before its children.`));\n                }\n\n                this._idToElement.delete(id);\n\n                let parentElement = null;\n\n                if (parentID === 0) {\n                  if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n                    debug('Remove', `node ${id} root`);\n                  }\n\n                  this._roots = this._roots.filter(rootID => rootID !== id);\n\n                  this._rootIDToRendererID.delete(id);\n\n                  this._rootIDToCapabilities.delete(id);\n\n                  haveRootsChanged = true;\n                } else {\n                  if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n                    debug('Remove', `node ${id} from parent ${parentID}`);\n                  }\n\n                  parentElement = this._idToElement.get(parentID);\n\n                  if (parentElement === undefined) {\n                    this._throwAndEmitError(Error(`Cannot remove node \"${id}\" from parent \"${parentID}\" because no matching node was found in the Store.`));\n\n                    break;\n                  }\n\n                  const index = parentElement.children.indexOf(id);\n                  parentElement.children.splice(index, 1);\n                }\n\n                this._adjustParentTreeWeight(parentElement, -weight);\n\n                removedElementIDs.set(id, parentID);\n\n                this._ownersMap.delete(id);\n\n                if (ownerID > 0) {\n                  const set = this._ownersMap.get(ownerID);\n\n                  if (set !== undefined) {\n                    set.delete(id);\n                  }\n                }\n\n                if (this._errorsAndWarnings.has(id)) {\n                  this._errorsAndWarnings.delete(id);\n\n                  haveErrorsOrWarningsChanged = true;\n                }\n              }\n\n              break;\n            }\n\n          case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REMOVE_ROOT:\n            {\n              i += 1;\n              const id = operations[1];\n\n              if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n                debug(`Remove root ${id}`);\n              }\n\n              const recursivelyDeleteElements = elementID => {\n                const element = this._idToElement.get(elementID);\n\n                this._idToElement.delete(elementID);\n\n                if (element) {\n                  // Mostly for Flow's sake\n                  for (let index = 0; index < element.children.length; index++) {\n                    recursivelyDeleteElements(element.children[index]);\n                  }\n                }\n              };\n\n              const root = this._idToElement.get(id);\n\n              if (root === undefined) {\n                this._throwAndEmitError(Error(`Cannot remove root \"${id}\": no matching node was found in the Store.`));\n\n                break;\n              }\n\n              recursivelyDeleteElements(id);\n\n              this._rootIDToCapabilities.delete(id);\n\n              this._rootIDToRendererID.delete(id);\n\n              this._roots = this._roots.filter(rootID => rootID !== id);\n              this._weightAcrossRoots -= root.weight;\n              break;\n            }\n\n          case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REORDER_CHILDREN:\n            {\n              const id = operations[i + 1];\n              const numChildren = operations[i + 2];\n              i += 3;\n\n              const element = this._idToElement.get(id);\n\n              if (element === undefined) {\n                this._throwAndEmitError(Error(`Cannot reorder children for node \"${id}\" because no matching node was found in the Store.`));\n\n                break;\n              }\n\n              const children = element.children;\n\n              if (children.length !== numChildren) {\n                this._throwAndEmitError(Error(`Children cannot be added or removed during a reorder operation.`));\n              }\n\n              for (let j = 0; j < numChildren; j++) {\n                const childID = operations[i + j];\n                children[j] = childID;\n\n                if (true) {\n                  // This check is more expensive so it's gated by __DEV__.\n                  const childElement = this._idToElement.get(childID);\n\n                  if (childElement == null || childElement.parentID !== id) {\n                    console.error(`Children cannot be added or removed during a reorder operation.`);\n                  }\n                }\n              }\n\n              i += numChildren;\n\n              if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n                debug('Re-order', `Node ${id} children ${children.join(',')}`);\n              }\n\n              break;\n            }\n\n          case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_SET_SUBTREE_MODE:\n            {\n              const id = operations[i + 1];\n              const mode = operations[i + 2];\n              i += 3; // If elements have already been mounted in this subtree, update them.\n              // (In practice, this likely only applies to the root element.)\n\n              if (mode === _frontend_types__WEBPACK_IMPORTED_MODULE_4__.StrictMode) {\n                this._recursivelyUpdateSubtree(id, element => {\n                  element.isStrictModeNonCompliant = false;\n                });\n              }\n\n              if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n                debug('Subtree mode', `Subtree with root ${id} set to mode ${mode}`);\n              }\n\n              break;\n            }\n\n          case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_TREE_BASE_DURATION:\n            // Base duration updates are only sent while profiling is in progress.\n            // We can ignore them at this point.\n            // The profiler UI uses them lazily in order to generate the tree.\n            i += 3;\n            break;\n\n          case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:\n            const id = operations[i + 1];\n            const errorCount = operations[i + 2];\n            const warningCount = operations[i + 3];\n            i += 4;\n\n            if (errorCount > 0 || warningCount > 0) {\n              this._errorsAndWarnings.set(id, {\n                errorCount,\n                warningCount\n              });\n            } else if (this._errorsAndWarnings.has(id)) {\n              this._errorsAndWarnings.delete(id);\n            }\n\n            haveErrorsOrWarningsChanged = true;\n            break;\n\n          default:\n            this._throwAndEmitError(new react_devtools_shared_src_UnsupportedBridgeOperationError__WEBPACK_IMPORTED_MODULE_10__[\"default\"](`Unsupported Bridge operation \"${operation}\"`));\n\n        }\n      }\n\n      this._revision++; // Any time the tree changes (e.g. elements added, removed, or reordered) cached indices may be invalid.\n\n      this._cachedErrorAndWarningTuples = null;\n\n      if (haveErrorsOrWarningsChanged) {\n        let componentWithErrorCount = 0;\n        let componentWithWarningCount = 0;\n\n        this._errorsAndWarnings.forEach(entry => {\n          if (entry.errorCount > 0) {\n            componentWithErrorCount++;\n          }\n\n          if (entry.warningCount > 0) {\n            componentWithWarningCount++;\n          }\n        });\n\n        this._cachedComponentWithErrorCount = componentWithErrorCount;\n        this._cachedComponentWithWarningCount = componentWithWarningCount;\n      }\n\n      if (haveRootsChanged) {\n        const prevRootSupportsProfiling = this._rootSupportsBasicProfiling;\n        const prevRootSupportsTimelineProfiling = this._rootSupportsTimelineProfiling;\n        this._hasOwnerMetadata = false;\n        this._rootSupportsBasicProfiling = false;\n        this._rootSupportsTimelineProfiling = false;\n\n        this._rootIDToCapabilities.forEach(({\n          supportsBasicProfiling,\n          hasOwnerMetadata,\n          supportsTimeline\n        }) => {\n          if (supportsBasicProfiling) {\n            this._rootSupportsBasicProfiling = true;\n          }\n\n          if (hasOwnerMetadata) {\n            this._hasOwnerMetadata = true;\n          }\n\n          if (supportsTimeline) {\n            this._rootSupportsTimelineProfiling = true;\n          }\n        });\n\n        this.emit('roots');\n\n        if (this._rootSupportsBasicProfiling !== prevRootSupportsProfiling) {\n          this.emit('rootSupportsBasicProfiling');\n        }\n\n        if (this._rootSupportsTimelineProfiling !== prevRootSupportsTimelineProfiling) {\n          this.emit('rootSupportsTimelineProfiling');\n        }\n      }\n\n      if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n        console.log((0,_utils__WEBPACK_IMPORTED_MODULE_7__.printStore)(this, true));\n        console.groupEnd();\n      }\n\n      this.emit('mutated', [addedElementIDs, removedElementIDs]);\n    });\n\n    _defineProperty(this, \"onBridgeOverrideComponentFilters\", componentFilters => {\n      this._componentFilters = componentFilters;\n      (0,_utils__WEBPACK_IMPORTED_MODULE_5__.setSavedComponentFilters)(componentFilters);\n    });\n\n    _defineProperty(this, \"onBridgeShutdown\", () => {\n      if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n        debug('onBridgeShutdown', 'unsubscribing from Bridge');\n      }\n\n      const bridge = this._bridge;\n      bridge.removeListener('operations', this.onBridgeOperations);\n      bridge.removeListener('overrideComponentFilters', this.onBridgeOverrideComponentFilters);\n      bridge.removeListener('shutdown', this.onBridgeShutdown);\n      bridge.removeListener('isReloadAndProfileSupportedByBackend', this.onBackendReloadAndProfileSupported);\n      bridge.removeListener('isNativeStyleEditorSupported', this.onBridgeNativeStyleEditorSupported);\n      bridge.removeListener('unsupportedRendererVersion', this.onBridgeUnsupportedRendererVersion);\n      bridge.removeListener('backendVersion', this.onBridgeBackendVersion);\n      bridge.removeListener('bridgeProtocol', this.onBridgeProtocol);\n      bridge.removeListener('saveToClipboard', this.onSaveToClipboard);\n\n      if (this._onBridgeProtocolTimeoutID !== null) {\n        clearTimeout(this._onBridgeProtocolTimeoutID);\n        this._onBridgeProtocolTimeoutID = null;\n      }\n    });\n\n    _defineProperty(this, \"onBackendReloadAndProfileSupported\", isReloadAndProfileSupported => {\n      this._isReloadAndProfileBackendSupported = isReloadAndProfileSupported;\n      this.emit('supportsReloadAndProfile');\n    });\n\n    _defineProperty(this, \"onBridgeUnsupportedRendererVersion\", () => {\n      this._unsupportedRendererVersionDetected = true;\n      this.emit('unsupportedRendererVersionDetected');\n    });\n\n    _defineProperty(this, \"onBridgeBackendVersion\", backendVersion => {\n      this._backendVersion = backendVersion;\n      this.emit('backendVersion');\n    });\n\n    _defineProperty(this, \"onBridgeProtocol\", bridgeProtocol => {\n      if (this._onBridgeProtocolTimeoutID !== null) {\n        clearTimeout(this._onBridgeProtocolTimeoutID);\n        this._onBridgeProtocolTimeoutID = null;\n      }\n\n      this._bridgeProtocol = bridgeProtocol;\n\n      if (bridgeProtocol.version !== react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_9__.currentBridgeProtocol.version) {// Technically newer versions of the frontend can, at least for now,\n        // gracefully handle older versions of the backend protocol.\n        // So for now we don't need to display the unsupported dialog.\n      }\n    });\n\n    _defineProperty(this, \"onBridgeProtocolTimeout\", () => {\n      this._onBridgeProtocolTimeoutID = null; // If we timed out, that indicates the backend predates the bridge protocol,\n      // so we can set a fake version (0) to trigger the downgrade message.\n\n      this._bridgeProtocol = react_devtools_shared_src_bridge__WEBPACK_IMPORTED_MODULE_9__.BRIDGE_PROTOCOL[0];\n      this.emit('unsupportedBridgeProtocolDetected');\n    });\n\n    _defineProperty(this, \"onSaveToClipboard\", text => {\n      (0,clipboard_js__WEBPACK_IMPORTED_MODULE_0__.copy)(text);\n    });\n\n    _defineProperty(this, \"onBackendInitialized\", () => {\n      // Verify that the frontend version is compatible with the connected backend.\n      // See github.com/facebook/react/issues/21326\n      if (this._shouldCheckBridgeProtocolCompatibility) {\n        // Older backends don't support an explicit bridge protocol,\n        // so we should timeout eventually and show a downgrade message.\n        this._onBridgeProtocolTimeoutID = setTimeout(this.onBridgeProtocolTimeout, 10000);\n\n        this._bridge.addListener('bridgeProtocol', this.onBridgeProtocol);\n\n        this._bridge.send('getBridgeProtocol');\n      }\n\n      this._bridge.send('getBackendVersion');\n\n      this._bridge.send('getIfHasUnsupportedRendererVersion');\n\n      this._bridge.send('getHookSettings'); // Warm up cached hook settings\n\n    });\n\n    _defineProperty(this, \"getHookSettings\", () => {\n      if (this._hookSettings != null) {\n        this.emit('hookSettings', this._hookSettings);\n      } else {\n        this._bridge.send('getHookSettings');\n      }\n    });\n\n    _defineProperty(this, \"updateHookSettings\", settings => {\n      this._hookSettings = settings;\n\n      this._bridge.send('updateHookSettings', settings);\n\n      this.emit('settingsUpdated', settings);\n    });\n\n    _defineProperty(this, \"onHookSettings\", settings => {\n      this._hookSettings = settings;\n      this.setShouldShowWarningsAndErrors(settings.showInlineWarningsAndErrors);\n      this.emit('hookSettings', settings);\n    });\n\n    if (_constants__WEBPACK_IMPORTED_MODULE_3__.__DEBUG__) {\n      debug('constructor', 'subscribing to Bridge');\n    }\n\n    this._collapseNodesByDefault = (0,_storage__WEBPACK_IMPORTED_MODULE_6__.localStorageGetItem)(LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY) === 'true';\n    this._recordChangeDescriptions = (0,_storage__WEBPACK_IMPORTED_MODULE_6__.localStorageGetItem)(LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === 'true';\n    this._componentFilters = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getSavedComponentFilters)();\n    let isProfiling = false;\n\n    if (config != null) {\n      isProfiling = config.isProfiling === true;\n      const {\n        supportsInspectMatchingDOMElement,\n        supportsClickToInspect,\n        supportsReloadAndProfile,\n        supportsTimeline,\n        supportsTraceUpdates,\n        checkBridgeProtocolCompatibility\n      } = config;\n\n      if (supportsInspectMatchingDOMElement) {\n        this._supportsInspectMatchingDOMElement = true;\n      }\n\n      if (supportsClickToInspect) {\n        this._supportsClickToInspect = true;\n      }\n\n      if (supportsReloadAndProfile) {\n        this._isReloadAndProfileFrontendSupported = true;\n      }\n\n      if (supportsTimeline) {\n        this._supportsTimeline = true;\n      }\n\n      if (supportsTraceUpdates) {\n        this._supportsTraceUpdates = true;\n      }\n\n      if (checkBridgeProtocolCompatibility) {\n        this._shouldCheckBridgeProtocolCompatibility = true;\n      }\n    }\n\n    this._bridge = _bridge;\n\n    _bridge.addListener('operations', this.onBridgeOperations);\n\n    _bridge.addListener('overrideComponentFilters', this.onBridgeOverrideComponentFilters);\n\n    _bridge.addListener('shutdown', this.onBridgeShutdown);\n\n    _bridge.addListener('isReloadAndProfileSupportedByBackend', this.onBackendReloadAndProfileSupported);\n\n    _bridge.addListener('isNativeStyleEditorSupported', this.onBridgeNativeStyleEditorSupported);\n\n    _bridge.addListener('unsupportedRendererVersion', this.onBridgeUnsupportedRendererVersion);\n\n    this._profilerStore = new _ProfilerStore__WEBPACK_IMPORTED_MODULE_8__[\"default\"](_bridge, this, isProfiling);\n\n    _bridge.addListener('backendVersion', this.onBridgeBackendVersion);\n\n    _bridge.addListener('saveToClipboard', this.onSaveToClipboard);\n\n    _bridge.addListener('hookSettings', this.onHookSettings);\n\n    _bridge.addListener('backendInitialized', this.onBackendInitialized);\n  } // This is only used in tests to avoid memory leaks.\n\n\n  assertExpectedRootMapSizes() {\n    if (this.roots.length === 0) {\n      // The only safe time to assert these maps are empty is when the store is empty.\n      this.assertMapSizeMatchesRootCount(this._idToElement, '_idToElement');\n      this.assertMapSizeMatchesRootCount(this._ownersMap, '_ownersMap');\n    } // These maps should always be the same size as the number of roots\n\n\n    this.assertMapSizeMatchesRootCount(this._rootIDToCapabilities, '_rootIDToCapabilities');\n    this.assertMapSizeMatchesRootCount(this._rootIDToRendererID, '_rootIDToRendererID');\n  } // This is only used in tests to avoid memory leaks.\n\n\n  assertMapSizeMatchesRootCount(map, mapName) {\n    const expectedSize = this.roots.length;\n\n    if (map.size !== expectedSize) {\n      this._throwAndEmitError(Error(`Expected ${mapName} to contain ${expectedSize} items, but it contains ${map.size} items\\n\\n${(0,util__WEBPACK_IMPORTED_MODULE_2__.inspect)(map, {\n        depth: 20\n      })}`));\n    }\n  }\n\n  get backendVersion() {\n    return this._backendVersion;\n  }\n\n  get collapseNodesByDefault() {\n    return this._collapseNodesByDefault;\n  }\n\n  set collapseNodesByDefault(value) {\n    this._collapseNodesByDefault = value;\n    (0,_storage__WEBPACK_IMPORTED_MODULE_6__.localStorageSetItem)(LOCAL_STORAGE_COLLAPSE_ROOTS_BY_DEFAULT_KEY, value ? 'true' : 'false');\n    this.emit('collapseNodesByDefault');\n  }\n\n  get componentFilters() {\n    return this._componentFilters;\n  }\n\n  set componentFilters(value) {\n    if (this._profilerStore.isProfilingBasedOnUserInput) {\n      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.\n      // If necessary, we could support this- but it doesn't seem like a necessary use case.\n      this._throwAndEmitError(Error('Cannot modify filter preferences while profiling'));\n    } // Filter updates are expensive to apply (since they impact the entire tree).\n    // Let's determine if they've changed and avoid doing this work if they haven't.\n\n\n    const prevEnabledComponentFilters = this._componentFilters.filter(filter => filter.isEnabled);\n\n    const nextEnabledComponentFilters = value.filter(filter => filter.isEnabled);\n    let haveEnabledFiltersChanged = prevEnabledComponentFilters.length !== nextEnabledComponentFilters.length;\n\n    if (!haveEnabledFiltersChanged) {\n      for (let i = 0; i < nextEnabledComponentFilters.length; i++) {\n        const prevFilter = prevEnabledComponentFilters[i];\n        const nextFilter = nextEnabledComponentFilters[i];\n\n        if ((0,_utils__WEBPACK_IMPORTED_MODULE_5__.shallowDiffers)(prevFilter, nextFilter)) {\n          haveEnabledFiltersChanged = true;\n          break;\n        }\n      }\n    }\n\n    this._componentFilters = value; // Update persisted filter preferences stored in localStorage.\n\n    (0,_utils__WEBPACK_IMPORTED_MODULE_5__.setSavedComponentFilters)(value); // Notify the renderer that filter preferences have changed.\n    // This is an expensive operation; it unmounts and remounts the entire tree,\n    // so only do it if the set of enabled component filters has changed.\n\n    if (haveEnabledFiltersChanged) {\n      this._bridge.send('updateComponentFilters', value);\n    }\n\n    this.emit('componentFilters');\n  }\n\n  get bridgeProtocol() {\n    return this._bridgeProtocol;\n  }\n\n  get componentWithErrorCount() {\n    if (!this._shouldShowWarningsAndErrors) {\n      return 0;\n    }\n\n    return this._cachedComponentWithErrorCount;\n  }\n\n  get componentWithWarningCount() {\n    if (!this._shouldShowWarningsAndErrors) {\n      return 0;\n    }\n\n    return this._cachedComponentWithWarningCount;\n  }\n\n  get displayingErrorsAndWarningsEnabled() {\n    return this._shouldShowWarningsAndErrors;\n  }\n\n  get hasOwnerMetadata() {\n    return this._hasOwnerMetadata;\n  }\n\n  get nativeStyleEditorValidAttributes() {\n    return this._nativeStyleEditorValidAttributes;\n  }\n\n  get numElements() {\n    return this._weightAcrossRoots;\n  }\n\n  get profilerStore() {\n    return this._profilerStore;\n  }\n\n  get recordChangeDescriptions() {\n    return this._recordChangeDescriptions;\n  }\n\n  set recordChangeDescriptions(value) {\n    this._recordChangeDescriptions = value;\n    (0,_storage__WEBPACK_IMPORTED_MODULE_6__.localStorageSetItem)(LOCAL_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, value ? 'true' : 'false');\n    this.emit('recordChangeDescriptions');\n  }\n\n  get revision() {\n    return this._revision;\n  }\n\n  get rootIDToRendererID() {\n    return this._rootIDToRendererID;\n  }\n\n  get roots() {\n    return this._roots;\n  } // At least one of the currently mounted roots support the Legacy profiler.\n\n\n  get rootSupportsBasicProfiling() {\n    return this._rootSupportsBasicProfiling;\n  } // At least one of the currently mounted roots support the Timeline profiler.\n\n\n  get rootSupportsTimelineProfiling() {\n    return this._rootSupportsTimelineProfiling;\n  }\n\n  get supportsInspectMatchingDOMElement() {\n    return this._supportsInspectMatchingDOMElement;\n  }\n\n  get supportsClickToInspect() {\n    return this._supportsClickToInspect;\n  }\n\n  get supportsNativeStyleEditor() {\n    return this._isNativeStyleEditorSupported;\n  }\n\n  get supportsReloadAndProfile() {\n    return this._isReloadAndProfileFrontendSupported && this._isReloadAndProfileBackendSupported;\n  } // This build of DevTools supports the Timeline profiler.\n  // This is a static flag, controlled by the Store config.\n\n\n  get supportsTimeline() {\n    return this._supportsTimeline;\n  }\n\n  get supportsTraceUpdates() {\n    return this._supportsTraceUpdates;\n  }\n\n  get unsupportedBridgeProtocolDetected() {\n    return this._unsupportedBridgeProtocolDetected;\n  }\n\n  get unsupportedRendererVersionDetected() {\n    return this._unsupportedRendererVersionDetected;\n  }\n\n  containsElement(id) {\n    return this._idToElement.has(id);\n  }\n\n  getElementAtIndex(index) {\n    if (index < 0 || index >= this.numElements) {\n      console.warn(`Invalid index ${index} specified; store contains ${this.numElements} items.`);\n      return null;\n    } // Find which root this element is in...\n\n\n    let root;\n    let rootWeight = 0;\n\n    for (let i = 0; i < this._roots.length; i++) {\n      const rootID = this._roots[i];\n      root = this._idToElement.get(rootID);\n\n      if (root === undefined) {\n        this._throwAndEmitError(Error(`Couldn't find root with id \"${rootID}\": no matching node was found in the Store.`));\n\n        return null;\n      }\n\n      if (root.children.length === 0) {\n        continue;\n      }\n\n      if (rootWeight + root.weight > index) {\n        break;\n      } else {\n        rootWeight += root.weight;\n      }\n    }\n\n    if (root === undefined) {\n      return null;\n    } // Find the element in the tree using the weight of each node...\n    // Skip over the root itself, because roots aren't visible in the Elements tree.\n\n\n    let currentElement = root;\n    let currentWeight = rootWeight - 1;\n\n    while (index !== currentWeight) {\n      const numChildren = currentElement.children.length;\n\n      for (let i = 0; i < numChildren; i++) {\n        const childID = currentElement.children[i];\n\n        const child = this._idToElement.get(childID);\n\n        if (child === undefined) {\n          this._throwAndEmitError(Error(`Couldn't child element with id \"${childID}\": no matching node was found in the Store.`));\n\n          return null;\n        }\n\n        const childWeight = child.isCollapsed ? 1 : child.weight;\n\n        if (index <= currentWeight + childWeight) {\n          currentWeight++;\n          currentElement = child;\n          break;\n        } else {\n          currentWeight += childWeight;\n        }\n      }\n    }\n\n    return currentElement || null;\n  }\n\n  getElementIDAtIndex(index) {\n    const element = this.getElementAtIndex(index);\n    return element === null ? null : element.id;\n  }\n\n  getElementByID(id) {\n    const element = this._idToElement.get(id);\n\n    if (element === undefined) {\n      console.warn(`No element found with id \"${id}\"`);\n      return null;\n    }\n\n    return element;\n  } // Returns a tuple of [id, index]\n\n\n  getElementsWithErrorsAndWarnings() {\n    if (!this._shouldShowWarningsAndErrors) {\n      return [];\n    }\n\n    if (this._cachedErrorAndWarningTuples !== null) {\n      return this._cachedErrorAndWarningTuples;\n    }\n\n    const errorAndWarningTuples = [];\n\n    this._errorsAndWarnings.forEach((_, id) => {\n      const index = this.getIndexOfElementID(id);\n\n      if (index !== null) {\n        let low = 0;\n        let high = errorAndWarningTuples.length;\n\n        while (low < high) {\n          const mid = low + high >> 1;\n\n          if (errorAndWarningTuples[mid].index > index) {\n            high = mid;\n          } else {\n            low = mid + 1;\n          }\n        }\n\n        errorAndWarningTuples.splice(low, 0, {\n          id,\n          index\n        });\n      }\n    }); // Cache for later (at least until the tree changes again).\n\n\n    this._cachedErrorAndWarningTuples = errorAndWarningTuples;\n    return errorAndWarningTuples;\n  }\n\n  getErrorAndWarningCountForElementID(id) {\n    if (!this._shouldShowWarningsAndErrors) {\n      return {\n        errorCount: 0,\n        warningCount: 0\n      };\n    }\n\n    return this._errorsAndWarnings.get(id) || {\n      errorCount: 0,\n      warningCount: 0\n    };\n  }\n\n  getIndexOfElementID(id) {\n    const element = this.getElementByID(id);\n\n    if (element === null || element.parentID === 0) {\n      return null;\n    } // Walk up the tree to the root.\n    // Increment the index by one for each node we encounter,\n    // and by the weight of all nodes to the left of the current one.\n    // This should be a relatively fast way of determining the index of a node within the tree.\n\n\n    let previousID = id;\n    let currentID = element.parentID;\n    let index = 0;\n\n    while (true) {\n      const current = this._idToElement.get(currentID);\n\n      if (current === undefined) {\n        return null;\n      }\n\n      const {\n        children\n      } = current;\n\n      for (let i = 0; i < children.length; i++) {\n        const childID = children[i];\n\n        if (childID === previousID) {\n          break;\n        }\n\n        const child = this._idToElement.get(childID);\n\n        if (child === undefined) {\n          return null;\n        }\n\n        index += child.isCollapsed ? 1 : child.weight;\n      }\n\n      if (current.parentID === 0) {\n        // We found the root; stop crawling.\n        break;\n      }\n\n      index++;\n      previousID = current.id;\n      currentID = current.parentID;\n    } // At this point, the current ID is a root (from the previous loop).\n    // We also need to offset the index by previous root weights.\n\n\n    for (let i = 0; i < this._roots.length; i++) {\n      const rootID = this._roots[i];\n\n      if (rootID === currentID) {\n        break;\n      }\n\n      const root = this._idToElement.get(rootID);\n\n      if (root === undefined) {\n        return null;\n      }\n\n      index += root.weight;\n    }\n\n    return index;\n  }\n\n  getOwnersListForElement(ownerID) {\n    const list = [];\n\n    const element = this._idToElement.get(ownerID);\n\n    if (element !== undefined) {\n      list.push({ ...element,\n        depth: 0\n      });\n\n      const unsortedIDs = this._ownersMap.get(ownerID);\n\n      if (unsortedIDs !== undefined) {\n        const depthMap = new Map([[ownerID, 0]]); // Items in a set are ordered based on insertion.\n        // This does not correlate with their order in the tree.\n        // So first we need to order them.\n        // I wish we could avoid this sorting operation; we could sort at insertion time,\n        // but then we'd have to pay sorting costs even if the owners list was never used.\n        // Seems better to defer the cost, since the set of ids is probably pretty small.\n\n        const sortedIDs = Array.from(unsortedIDs).sort((idA, idB) => (this.getIndexOfElementID(idA) || 0) - (this.getIndexOfElementID(idB) || 0)); // Next we need to determine the appropriate depth for each element in the list.\n        // The depth in the list may not correspond to the depth in the tree,\n        // because the list has been filtered to remove intermediate components.\n        // Perhaps the easiest way to do this is to walk up the tree until we reach either:\n        // (1) another node that's already in the tree, or (2) the root (owner)\n        // at which point, our depth is just the depth of that node plus one.\n\n        sortedIDs.forEach(id => {\n          const innerElement = this._idToElement.get(id);\n\n          if (innerElement !== undefined) {\n            let parentID = innerElement.parentID;\n            let depth = 0;\n\n            while (parentID > 0) {\n              if (parentID === ownerID || unsortedIDs.has(parentID)) {\n                // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                depth = depthMap.get(parentID) + 1;\n                depthMap.set(id, depth);\n                break;\n              }\n\n              const parent = this._idToElement.get(parentID);\n\n              if (parent === undefined) {\n                break;\n              }\n\n              parentID = parent.parentID;\n            }\n\n            if (depth === 0) {\n              this._throwAndEmitError(Error('Invalid owners list'));\n            }\n\n            list.push({ ...innerElement,\n              depth\n            });\n          }\n        });\n      }\n    }\n\n    return list;\n  }\n\n  getRendererIDForElement(id) {\n    let current = this._idToElement.get(id);\n\n    while (current !== undefined) {\n      if (current.parentID === 0) {\n        const rendererID = this._rootIDToRendererID.get(current.id);\n\n        return rendererID == null ? null : rendererID;\n      } else {\n        current = this._idToElement.get(current.parentID);\n      }\n    }\n\n    return null;\n  }\n\n  getRootIDForElement(id) {\n    let current = this._idToElement.get(id);\n\n    while (current !== undefined) {\n      if (current.parentID === 0) {\n        return current.id;\n      } else {\n        current = this._idToElement.get(current.parentID);\n      }\n    }\n\n    return null;\n  }\n\n  isInsideCollapsedSubTree(id) {\n    let current = this._idToElement.get(id);\n\n    while (current != null) {\n      if (current.parentID === 0) {\n        return false;\n      } else {\n        current = this._idToElement.get(current.parentID);\n\n        if (current != null && current.isCollapsed) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  } // TODO Maybe split this into two methods: expand() and collapse()\n\n\n  toggleIsCollapsed(id, isCollapsed) {\n    let didMutate = false;\n    const element = this.getElementByID(id);\n\n    if (element !== null) {\n      if (isCollapsed) {\n        if (element.type === _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeRoot) {\n          this._throwAndEmitError(Error('Root nodes cannot be collapsed'));\n        }\n\n        if (!element.isCollapsed) {\n          didMutate = true;\n          element.isCollapsed = true;\n          const weightDelta = 1 - element.weight;\n\n          let parentElement = this._idToElement.get(element.parentID);\n\n          while (parentElement !== undefined) {\n            // We don't need to break on a collapsed parent in the same way as the expand case below.\n            // That's because collapsing a node doesn't \"bubble\" and affect its parents.\n            parentElement.weight += weightDelta;\n            parentElement = this._idToElement.get(parentElement.parentID);\n          }\n        }\n      } else {\n        let currentElement = element;\n\n        while (currentElement != null) {\n          const oldWeight = currentElement.isCollapsed ? 1 : currentElement.weight;\n\n          if (currentElement.isCollapsed) {\n            didMutate = true;\n            currentElement.isCollapsed = false;\n            const newWeight = currentElement.isCollapsed ? 1 : currentElement.weight;\n            const weightDelta = newWeight - oldWeight;\n\n            let parentElement = this._idToElement.get(currentElement.parentID);\n\n            while (parentElement !== undefined) {\n              parentElement.weight += weightDelta;\n\n              if (parentElement.isCollapsed) {\n                // It's important to break on a collapsed parent when expanding nodes.\n                // That's because expanding a node \"bubbles\" up and expands all parents as well.\n                // Breaking in this case prevents us from over-incrementing the expanded weights.\n                break;\n              }\n\n              parentElement = this._idToElement.get(parentElement.parentID);\n            }\n          }\n\n          currentElement = currentElement.parentID !== 0 ? this.getElementByID(currentElement.parentID) : null;\n        }\n      } // Only re-calculate weights and emit an \"update\" event if the store was mutated.\n\n\n      if (didMutate) {\n        let weightAcrossRoots = 0;\n\n        this._roots.forEach(rootID => {\n          const {\n            weight\n          } = this.getElementByID(rootID);\n          weightAcrossRoots += weight;\n        });\n\n        this._weightAcrossRoots = weightAcrossRoots; // The Tree context's search reducer expects an explicit list of ids for nodes that were added or removed.\n        // In this  case, we can pass it empty arrays since nodes in a collapsed tree are still there (just hidden).\n        // Updating the selected search index later may require auto-expanding a collapsed subtree though.\n\n        this.emit('mutated', [[], new Map()]);\n      }\n    }\n  }\n\n  _recursivelyUpdateSubtree(id, callback) {\n    const element = this._idToElement.get(id);\n\n    if (element) {\n      callback(element);\n      element.children.forEach(child => this._recursivelyUpdateSubtree(child, callback));\n    }\n  }\n\n  setShouldShowWarningsAndErrors(status) {\n    const previousStatus = this._shouldShowWarningsAndErrors;\n    this._shouldShowWarningsAndErrors = status;\n\n    if (previousStatus !== status) {\n      // Propagate to subscribers, although tree state has not changed\n      this.emit('mutated', [[], new Map()]);\n    }\n  } // The Store should never throw an Error without also emitting an event.\n  // Otherwise Store errors will be invisible to users,\n  // but the downstream errors they cause will be reported as bugs.\n  // For example, https://github.com/facebook/react/issues/21402\n  // Emitting an error event allows the ErrorBoundary to show the original error.\n\n\n  _throwAndEmitError(error) {\n    this.emit('error', error); // Throwing is still valuable for local development\n    // and for unit testing the Store itself.\n\n    throw error;\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy9zdG9yZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBV0E7O0FBR0E7QUFDQTtBQUNBO0FBTUE7QUFDQTs7QUFFQTtBQUVBOztBQXNCQTs7OztBQUlBO0FBaUJBO0FBQ0E7QUFLQTtBQUtBO0FBS0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBR0E7QUFTQTtBQVFBO0FBQ0E7QUFPQTtBQUNBOztBQURBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBO0FBNHFCQTs7QUFFQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBL3JCQTtBQWt0QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBdnRCQTtBQTB0QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUVBOztBQUVBOztBQUdBOztBQUdBO0FBQUE7QUFHQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBR0E7O0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVFBOzs7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTs7QUFFQTs7QUFDQTtBQUNBOztBQU1BO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBOztBQWdCQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBTUE7QUFDQTs7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBR0E7O0FBRUE7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQU1BO0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQU1BO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFsV0E7QUF3V0E7O0FBRUE7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBL3FDQTtBQXlyQ0E7QUFFQTtBQUNBOztBQTVyQ0E7QUErckNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTl0Q0E7QUFtdUNBO0FBRUE7QUFDQTs7QUF0dUNBO0FBeXVDQTtBQUVBO0FBQ0E7O0FBNXVDQTtBQSt1Q0E7QUFDQTtBQUNBOztBQWp2Q0E7QUFxdkNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBandDQTtBQW93Q0E7QUFHQTs7QUFDQTtBQUVBO0FBQ0E7O0FBM3dDQTtBQTh3Q0E7QUFDQTs7QUEvd0NBO0FBa3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFueUNBO0FBc3lDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM3lDQTtBQSt5Q0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFuekNBO0FBdXpDQTtBQUVBO0FBQ0E7QUFDQTs7QUF4ekNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBSUE7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTs7QUFRQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUlBOztBQUNBOztBQUlBOztBQUlBOztBQUtBOztBQUVBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFJQTtBQUlBOzs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFLQTtBQURBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBOzs7QUFDQTs7QUFHQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFHQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOzs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFNQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUZBOztBQUtBOztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7O0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTJCQTtBQUlBOztBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7O0FBZ25CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTs7QUF0NkNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL3N0b3JlLmpzP2ZiNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHtjb3B5fSBmcm9tICdjbGlwYm9hcmQtanMnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHtpbnNwZWN0fSBmcm9tICd1dGlsJztcbmltcG9ydCB7XG4gIFBST0ZJTElOR19GTEFHX0JBU0lDX1NVUFBPUlQsXG4gIFBST0ZJTElOR19GTEFHX1RJTUVMSU5FX1NVUFBPUlQsXG4gIFRSRUVfT1BFUkFUSU9OX0FERCxcbiAgVFJFRV9PUEVSQVRJT05fUkVNT1ZFLFxuICBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCxcbiAgVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTixcbiAgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSxcbiAgVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyxcbiAgVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTixcbn0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7RWxlbWVudFR5cGVSb290fSBmcm9tICcuLi9mcm9udGVuZC90eXBlcyc7XG5pbXBvcnQge1xuICBnZXRTYXZlZENvbXBvbmVudEZpbHRlcnMsXG4gIHNldFNhdmVkQ29tcG9uZW50RmlsdGVycyxcbiAgc2hhbGxvd0RpZmZlcnMsXG4gIHV0ZkRlY29kZVN0cmluZ1dpdGhSYW5nZXMsXG4gIHBhcnNlRWxlbWVudERpc3BsYXlOYW1lRnJvbUJhY2tlbmQsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7bG9jYWxTdG9yYWdlR2V0SXRlbSwgbG9jYWxTdG9yYWdlU2V0SXRlbX0gZnJvbSAnLi4vc3RvcmFnZSc7XG5pbXBvcnQge19fREVCVUdfX30gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7cHJpbnRTdG9yZX0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgUHJvZmlsZXJTdG9yZSBmcm9tICcuL1Byb2ZpbGVyU3RvcmUnO1xuaW1wb3J0IHtcbiAgQlJJREdFX1BST1RPQ09MLFxuICBjdXJyZW50QnJpZGdlUHJvdG9jb2wsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYnJpZGdlJztcbmltcG9ydCB7U3RyaWN0TW9kZX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5cbmltcG9ydCB0eXBlIHtcbiAgRWxlbWVudCxcbiAgQ29tcG9uZW50RmlsdGVyLFxuICBFbGVtZW50VHlwZSxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIEZyb250ZW5kQnJpZGdlLFxuICBCcmlkZ2VQcm90b2NvbCxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9icmlkZ2UnO1xuaW1wb3J0IFVuc3VwcG9ydGVkQnJpZGdlT3BlcmF0aW9uRXJyb3IgZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9VbnN1cHBvcnRlZEJyaWRnZU9wZXJhdGlvbkVycm9yJztcbmltcG9ydCB0eXBlIHtEZXZUb29sc0hvb2tTZXR0aW5nc30gZnJvbSAnLi4vYmFja2VuZC90eXBlcyc7XG5cbmNvbnN0IGRlYnVnID0gKG1ldGhvZE5hbWU6IHN0cmluZywgLi4uYXJnczogQXJyYXk8c3RyaW5nPikgPT4ge1xuICBpZiAoX19ERUJVR19fKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgJWNTdG9yZSAlYyR7bWV0aG9kTmFtZX1gLFxuICAgICAgJ2NvbG9yOiBncmVlbjsgZm9udC13ZWlnaHQ6IGJvbGQ7JyxcbiAgICAgICdmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgLi4uYXJncyxcbiAgICApO1xuICB9XG59O1xuXG5jb25zdCBMT0NBTF9TVE9SQUdFX0NPTExBUFNFX1JPT1RTX0JZX0RFRkFVTFRfS0VZID1cbiAgJ1JlYWN0OjpEZXZUb29sczo6Y29sbGFwc2VOb2Rlc0J5RGVmYXVsdCc7XG5jb25zdCBMT0NBTF9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSA9XG4gICdSZWFjdDo6RGV2VG9vbHM6OnJlY29yZENoYW5nZURlc2NyaXB0aW9ucyc7XG5cbnR5cGUgRXJyb3JBbmRXYXJuaW5nVHVwbGVzID0gQXJyYXk8e2lkOiBudW1iZXIsIGluZGV4OiBudW1iZXJ9PjtcblxuZXhwb3J0IHR5cGUgQ29uZmlnID0ge1xuICBjaGVja0JyaWRnZVByb3RvY29sQ29tcGF0aWJpbGl0eT86IGJvb2xlYW4sXG4gIGlzUHJvZmlsaW5nPzogYm9vbGVhbixcbiAgc3VwcG9ydHNJbnNwZWN0TWF0Y2hpbmdET01FbGVtZW50PzogYm9vbGVhbixcbiAgc3VwcG9ydHNDbGlja1RvSW5zcGVjdD86IGJvb2xlYW4sXG4gIHN1cHBvcnRzUmVsb2FkQW5kUHJvZmlsZT86IGJvb2xlYW4sXG4gIHN1cHBvcnRzVGltZWxpbmU/OiBib29sZWFuLFxuICBzdXBwb3J0c1RyYWNlVXBkYXRlcz86IGJvb2xlYW4sXG59O1xuXG5leHBvcnQgdHlwZSBDYXBhYmlsaXRpZXMgPSB7XG4gIHN1cHBvcnRzQmFzaWNQcm9maWxpbmc6IGJvb2xlYW4sXG4gIGhhc093bmVyTWV0YWRhdGE6IGJvb2xlYW4sXG4gIHN1cHBvcnRzU3RyaWN0TW9kZTogYm9vbGVhbixcbiAgc3VwcG9ydHNUaW1lbGluZTogYm9vbGVhbixcbn07XG5cbi8qKlxuICogVGhlIHN0b3JlIGlzIHRoZSBzaW5nbGUgc291cmNlIG9mIHRydXRoIGZvciB1cGRhdGVzIGZyb20gdGhlIGJhY2tlbmQuXG4gKiBDb250ZXh0UHJvdmlkZXJzIGNhbiBzdWJzY3JpYmUgdG8gdGhlIFN0b3JlIGZvciBzcGVjaWZpYyB0aGluZ3MgdGhleSB3YW50IHRvIHByb3ZpZGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JlIGV4dGVuZHMgRXZlbnRFbWl0dGVyPHtcbiAgYmFja2VuZFZlcnNpb246IFtdLFxuICBjb2xsYXBzZU5vZGVzQnlEZWZhdWx0OiBbXSxcbiAgY29tcG9uZW50RmlsdGVyczogW10sXG4gIGVycm9yOiBbRXJyb3JdLFxuICBob29rU2V0dGluZ3M6IFskUmVhZE9ubHk8RGV2VG9vbHNIb29rU2V0dGluZ3M+XSxcbiAgc2V0dGluZ3NVcGRhdGVkOiBbJFJlYWRPbmx5PERldlRvb2xzSG9va1NldHRpbmdzPl0sXG4gIG11dGF0ZWQ6IFtbQXJyYXk8bnVtYmVyPiwgTWFwPG51bWJlciwgbnVtYmVyPl1dLFxuICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM6IFtdLFxuICByb290czogW10sXG4gIHJvb3RTdXBwb3J0c0Jhc2ljUHJvZmlsaW5nOiBbXSxcbiAgcm9vdFN1cHBvcnRzVGltZWxpbmVQcm9maWxpbmc6IFtdLFxuICBzdXBwb3J0c05hdGl2ZVN0eWxlRWRpdG9yOiBbXSxcbiAgc3VwcG9ydHNSZWxvYWRBbmRQcm9maWxlOiBbXSxcbiAgdW5zdXBwb3J0ZWRCcmlkZ2VQcm90b2NvbERldGVjdGVkOiBbXSxcbiAgdW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb25EZXRlY3RlZDogW10sXG59PiB7XG4gIC8vIElmIHRoZSBiYWNrZW5kIHZlcnNpb24gaXMgbmV3IGVub3VnaCB0byByZXBvcnQgaXRzIChOUE0pIHZlcnNpb24sIHRoaXMgaXMgaXQuXG4gIC8vIFRoaXMgdmVyc2lvbiBtYXkgYmUgZGlzcGxheWVkIGJ5IHRoZSBmcm9udGVuZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICBfYmFja2VuZFZlcnNpb246IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIF9icmlkZ2U6IEZyb250ZW5kQnJpZGdlO1xuXG4gIC8vIENvbXB1dGVkIHdoZW5ldmVyIF9lcnJvcnNBbmRXYXJuaW5ncyBNYXAgY2hhbmdlcy5cbiAgX2NhY2hlZENvbXBvbmVudFdpdGhFcnJvckNvdW50OiBudW1iZXIgPSAwO1xuICBfY2FjaGVkQ29tcG9uZW50V2l0aFdhcm5pbmdDb3VudDogbnVtYmVyID0gMDtcbiAgX2NhY2hlZEVycm9yQW5kV2FybmluZ1R1cGxlczogRXJyb3JBbmRXYXJuaW5nVHVwbGVzIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gU2hvdWxkIG5ldyBub2RlcyBiZSBjb2xsYXBzZWQgYnkgZGVmYXVsdCB3aGVuIGFkZGVkIHRvIHRoZSB0cmVlP1xuICBfY29sbGFwc2VOb2Rlc0J5RGVmYXVsdDogYm9vbGVhbiA9IHRydWU7XG5cbiAgX2NvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj47XG5cbiAgLy8gTWFwIG9mIElEIHRvIG51bWJlciBvZiByZWNvcmRlZCBlcnJvciBhbmQgd2FybmluZyBtZXNzYWdlIElEcy5cbiAgX2Vycm9yc0FuZFdhcm5pbmdzOiBNYXA8bnVtYmVyLCB7ZXJyb3JDb3VudDogbnVtYmVyLCB3YXJuaW5nQ291bnQ6IG51bWJlcn0+ID1cbiAgICBuZXcgTWFwKCk7XG5cbiAgLy8gQXQgbGVhc3Qgb25lIG9mIHRoZSBpbmplY3RlZCByZW5kZXJlcnMgY29udGFpbnMgKERFViBvbmx5KSBvd25lciBtZXRhZGF0YS5cbiAgX2hhc093bmVyTWV0YWRhdGE6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBNYXAgb2YgSUQgdG8gKG11dGFibGUpIEVsZW1lbnQuXG4gIC8vIEVsZW1lbnRzIGFyZSBtdXRhdGVkIHRvIGF2b2lkIGV4Y2Vzc2l2ZSBjbG9uaW5nIGR1cmluZyB0cmVlIHVwZGF0ZXMuXG4gIC8vIFRoZSBJbnNwZWN0ZWRFbGVtZW50IFN1c3BlbnNlIGNhY2hlIGFsc28gcmVsaWVzIG9uIHRoaXMgbXV0YWJpbGl0eSBmb3IgaXRzIFdlYWtNYXAgdXNhZ2UuXG4gIF9pZFRvRWxlbWVudDogTWFwPG51bWJlciwgRWxlbWVudD4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gU2hvdWxkIHRoZSBSZWFjdCBOYXRpdmUgc3R5bGUgZWRpdG9yIHBhbmVsIGJlIHNob3duP1xuICBfaXNOYXRpdmVTdHlsZUVkaXRvclN1cHBvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIF9uYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlczogJFJlYWRPbmx5QXJyYXk8c3RyaW5nPiB8IG51bGwgPSBudWxsO1xuXG4gIC8vIE9sZGVyIGJhY2tlbmRzIGRvbid0IHN1cHBvcnQgYW4gZXhwbGljaXQgYnJpZGdlIHByb3RvY29sLFxuICAvLyBzbyB3ZSBzaG91bGQgdGltZW91dCBldmVudHVhbGx5IGFuZCBzaG93IGEgZG93bmdyYWRlIG1lc3NhZ2UuXG4gIF9vbkJyaWRnZVByb3RvY29sVGltZW91dElEOiBUaW1lb3V0SUQgfCBudWxsID0gbnVsbDtcblxuICAvLyBNYXAgb2YgZWxlbWVudCAoaWQpIHRvIHRoZSBzZXQgb2YgZWxlbWVudHMgKGlkcykgaXQgb3ducy5cbiAgLy8gVGhpcyBtYXAgZW5hYmxlcyBnZXRPd25lcnNMaXN0Rm9yRWxlbWVudCgpIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIGVudGlyZSB0cmVlLlxuICBfb3duZXJzTWFwOiBNYXA8bnVtYmVyLCBTZXQ8bnVtYmVyPj4gPSBuZXcgTWFwKCk7XG5cbiAgX3Byb2ZpbGVyU3RvcmU6IFByb2ZpbGVyU3RvcmU7XG5cbiAgX3JlY29yZENoYW5nZURlc2NyaXB0aW9uczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIEluY3JlbWVudGVkIGVhY2ggdGltZSB0aGUgc3RvcmUgaXMgbXV0YXRlZC5cbiAgLy8gVGhpcyBlbmFibGVzIGEgcGFzc2l2ZSBlZmZlY3QgdG8gZGV0ZWN0IGEgbXV0YXRpb24gYmV0d2VlbiByZW5kZXIgYW5kIGNvbW1pdCBwaGFzZS5cbiAgX3JldmlzaW9uOiBudW1iZXIgPSAwO1xuXG4gIC8vIFRoaXMgQXJyYXkgbXVzdCBiZSB0cmVhdGVkIGFzIGltbXV0YWJsZSFcbiAgLy8gUGFzc2l2ZSBlZmZlY3RzIHdpbGwgY2hlY2sgaXQgZm9yIGNoYW5nZXMgYmV0d2VlbiByZW5kZXIgYW5kIG1vdW50LlxuICBfcm9vdHM6ICRSZWFkT25seUFycmF5PG51bWJlcj4gPSBbXTtcblxuICBfcm9vdElEVG9DYXBhYmlsaXRpZXM6IE1hcDxudW1iZXIsIENhcGFiaWxpdGllcz4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gUmVuZGVyZXIgSUQgaXMgbmVlZGVkIHRvIHN1cHBvcnQgaW5zcGVjdGlvbiBmaWJlciBwcm9wcywgc3RhdGUsIGFuZCBob29rcy5cbiAgX3Jvb3RJRFRvUmVuZGVyZXJJRDogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXAoKTtcblxuICAvLyBUaGVzZSBvcHRpb25zIG1heSBiZSBpbml0aWFsbHkgc2V0IGJ5IGEgY29uZmlndXJhdGlvbiBvcHRpb24gd2hlbiBjb25zdHJ1Y3RpbmcgdGhlIFN0b3JlLlxuICBfc3VwcG9ydHNJbnNwZWN0TWF0Y2hpbmdET01FbGVtZW50OiBib29sZWFuID0gZmFsc2U7XG4gIF9zdXBwb3J0c0NsaWNrVG9JbnNwZWN0OiBib29sZWFuID0gZmFsc2U7XG4gIF9zdXBwb3J0c1RpbWVsaW5lOiBib29sZWFuID0gZmFsc2U7XG4gIF9zdXBwb3J0c1RyYWNlVXBkYXRlczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIF9pc1JlbG9hZEFuZFByb2ZpbGVGcm9udGVuZFN1cHBvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBfaXNSZWxvYWRBbmRQcm9maWxlQmFja2VuZFN1cHBvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIFRoZXNlIG9wdGlvbnMgZGVmYXVsdCB0byBmYWxzZSBidXQgbWF5IGJlIHVwZGF0ZWQgYXMgcm9vdHMgYXJlIGFkZGVkIGFuZCByZW1vdmVkLlxuICBfcm9vdFN1cHBvcnRzQmFzaWNQcm9maWxpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgX3Jvb3RTdXBwb3J0c1RpbWVsaW5lUHJvZmlsaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgX2JyaWRnZVByb3RvY29sOiBCcmlkZ2VQcm90b2NvbCB8IG51bGwgPSBudWxsO1xuICBfdW5zdXBwb3J0ZWRCcmlkZ2VQcm90b2NvbERldGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG4gIF91bnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbkRldGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gVG90YWwgbnVtYmVyIG9mIHZpc2libGUgZWxlbWVudHMgKHdpdGhpbiBhbGwgcm9vdHMpLlxuICAvLyBVc2VkIGZvciB3aW5kb3dpbmcgcHVycG9zZXMuXG4gIF93ZWlnaHRBY3Jvc3NSb290czogbnVtYmVyID0gMDtcblxuICBfc2hvdWxkQ2hlY2tCcmlkZ2VQcm90b2NvbENvbXBhdGliaWxpdHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgX2hvb2tTZXR0aW5nczogJFJlYWRPbmx5PERldlRvb2xzSG9va1NldHRpbmdzPiB8IG51bGwgPSBudWxsO1xuICBfc2hvdWxkU2hvd1dhcm5pbmdzQW5kRXJyb3JzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoYnJpZGdlOiBGcm9udGVuZEJyaWRnZSwgY29uZmlnPzogQ29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCdjb25zdHJ1Y3RvcicsICdzdWJzY3JpYmluZyB0byBCcmlkZ2UnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsYXBzZU5vZGVzQnlEZWZhdWx0ID1cbiAgICAgIGxvY2FsU3RvcmFnZUdldEl0ZW0oTE9DQUxfU1RPUkFHRV9DT0xMQVBTRV9ST09UU19CWV9ERUZBVUxUX0tFWSkgPT09XG4gICAgICAndHJ1ZSc7XG5cbiAgICB0aGlzLl9yZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPVxuICAgICAgbG9jYWxTdG9yYWdlR2V0SXRlbShMT0NBTF9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSkgPT09XG4gICAgICAndHJ1ZSc7XG5cbiAgICB0aGlzLl9jb21wb25lbnRGaWx0ZXJzID0gZ2V0U2F2ZWRDb21wb25lbnRGaWx0ZXJzKCk7XG5cbiAgICBsZXQgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgIGlzUHJvZmlsaW5nID0gY29uZmlnLmlzUHJvZmlsaW5nID09PSB0cnVlO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHN1cHBvcnRzSW5zcGVjdE1hdGNoaW5nRE9NRWxlbWVudCxcbiAgICAgICAgc3VwcG9ydHNDbGlja1RvSW5zcGVjdCxcbiAgICAgICAgc3VwcG9ydHNSZWxvYWRBbmRQcm9maWxlLFxuICAgICAgICBzdXBwb3J0c1RpbWVsaW5lLFxuICAgICAgICBzdXBwb3J0c1RyYWNlVXBkYXRlcyxcbiAgICAgICAgY2hlY2tCcmlkZ2VQcm90b2NvbENvbXBhdGliaWxpdHksXG4gICAgICB9ID0gY29uZmlnO1xuICAgICAgaWYgKHN1cHBvcnRzSW5zcGVjdE1hdGNoaW5nRE9NRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9zdXBwb3J0c0luc3BlY3RNYXRjaGluZ0RPTUVsZW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzQ2xpY2tUb0luc3BlY3QpIHtcbiAgICAgICAgdGhpcy5fc3VwcG9ydHNDbGlja1RvSW5zcGVjdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHNSZWxvYWRBbmRQcm9maWxlKSB7XG4gICAgICAgIHRoaXMuX2lzUmVsb2FkQW5kUHJvZmlsZUZyb250ZW5kU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c1RpbWVsaW5lKSB7XG4gICAgICAgIHRoaXMuX3N1cHBvcnRzVGltZWxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzVHJhY2VVcGRhdGVzKSB7XG4gICAgICAgIHRoaXMuX3N1cHBvcnRzVHJhY2VVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0JyaWRnZVByb3RvY29sQ29tcGF0aWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9zaG91bGRDaGVja0JyaWRnZVByb3RvY29sQ29tcGF0aWJpbGl0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fYnJpZGdlID0gYnJpZGdlO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3BlcmF0aW9ucycsIHRoaXMub25CcmlkZ2VPcGVyYXRpb25zKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoXG4gICAgICAnb3ZlcnJpZGVDb21wb25lbnRGaWx0ZXJzJyxcbiAgICAgIHRoaXMub25CcmlkZ2VPdmVycmlkZUNvbXBvbmVudEZpbHRlcnMsXG4gICAgKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgdGhpcy5vbkJyaWRnZVNodXRkb3duKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoXG4gICAgICAnaXNSZWxvYWRBbmRQcm9maWxlU3VwcG9ydGVkQnlCYWNrZW5kJyxcbiAgICAgIHRoaXMub25CYWNrZW5kUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZCxcbiAgICApO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcihcbiAgICAgICdpc05hdGl2ZVN0eWxlRWRpdG9yU3VwcG9ydGVkJyxcbiAgICAgIHRoaXMub25CcmlkZ2VOYXRpdmVTdHlsZUVkaXRvclN1cHBvcnRlZCxcbiAgICApO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcihcbiAgICAgICd1bnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbicsXG4gICAgICB0aGlzLm9uQnJpZGdlVW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb24sXG4gICAgKTtcblxuICAgIHRoaXMuX3Byb2ZpbGVyU3RvcmUgPSBuZXcgUHJvZmlsZXJTdG9yZShicmlkZ2UsIHRoaXMsIGlzUHJvZmlsaW5nKTtcblxuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignYmFja2VuZFZlcnNpb24nLCB0aGlzLm9uQnJpZGdlQmFja2VuZFZlcnNpb24pO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignc2F2ZVRvQ2xpcGJvYXJkJywgdGhpcy5vblNhdmVUb0NsaXBib2FyZCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdob29rU2V0dGluZ3MnLCB0aGlzLm9uSG9va1NldHRpbmdzKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2JhY2tlbmRJbml0aWFsaXplZCcsIHRoaXMub25CYWNrZW5kSW5pdGlhbGl6ZWQpO1xuICB9XG5cbiAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgaW4gdGVzdHMgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICBhc3NlcnRFeHBlY3RlZFJvb3RNYXBTaXplcygpIHtcbiAgICBpZiAodGhpcy5yb290cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFRoZSBvbmx5IHNhZmUgdGltZSB0byBhc3NlcnQgdGhlc2UgbWFwcyBhcmUgZW1wdHkgaXMgd2hlbiB0aGUgc3RvcmUgaXMgZW1wdHkuXG4gICAgICB0aGlzLmFzc2VydE1hcFNpemVNYXRjaGVzUm9vdENvdW50KHRoaXMuX2lkVG9FbGVtZW50LCAnX2lkVG9FbGVtZW50Jyk7XG4gICAgICB0aGlzLmFzc2VydE1hcFNpemVNYXRjaGVzUm9vdENvdW50KHRoaXMuX293bmVyc01hcCwgJ19vd25lcnNNYXAnKTtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBtYXBzIHNob3VsZCBhbHdheXMgYmUgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgbnVtYmVyIG9mIHJvb3RzXG4gICAgdGhpcy5hc3NlcnRNYXBTaXplTWF0Y2hlc1Jvb3RDb3VudChcbiAgICAgIHRoaXMuX3Jvb3RJRFRvQ2FwYWJpbGl0aWVzLFxuICAgICAgJ19yb290SURUb0NhcGFiaWxpdGllcycsXG4gICAgKTtcbiAgICB0aGlzLmFzc2VydE1hcFNpemVNYXRjaGVzUm9vdENvdW50KFxuICAgICAgdGhpcy5fcm9vdElEVG9SZW5kZXJlcklELFxuICAgICAgJ19yb290SURUb1JlbmRlcmVySUQnLFxuICAgICk7XG4gIH1cblxuICAvLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiB0ZXN0cyB0byBhdm9pZCBtZW1vcnkgbGVha3MuXG4gIGFzc2VydE1hcFNpemVNYXRjaGVzUm9vdENvdW50KG1hcDogTWFwPGFueSwgYW55PiwgbWFwTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRTaXplID0gdGhpcy5yb290cy5sZW5ndGg7XG4gICAgaWYgKG1hcC5zaXplICE9PSBleHBlY3RlZFNpemUpIHtcbiAgICAgIHRoaXMuX3Rocm93QW5kRW1pdEVycm9yKFxuICAgICAgICBFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgJHttYXBOYW1lfSB0byBjb250YWluICR7ZXhwZWN0ZWRTaXplfSBpdGVtcywgYnV0IGl0IGNvbnRhaW5zICR7XG4gICAgICAgICAgICBtYXAuc2l6ZVxuICAgICAgICAgIH0gaXRlbXNcXG5cXG4ke2luc3BlY3QobWFwLCB7XG4gICAgICAgICAgICBkZXB0aDogMjAsXG4gICAgICAgICAgfSl9YCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGJhY2tlbmRWZXJzaW9uKCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9iYWNrZW5kVmVyc2lvbjtcbiAgfVxuXG4gIGdldCBjb2xsYXBzZU5vZGVzQnlEZWZhdWx0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZU5vZGVzQnlEZWZhdWx0O1xuICB9XG4gIHNldCBjb2xsYXBzZU5vZGVzQnlEZWZhdWx0KHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5fY29sbGFwc2VOb2Rlc0J5RGVmYXVsdCA9IHZhbHVlO1xuXG4gICAgbG9jYWxTdG9yYWdlU2V0SXRlbShcbiAgICAgIExPQ0FMX1NUT1JBR0VfQ09MTEFQU0VfUk9PVFNfQllfREVGQVVMVF9LRVksXG4gICAgICB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgKTtcblxuICAgIHRoaXMuZW1pdCgnY29sbGFwc2VOb2Rlc0J5RGVmYXVsdCcpO1xuICB9XG5cbiAgZ2V0IGNvbXBvbmVudEZpbHRlcnMoKTogQXJyYXk8Q29tcG9uZW50RmlsdGVyPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudEZpbHRlcnM7XG4gIH1cbiAgc2V0IGNvbXBvbmVudEZpbHRlcnModmFsdWU6IEFycmF5PENvbXBvbmVudEZpbHRlcj4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fcHJvZmlsZXJTdG9yZS5pc1Byb2ZpbGluZ0Jhc2VkT25Vc2VySW5wdXQpIHtcbiAgICAgIC8vIFJlLW1vdW50aW5nIGEgdHJlZSB3aGlsZSBwcm9maWxpbmcgaXMgaW4gcHJvZ3Jlc3MgbWlnaHQgYnJlYWsgYSBsb3Qgb2YgYXNzdW1wdGlvbnMuXG4gICAgICAvLyBJZiBuZWNlc3NhcnksIHdlIGNvdWxkIHN1cHBvcnQgdGhpcy0gYnV0IGl0IGRvZXNuJ3Qgc2VlbSBsaWtlIGEgbmVjZXNzYXJ5IHVzZSBjYXNlLlxuICAgICAgdGhpcy5fdGhyb3dBbmRFbWl0RXJyb3IoXG4gICAgICAgIEVycm9yKCdDYW5ub3QgbW9kaWZ5IGZpbHRlciBwcmVmZXJlbmNlcyB3aGlsZSBwcm9maWxpbmcnKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIHVwZGF0ZXMgYXJlIGV4cGVuc2l2ZSB0byBhcHBseSAoc2luY2UgdGhleSBpbXBhY3QgdGhlIGVudGlyZSB0cmVlKS5cbiAgICAvLyBMZXQncyBkZXRlcm1pbmUgaWYgdGhleSd2ZSBjaGFuZ2VkIGFuZCBhdm9pZCBkb2luZyB0aGlzIHdvcmsgaWYgdGhleSBoYXZlbid0LlxuICAgIGNvbnN0IHByZXZFbmFibGVkQ29tcG9uZW50RmlsdGVycyA9IHRoaXMuX2NvbXBvbmVudEZpbHRlcnMuZmlsdGVyKFxuICAgICAgZmlsdGVyID0+IGZpbHRlci5pc0VuYWJsZWQsXG4gICAgKTtcbiAgICBjb25zdCBuZXh0RW5hYmxlZENvbXBvbmVudEZpbHRlcnMgPSB2YWx1ZS5maWx0ZXIoXG4gICAgICBmaWx0ZXIgPT4gZmlsdGVyLmlzRW5hYmxlZCxcbiAgICApO1xuICAgIGxldCBoYXZlRW5hYmxlZEZpbHRlcnNDaGFuZ2VkID1cbiAgICAgIHByZXZFbmFibGVkQ29tcG9uZW50RmlsdGVycy5sZW5ndGggIT09IG5leHRFbmFibGVkQ29tcG9uZW50RmlsdGVycy5sZW5ndGg7XG4gICAgaWYgKCFoYXZlRW5hYmxlZEZpbHRlcnNDaGFuZ2VkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRFbmFibGVkQ29tcG9uZW50RmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2RmlsdGVyID0gcHJldkVuYWJsZWRDb21wb25lbnRGaWx0ZXJzW2ldO1xuICAgICAgICBjb25zdCBuZXh0RmlsdGVyID0gbmV4dEVuYWJsZWRDb21wb25lbnRGaWx0ZXJzW2ldO1xuICAgICAgICBpZiAoc2hhbGxvd0RpZmZlcnMocHJldkZpbHRlciwgbmV4dEZpbHRlcikpIHtcbiAgICAgICAgICBoYXZlRW5hYmxlZEZpbHRlcnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NvbXBvbmVudEZpbHRlcnMgPSB2YWx1ZTtcblxuICAgIC8vIFVwZGF0ZSBwZXJzaXN0ZWQgZmlsdGVyIHByZWZlcmVuY2VzIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2UuXG4gICAgc2V0U2F2ZWRDb21wb25lbnRGaWx0ZXJzKHZhbHVlKTtcblxuICAgIC8vIE5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCBmaWx0ZXIgcHJlZmVyZW5jZXMgaGF2ZSBjaGFuZ2VkLlxuICAgIC8vIFRoaXMgaXMgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbjsgaXQgdW5tb3VudHMgYW5kIHJlbW91bnRzIHRoZSBlbnRpcmUgdHJlZSxcbiAgICAvLyBzbyBvbmx5IGRvIGl0IGlmIHRoZSBzZXQgb2YgZW5hYmxlZCBjb21wb25lbnQgZmlsdGVycyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoaGF2ZUVuYWJsZWRGaWx0ZXJzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYnJpZGdlLnNlbmQoJ3VwZGF0ZUNvbXBvbmVudEZpbHRlcnMnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdjb21wb25lbnRGaWx0ZXJzJyk7XG4gIH1cblxuICBnZXQgYnJpZGdlUHJvdG9jb2woKTogQnJpZGdlUHJvdG9jb2wgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5fYnJpZGdlUHJvdG9jb2w7XG4gIH1cblxuICBnZXQgY29tcG9uZW50V2l0aEVycm9yQ291bnQoKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMuX3Nob3VsZFNob3dXYXJuaW5nc0FuZEVycm9ycykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBvbmVudFdpdGhFcnJvckNvdW50O1xuICB9XG5cbiAgZ2V0IGNvbXBvbmVudFdpdGhXYXJuaW5nQ291bnQoKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMuX3Nob3VsZFNob3dXYXJuaW5nc0FuZEVycm9ycykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBvbmVudFdpdGhXYXJuaW5nQ291bnQ7XG4gIH1cblxuICBnZXQgZGlzcGxheWluZ0Vycm9yc0FuZFdhcm5pbmdzRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvdWxkU2hvd1dhcm5pbmdzQW5kRXJyb3JzO1xuICB9XG5cbiAgZ2V0IGhhc093bmVyTWV0YWRhdGEoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc093bmVyTWV0YWRhdGE7XG4gIH1cblxuICBnZXQgbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMoKTogJFJlYWRPbmx5QXJyYXk8c3RyaW5nPiB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9uYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcztcbiAgfVxuXG4gIGdldCBudW1FbGVtZW50cygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl93ZWlnaHRBY3Jvc3NSb290cztcbiAgfVxuXG4gIGdldCBwcm9maWxlclN0b3JlKCk6IFByb2ZpbGVyU3RvcmUge1xuICAgIHJldHVybiB0aGlzLl9wcm9maWxlclN0b3JlO1xuICB9XG5cbiAgZ2V0IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zO1xuICB9XG4gIHNldCByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnModmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLl9yZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPSB2YWx1ZTtcblxuICAgIGxvY2FsU3RvcmFnZVNldEl0ZW0oXG4gICAgICBMT0NBTF9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSxcbiAgICAgIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICApO1xuXG4gICAgdGhpcy5lbWl0KCdyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMnKTtcbiAgfVxuXG4gIGdldCByZXZpc2lvbigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9yZXZpc2lvbjtcbiAgfVxuXG4gIGdldCByb290SURUb1JlbmRlcmVySUQoKTogTWFwPG51bWJlciwgbnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RJRFRvUmVuZGVyZXJJRDtcbiAgfVxuXG4gIGdldCByb290cygpOiAkUmVhZE9ubHlBcnJheTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdHM7XG4gIH1cblxuICAvLyBBdCBsZWFzdCBvbmUgb2YgdGhlIGN1cnJlbnRseSBtb3VudGVkIHJvb3RzIHN1cHBvcnQgdGhlIExlZ2FjeSBwcm9maWxlci5cbiAgZ2V0IHJvb3RTdXBwb3J0c0Jhc2ljUHJvZmlsaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9yb290U3VwcG9ydHNCYXNpY1Byb2ZpbGluZztcbiAgfVxuXG4gIC8vIEF0IGxlYXN0IG9uZSBvZiB0aGUgY3VycmVudGx5IG1vdW50ZWQgcm9vdHMgc3VwcG9ydCB0aGUgVGltZWxpbmUgcHJvZmlsZXIuXG4gIGdldCByb290U3VwcG9ydHNUaW1lbGluZVByb2ZpbGluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdFN1cHBvcnRzVGltZWxpbmVQcm9maWxpbmc7XG4gIH1cblxuICBnZXQgc3VwcG9ydHNJbnNwZWN0TWF0Y2hpbmdET01FbGVtZW50KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdXBwb3J0c0luc3BlY3RNYXRjaGluZ0RPTUVsZW1lbnQ7XG4gIH1cblxuICBnZXQgc3VwcG9ydHNDbGlja1RvSW5zcGVjdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3VwcG9ydHNDbGlja1RvSW5zcGVjdDtcbiAgfVxuXG4gIGdldCBzdXBwb3J0c05hdGl2ZVN0eWxlRWRpdG9yKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pc05hdGl2ZVN0eWxlRWRpdG9yU3VwcG9ydGVkO1xuICB9XG5cbiAgZ2V0IHN1cHBvcnRzUmVsb2FkQW5kUHJvZmlsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5faXNSZWxvYWRBbmRQcm9maWxlRnJvbnRlbmRTdXBwb3J0ZWQgJiZcbiAgICAgIHRoaXMuX2lzUmVsb2FkQW5kUHJvZmlsZUJhY2tlbmRTdXBwb3J0ZWRcbiAgICApO1xuICB9XG5cbiAgLy8gVGhpcyBidWlsZCBvZiBEZXZUb29scyBzdXBwb3J0cyB0aGUgVGltZWxpbmUgcHJvZmlsZXIuXG4gIC8vIFRoaXMgaXMgYSBzdGF0aWMgZmxhZywgY29udHJvbGxlZCBieSB0aGUgU3RvcmUgY29uZmlnLlxuICBnZXQgc3VwcG9ydHNUaW1lbGluZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3VwcG9ydHNUaW1lbGluZTtcbiAgfVxuXG4gIGdldCBzdXBwb3J0c1RyYWNlVXBkYXRlcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3VwcG9ydHNUcmFjZVVwZGF0ZXM7XG4gIH1cblxuICBnZXQgdW5zdXBwb3J0ZWRCcmlkZ2VQcm90b2NvbERldGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl91bnN1cHBvcnRlZEJyaWRnZVByb3RvY29sRGV0ZWN0ZWQ7XG4gIH1cblxuICBnZXQgdW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb25EZXRlY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fdW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb25EZXRlY3RlZDtcbiAgfVxuXG4gIGNvbnRhaW5zRWxlbWVudChpZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2lkVG9FbGVtZW50LmhhcyhpZCk7XG4gIH1cblxuICBnZXRFbGVtZW50QXRJbmRleChpbmRleDogbnVtYmVyKTogRWxlbWVudCB8IG51bGwge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5udW1FbGVtZW50cykge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgSW52YWxpZCBpbmRleCAke2luZGV4fSBzcGVjaWZpZWQ7IHN0b3JlIGNvbnRhaW5zICR7dGhpcy5udW1FbGVtZW50c30gaXRlbXMuYCxcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEZpbmQgd2hpY2ggcm9vdCB0aGlzIGVsZW1lbnQgaXMgaW4uLi5cbiAgICBsZXQgcm9vdDtcbiAgICBsZXQgcm9vdFdlaWdodCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgcm9vdElEID0gdGhpcy5fcm9vdHNbaV07XG4gICAgICByb290ID0gdGhpcy5faWRUb0VsZW1lbnQuZ2V0KHJvb3RJRCk7XG5cbiAgICAgIGlmIChyb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dBbmRFbWl0RXJyb3IoXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBgQ291bGRuJ3QgZmluZCByb290IHdpdGggaWQgXCIke3Jvb3RJRH1cIjogbm8gbWF0Y2hpbmcgbm9kZSB3YXMgZm91bmQgaW4gdGhlIFN0b3JlLmAsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvb3QuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocm9vdFdlaWdodCArIHJvb3Qud2VpZ2h0ID4gaW5kZXgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290V2VpZ2h0ICs9IHJvb3Qud2VpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGVsZW1lbnQgaW4gdGhlIHRyZWUgdXNpbmcgdGhlIHdlaWdodCBvZiBlYWNoIG5vZGUuLi5cbiAgICAvLyBTa2lwIG92ZXIgdGhlIHJvb3QgaXRzZWxmLCBiZWNhdXNlIHJvb3RzIGFyZW4ndCB2aXNpYmxlIGluIHRoZSBFbGVtZW50cyB0cmVlLlxuICAgIGxldCBjdXJyZW50RWxlbWVudDogRWxlbWVudCA9IHJvb3Q7XG4gICAgbGV0IGN1cnJlbnRXZWlnaHQgPSByb290V2VpZ2h0IC0gMTtcblxuICAgIHdoaWxlIChpbmRleCAhPT0gY3VycmVudFdlaWdodCkge1xuICAgICAgY29uc3QgbnVtQ2hpbGRyZW4gPSBjdXJyZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNoaWxkcmVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGRJRCA9IGN1cnJlbnRFbGVtZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2lkVG9FbGVtZW50LmdldChjaGlsZElEKTtcblxuICAgICAgICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93QW5kRW1pdEVycm9yKFxuICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgIGBDb3VsZG4ndCBjaGlsZCBlbGVtZW50IHdpdGggaWQgXCIke2NoaWxkSUR9XCI6IG5vIG1hdGNoaW5nIG5vZGUgd2FzIGZvdW5kIGluIHRoZSBTdG9yZS5gLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZFdlaWdodCA9IGNoaWxkLmlzQ29sbGFwc2VkID8gMSA6IGNoaWxkLndlaWdodDtcblxuICAgICAgICBpZiAoaW5kZXggPD0gY3VycmVudFdlaWdodCArIGNoaWxkV2VpZ2h0KSB7XG4gICAgICAgICAgY3VycmVudFdlaWdodCsrO1xuICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFdlaWdodCArPSBjaGlsZFdlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50RWxlbWVudCB8fCBudWxsO1xuICB9XG5cbiAgZ2V0RWxlbWVudElEQXRJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudEF0SW5kZXgoaW5kZXgpO1xuICAgIHJldHVybiBlbGVtZW50ID09PSBudWxsID8gbnVsbCA6IGVsZW1lbnQuaWQ7XG4gIH1cblxuICBnZXRFbGVtZW50QnlJRChpZDogbnVtYmVyKTogRWxlbWVudCB8IG51bGwge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQoaWQpO1xuICAgIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTm8gZWxlbWVudCBmb3VuZCB3aXRoIGlkIFwiJHtpZH1cImApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgdHVwbGUgb2YgW2lkLCBpbmRleF1cbiAgZ2V0RWxlbWVudHNXaXRoRXJyb3JzQW5kV2FybmluZ3MoKTogRXJyb3JBbmRXYXJuaW5nVHVwbGVzIHtcbiAgICBpZiAoIXRoaXMuX3Nob3VsZFNob3dXYXJuaW5nc0FuZEVycm9ycykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWNoZWRFcnJvckFuZFdhcm5pbmdUdXBsZXMgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRFcnJvckFuZFdhcm5pbmdUdXBsZXM7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JBbmRXYXJuaW5nVHVwbGVzOiBFcnJvckFuZFdhcm5pbmdUdXBsZXMgPSBbXTtcblxuICAgIHRoaXMuX2Vycm9yc0FuZFdhcm5pbmdzLmZvckVhY2goKF8sIGlkKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhPZkVsZW1lbnRJRChpZCk7XG4gICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgIGxldCBoaWdoID0gZXJyb3JBbmRXYXJuaW5nVHVwbGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTtcbiAgICAgICAgICBpZiAoZXJyb3JBbmRXYXJuaW5nVHVwbGVzW21pZF0uaW5kZXggPiBpbmRleCkge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvckFuZFdhcm5pbmdUdXBsZXMuc3BsaWNlKGxvdywgMCwge2lkLCBpbmRleH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FjaGUgZm9yIGxhdGVyIChhdCBsZWFzdCB1bnRpbCB0aGUgdHJlZSBjaGFuZ2VzIGFnYWluKS5cbiAgICB0aGlzLl9jYWNoZWRFcnJvckFuZFdhcm5pbmdUdXBsZXMgPSBlcnJvckFuZFdhcm5pbmdUdXBsZXM7XG4gICAgcmV0dXJuIGVycm9yQW5kV2FybmluZ1R1cGxlcztcbiAgfVxuXG4gIGdldEVycm9yQW5kV2FybmluZ0NvdW50Rm9yRWxlbWVudElEKGlkOiBudW1iZXIpOiB7XG4gICAgZXJyb3JDb3VudDogbnVtYmVyLFxuICAgIHdhcm5pbmdDb3VudDogbnVtYmVyLFxuICB9IHtcbiAgICBpZiAoIXRoaXMuX3Nob3VsZFNob3dXYXJuaW5nc0FuZEVycm9ycykge1xuICAgICAgcmV0dXJuIHtlcnJvckNvdW50OiAwLCB3YXJuaW5nQ291bnQ6IDB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9lcnJvcnNBbmRXYXJuaW5ncy5nZXQoaWQpIHx8IHtlcnJvckNvdW50OiAwLCB3YXJuaW5nQ291bnQ6IDB9O1xuICB9XG5cbiAgZ2V0SW5kZXhPZkVsZW1lbnRJRChpZDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudEJ5SUQoaWQpO1xuXG4gICAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudC5wYXJlbnRJRCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gV2FsayB1cCB0aGUgdHJlZSB0byB0aGUgcm9vdC5cbiAgICAvLyBJbmNyZW1lbnQgdGhlIGluZGV4IGJ5IG9uZSBmb3IgZWFjaCBub2RlIHdlIGVuY291bnRlcixcbiAgICAvLyBhbmQgYnkgdGhlIHdlaWdodCBvZiBhbGwgbm9kZXMgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbnQgb25lLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGEgcmVsYXRpdmVseSBmYXN0IHdheSBvZiBkZXRlcm1pbmluZyB0aGUgaW5kZXggb2YgYSBub2RlIHdpdGhpbiB0aGUgdHJlZS5cbiAgICBsZXQgcHJldmlvdXNJRCA9IGlkO1xuICAgIGxldCBjdXJyZW50SUQgPSBlbGVtZW50LnBhcmVudElEO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQoY3VycmVudElEKTtcbiAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtjaGlsZHJlbn0gPSBjdXJyZW50O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZElEID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZElEID09PSBwcmV2aW91c0lEKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2lkVG9FbGVtZW50LmdldChjaGlsZElEKTtcbiAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ICs9IGNoaWxkLmlzQ29sbGFwc2VkID8gMSA6IGNoaWxkLndlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQucGFyZW50SUQgPT09IDApIHtcbiAgICAgICAgLy8gV2UgZm91bmQgdGhlIHJvb3Q7IHN0b3AgY3Jhd2xpbmcuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpbmRleCsrO1xuXG4gICAgICBwcmV2aW91c0lEID0gY3VycmVudC5pZDtcbiAgICAgIGN1cnJlbnRJRCA9IGN1cnJlbnQucGFyZW50SUQ7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGN1cnJlbnQgSUQgaXMgYSByb290IChmcm9tIHRoZSBwcmV2aW91cyBsb29wKS5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gb2Zmc2V0IHRoZSBpbmRleCBieSBwcmV2aW91cyByb290IHdlaWdodHMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgcm9vdElEID0gdGhpcy5fcm9vdHNbaV07XG4gICAgICBpZiAocm9vdElEID09PSBjdXJyZW50SUQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQocm9vdElEKTtcbiAgICAgIGlmIChyb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IHJvb3Qud2VpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGdldE93bmVyc0xpc3RGb3JFbGVtZW50KG93bmVySUQ6IG51bWJlcik6IEFycmF5PEVsZW1lbnQ+IHtcbiAgICBjb25zdCBsaXN0OiBBcnJheTxFbGVtZW50PiA9IFtdO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQob3duZXJJRCk7XG4gICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgLi4uZWxlbWVudCxcbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdW5zb3J0ZWRJRHMgPSB0aGlzLl9vd25lcnNNYXAuZ2V0KG93bmVySUQpO1xuICAgICAgaWYgKHVuc29ydGVkSURzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZGVwdGhNYXA6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwKFtbb3duZXJJRCwgMF1dKTtcblxuICAgICAgICAvLyBJdGVtcyBpbiBhIHNldCBhcmUgb3JkZXJlZCBiYXNlZCBvbiBpbnNlcnRpb24uXG4gICAgICAgIC8vIFRoaXMgZG9lcyBub3QgY29ycmVsYXRlIHdpdGggdGhlaXIgb3JkZXIgaW4gdGhlIHRyZWUuXG4gICAgICAgIC8vIFNvIGZpcnN0IHdlIG5lZWQgdG8gb3JkZXIgdGhlbS5cbiAgICAgICAgLy8gSSB3aXNoIHdlIGNvdWxkIGF2b2lkIHRoaXMgc29ydGluZyBvcGVyYXRpb247IHdlIGNvdWxkIHNvcnQgYXQgaW5zZXJ0aW9uIHRpbWUsXG4gICAgICAgIC8vIGJ1dCB0aGVuIHdlJ2QgaGF2ZSB0byBwYXkgc29ydGluZyBjb3N0cyBldmVuIGlmIHRoZSBvd25lcnMgbGlzdCB3YXMgbmV2ZXIgdXNlZC5cbiAgICAgICAgLy8gU2VlbXMgYmV0dGVyIHRvIGRlZmVyIHRoZSBjb3N0LCBzaW5jZSB0aGUgc2V0IG9mIGlkcyBpcyBwcm9iYWJseSBwcmV0dHkgc21hbGwuXG4gICAgICAgIGNvbnN0IHNvcnRlZElEcyA9IEFycmF5LmZyb20odW5zb3J0ZWRJRHMpLnNvcnQoXG4gICAgICAgICAgKGlkQSwgaWRCKSA9PlxuICAgICAgICAgICAgKHRoaXMuZ2V0SW5kZXhPZkVsZW1lbnRJRChpZEEpIHx8IDApIC1cbiAgICAgICAgICAgICh0aGlzLmdldEluZGV4T2ZFbGVtZW50SUQoaWRCKSB8fCAwKSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBOZXh0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBkZXB0aCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBsaXN0LlxuICAgICAgICAvLyBUaGUgZGVwdGggaW4gdGhlIGxpc3QgbWF5IG5vdCBjb3JyZXNwb25kIHRvIHRoZSBkZXB0aCBpbiB0aGUgdHJlZSxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgbGlzdCBoYXMgYmVlbiBmaWx0ZXJlZCB0byByZW1vdmUgaW50ZXJtZWRpYXRlIGNvbXBvbmVudHMuXG4gICAgICAgIC8vIFBlcmhhcHMgdGhlIGVhc2llc3Qgd2F5IHRvIGRvIHRoaXMgaXMgdG8gd2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSByZWFjaCBlaXRoZXI6XG4gICAgICAgIC8vICgxKSBhbm90aGVyIG5vZGUgdGhhdCdzIGFscmVhZHkgaW4gdGhlIHRyZWUsIG9yICgyKSB0aGUgcm9vdCAob3duZXIpXG4gICAgICAgIC8vIGF0IHdoaWNoIHBvaW50LCBvdXIgZGVwdGggaXMganVzdCB0aGUgZGVwdGggb2YgdGhhdCBub2RlIHBsdXMgb25lLlxuICAgICAgICBzb3J0ZWRJRHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgY29uc3QgaW5uZXJFbGVtZW50ID0gdGhpcy5faWRUb0VsZW1lbnQuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoaW5uZXJFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRJRCA9IGlubmVyRWxlbWVudC5wYXJlbnRJRDtcblxuICAgICAgICAgICAgbGV0IGRlcHRoID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRJRCA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudElEID09PSBvd25lcklEIHx8IHVuc29ydGVkSURzLmhhcyhwYXJlbnRJRCkpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gYWRkaXRpb24gd2l0aCBwb3NzaWJsZSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGRlcHRoID0gZGVwdGhNYXAuZ2V0KHBhcmVudElEKSArIDE7XG4gICAgICAgICAgICAgICAgZGVwdGhNYXAuc2V0KGlkLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5faWRUb0VsZW1lbnQuZ2V0KHBhcmVudElEKTtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyZW50SUQgPSBwYXJlbnQucGFyZW50SUQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLl90aHJvd0FuZEVtaXRFcnJvcihFcnJvcignSW52YWxpZCBvd25lcnMgbGlzdCcpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdC5wdXNoKHsuLi5pbm5lckVsZW1lbnQsIGRlcHRofSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIGdldFJlbmRlcmVySURGb3JFbGVtZW50KGlkOiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuX2lkVG9FbGVtZW50LmdldChpZCk7XG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGN1cnJlbnQucGFyZW50SUQgPT09IDApIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJJRCA9IHRoaXMuX3Jvb3RJRFRvUmVuZGVyZXJJRC5nZXQoY3VycmVudC5pZCk7XG4gICAgICAgIHJldHVybiByZW5kZXJlcklEID09IG51bGwgPyBudWxsIDogcmVuZGVyZXJJRDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQoY3VycmVudC5wYXJlbnRJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0Um9vdElERm9yRWxlbWVudChpZDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQoaWQpO1xuICAgIHdoaWxlIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjdXJyZW50LnBhcmVudElEID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LmlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudCA9IHRoaXMuX2lkVG9FbGVtZW50LmdldChjdXJyZW50LnBhcmVudElEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpc0luc2lkZUNvbGxhcHNlZFN1YlRyZWUoaWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5faWRUb0VsZW1lbnQuZ2V0KGlkKTtcbiAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudC5wYXJlbnRJRCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gdGhpcy5faWRUb0VsZW1lbnQuZ2V0KGN1cnJlbnQucGFyZW50SUQpO1xuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIGN1cnJlbnQuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUT0RPIE1heWJlIHNwbGl0IHRoaXMgaW50byB0d28gbWV0aG9kczogZXhwYW5kKCkgYW5kIGNvbGxhcHNlKClcbiAgdG9nZ2xlSXNDb2xsYXBzZWQoaWQ6IG51bWJlciwgaXNDb2xsYXBzZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQgZGlkTXV0YXRlID0gZmFsc2U7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50QnlJRChpZCk7XG4gICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBFbGVtZW50VHlwZVJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0FuZEVtaXRFcnJvcihFcnJvcignUm9vdCBub2RlcyBjYW5ub3QgYmUgY29sbGFwc2VkJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlbGVtZW50LmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgICAgICBlbGVtZW50LmlzQ29sbGFwc2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGNvbnN0IHdlaWdodERlbHRhID0gMSAtIGVsZW1lbnQud2VpZ2h0O1xuXG4gICAgICAgICAgbGV0IHBhcmVudEVsZW1lbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQoZWxlbWVudC5wYXJlbnRJRCk7XG4gICAgICAgICAgd2hpbGUgKHBhcmVudEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBicmVhayBvbiBhIGNvbGxhcHNlZCBwYXJlbnQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBleHBhbmQgY2FzZSBiZWxvdy5cbiAgICAgICAgICAgIC8vIFRoYXQncyBiZWNhdXNlIGNvbGxhcHNpbmcgYSBub2RlIGRvZXNuJ3QgXCJidWJibGVcIiBhbmQgYWZmZWN0IGl0cyBwYXJlbnRzLlxuICAgICAgICAgICAgcGFyZW50RWxlbWVudC53ZWlnaHQgKz0gd2VpZ2h0RGVsdGE7XG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gdGhpcy5faWRUb0VsZW1lbnQuZ2V0KHBhcmVudEVsZW1lbnQucGFyZW50SUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGN1cnJlbnRFbGVtZW50OiA/RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3Qgb2xkV2VpZ2h0ID0gY3VycmVudEVsZW1lbnQuaXNDb2xsYXBzZWRcbiAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgOiBjdXJyZW50RWxlbWVudC53ZWlnaHQ7XG5cbiAgICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIGRpZE11dGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudC5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdXZWlnaHQgPSBjdXJyZW50RWxlbWVudC5pc0NvbGxhcHNlZFxuICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgOiBjdXJyZW50RWxlbWVudC53ZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3ZWlnaHREZWx0YSA9IG5ld1dlaWdodCAtIG9sZFdlaWdodDtcblxuICAgICAgICAgICAgbGV0IHBhcmVudEVsZW1lbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQoY3VycmVudEVsZW1lbnQucGFyZW50SUQpO1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50LndlaWdodCArPSB3ZWlnaHREZWx0YTtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBicmVhayBvbiBhIGNvbGxhcHNlZCBwYXJlbnQgd2hlbiBleHBhbmRpbmcgbm9kZXMuXG4gICAgICAgICAgICAgICAgLy8gVGhhdCdzIGJlY2F1c2UgZXhwYW5kaW5nIGEgbm9kZSBcImJ1YmJsZXNcIiB1cCBhbmQgZXhwYW5kcyBhbGwgcGFyZW50cyBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIC8vIEJyZWFraW5nIGluIHRoaXMgY2FzZSBwcmV2ZW50cyB1cyBmcm9tIG92ZXItaW5jcmVtZW50aW5nIHRoZSBleHBhbmRlZCB3ZWlnaHRzLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQocGFyZW50RWxlbWVudC5wYXJlbnRJRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudEVsZW1lbnQgPVxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQucGFyZW50SUQgIT09IDBcbiAgICAgICAgICAgICAgPyB0aGlzLmdldEVsZW1lbnRCeUlEKGN1cnJlbnRFbGVtZW50LnBhcmVudElEKVxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT25seSByZS1jYWxjdWxhdGUgd2VpZ2h0cyBhbmQgZW1pdCBhbiBcInVwZGF0ZVwiIGV2ZW50IGlmIHRoZSBzdG9yZSB3YXMgbXV0YXRlZC5cbiAgICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgICAgbGV0IHdlaWdodEFjcm9zc1Jvb3RzID0gMDtcbiAgICAgICAgdGhpcy5fcm9vdHMuZm9yRWFjaChyb290SUQgPT4ge1xuICAgICAgICAgIGNvbnN0IHt3ZWlnaHR9ID0gKCh0aGlzLmdldEVsZW1lbnRCeUlEKHJvb3RJRCk6IGFueSk6IEVsZW1lbnQpO1xuICAgICAgICAgIHdlaWdodEFjcm9zc1Jvb3RzICs9IHdlaWdodDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3dlaWdodEFjcm9zc1Jvb3RzID0gd2VpZ2h0QWNyb3NzUm9vdHM7XG5cbiAgICAgICAgLy8gVGhlIFRyZWUgY29udGV4dCdzIHNlYXJjaCByZWR1Y2VyIGV4cGVjdHMgYW4gZXhwbGljaXQgbGlzdCBvZiBpZHMgZm9yIG5vZGVzIHRoYXQgd2VyZSBhZGRlZCBvciByZW1vdmVkLlxuICAgICAgICAvLyBJbiB0aGlzICBjYXNlLCB3ZSBjYW4gcGFzcyBpdCBlbXB0eSBhcnJheXMgc2luY2Ugbm9kZXMgaW4gYSBjb2xsYXBzZWQgdHJlZSBhcmUgc3RpbGwgdGhlcmUgKGp1c3QgaGlkZGVuKS5cbiAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHNlbGVjdGVkIHNlYXJjaCBpbmRleCBsYXRlciBtYXkgcmVxdWlyZSBhdXRvLWV4cGFuZGluZyBhIGNvbGxhcHNlZCBzdWJ0cmVlIHRob3VnaC5cbiAgICAgICAgdGhpcy5lbWl0KCdtdXRhdGVkJywgW1tdLCBuZXcgTWFwKCldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfYWRqdXN0UGFyZW50VHJlZVdlaWdodDogKFxuICAgIHBhcmVudEVsZW1lbnQ6ID9FbGVtZW50LFxuICAgIHdlaWdodERlbHRhOiBudW1iZXIsXG4gICkgPT4gdm9pZCA9IChwYXJlbnRFbGVtZW50LCB3ZWlnaHREZWx0YSkgPT4ge1xuICAgIGxldCBpc0luc2lkZUNvbGxhcHNlZFN1YlRyZWUgPSBmYWxzZTtcblxuICAgIHdoaWxlIChwYXJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIHBhcmVudEVsZW1lbnQud2VpZ2h0ICs9IHdlaWdodERlbHRhO1xuXG4gICAgICAvLyBBZGRpdGlvbnMgYW5kIGRlbGV0aW9ucyB3aXRoaW4gYSBjb2xsYXBzZWQgc3VidHJlZSBzaG91bGQgbm90IGJ1YmJsZSBiZXlvbmQgdGhlIGNvbGxhcHNlZCBwYXJlbnQuXG4gICAgICAvLyBUaGVpciB3ZWlnaHQgd2lsbCBidWJibGUgdXAgd2hlbiB0aGUgcGFyZW50IGlzIGV4cGFuZGVkLlxuICAgICAgaWYgKHBhcmVudEVsZW1lbnQuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgaXNJbnNpZGVDb2xsYXBzZWRTdWJUcmVlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudEVsZW1lbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQocGFyZW50RWxlbWVudC5wYXJlbnRJRCk7XG4gICAgfVxuXG4gICAgLy8gQWRkaXRpb25zIGFuZCBkZWxldGlvbnMgd2l0aGluIGEgY29sbGFwc2VkIHN1YnRyZWUgc2hvdWxkIG5vdCBhZmZlY3QgdGhlIG92ZXJhbGwgbnVtYmVyIG9mIGVsZW1lbnRzLlxuICAgIGlmICghaXNJbnNpZGVDb2xsYXBzZWRTdWJUcmVlKSB7XG4gICAgICB0aGlzLl93ZWlnaHRBY3Jvc3NSb290cyArPSB3ZWlnaHREZWx0YTtcbiAgICB9XG4gIH07XG5cbiAgX3JlY3Vyc2l2ZWx5VXBkYXRlU3VidHJlZShcbiAgICBpZDogbnVtYmVyLFxuICAgIGNhbGxiYWNrOiAoZWxlbWVudDogRWxlbWVudCkgPT4gdm9pZCxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2lkVG9FbGVtZW50LmdldChpZCk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuXG4gICAgICBlbGVtZW50LmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT5cbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlbHlVcGRhdGVTdWJ0cmVlKGNoaWxkLCBjYWxsYmFjayksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIG9uQnJpZGdlTmF0aXZlU3R5bGVFZGl0b3JTdXBwb3J0ZWQ6ICh7XG4gICAgaXNTdXBwb3J0ZWQ6IGJvb2xlYW4sXG4gICAgdmFsaWRBdHRyaWJ1dGVzOiA/JFJlYWRPbmx5QXJyYXk8c3RyaW5nPixcbiAgfSkgPT4gdm9pZCA9ICh7aXNTdXBwb3J0ZWQsIHZhbGlkQXR0cmlidXRlc30pID0+IHtcbiAgICB0aGlzLl9pc05hdGl2ZVN0eWxlRWRpdG9yU3VwcG9ydGVkID0gaXNTdXBwb3J0ZWQ7XG4gICAgdGhpcy5fbmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMgPSB2YWxpZEF0dHJpYnV0ZXMgfHwgbnVsbDtcblxuICAgIHRoaXMuZW1pdCgnc3VwcG9ydHNOYXRpdmVTdHlsZUVkaXRvcicpO1xuICB9O1xuXG4gIG9uQnJpZGdlT3BlcmF0aW9uczogKG9wZXJhdGlvbnM6IEFycmF5PG51bWJlcj4pID0+IHZvaWQgPSBvcGVyYXRpb25zID0+IHtcbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKCdvbkJyaWRnZU9wZXJhdGlvbnMnKTtcbiAgICAgIGRlYnVnKCdvbkJyaWRnZU9wZXJhdGlvbnMnLCBvcGVyYXRpb25zLmpvaW4oJywnKSk7XG4gICAgfVxuXG4gICAgbGV0IGhhdmVSb290c0NoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgaGF2ZUVycm9yc09yV2FybmluZ3NDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAvLyBUaGUgZmlyc3QgdHdvIHZhbHVlcyBhcmUgYWx3YXlzIHJlbmRlcmVySUQgYW5kIHJvb3RJRFxuICAgIGNvbnN0IHJlbmRlcmVySUQgPSBvcGVyYXRpb25zWzBdO1xuXG4gICAgY29uc3QgYWRkZWRFbGVtZW50SURzOiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgLy8gVGhpcyBpcyBhIG1hcHBpbmcgb2YgcmVtb3ZlZCBJRCAtPiBwYXJlbnQgSUQ6XG4gICAgY29uc3QgcmVtb3ZlZEVsZW1lbnRJRHM6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gICAgLy8gV2UnbGwgdXNlIHRoZSBwYXJlbnQgSUQgdG8gYWRqdXN0IHNlbGVjdGlvbiBpZiBpdCBnZXRzIGRlbGV0ZWQuXG5cbiAgICBsZXQgaSA9IDI7XG5cbiAgICAvLyBSZWFzc2VtYmxlIHRoZSBzdHJpbmcgdGFibGUuXG4gICAgY29uc3Qgc3RyaW5nVGFibGU6IEFycmF5PHN0cmluZyB8IG51bGw+ID0gW1xuICAgICAgbnVsbCwgLy8gSUQgPSAwIGNvcnJlc3BvbmRzIHRvIHRoZSBudWxsIHN0cmluZy5cbiAgICBdO1xuICAgIGNvbnN0IHN0cmluZ1RhYmxlU2l6ZSA9IG9wZXJhdGlvbnNbaV07XG4gICAgaSsrO1xuXG4gICAgY29uc3Qgc3RyaW5nVGFibGVFbmQgPSBpICsgc3RyaW5nVGFibGVTaXplO1xuXG4gICAgd2hpbGUgKGkgPCBzdHJpbmdUYWJsZUVuZCkge1xuICAgICAgY29uc3QgbmV4dExlbmd0aCA9IG9wZXJhdGlvbnNbaV07XG4gICAgICBpKys7XG5cbiAgICAgIGNvbnN0IG5leHRTdHJpbmcgPSB1dGZEZWNvZGVTdHJpbmdXaXRoUmFuZ2VzKFxuICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICBpLFxuICAgICAgICBpICsgbmV4dExlbmd0aCAtIDEsXG4gICAgICApO1xuICAgICAgc3RyaW5nVGFibGUucHVzaChuZXh0U3RyaW5nKTtcbiAgICAgIGkgKz0gbmV4dExlbmd0aDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IG9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvcGVyYXRpb24gPSBvcGVyYXRpb25zW2ldO1xuICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9BREQ6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSAoKG9wZXJhdGlvbnNbaSArIDJdOiBhbnkpOiBFbGVtZW50VHlwZSk7XG5cbiAgICAgICAgICBpICs9IDM7XG5cbiAgICAgICAgICBpZiAodGhpcy5faWRUb0VsZW1lbnQuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dBbmRFbWl0RXJyb3IoXG4gICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgIGBDYW5ub3QgYWRkIG5vZGUgXCIke2lkfVwiIGJlY2F1c2UgYSBub2RlIHdpdGggdGhhdCBpZCBpcyBhbHJlYWR5IGluIHRoZSBTdG9yZS5gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gRWxlbWVudFR5cGVSb290KSB7XG4gICAgICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdBZGQnLCBgbmV3IHJvb3Qgbm9kZSAke2lkfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc1N0cmljdE1vZGVDb21wbGlhbnQgPSBvcGVyYXRpb25zW2ldID4gMDtcbiAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydHNCYXNpY1Byb2ZpbGluZyA9XG4gICAgICAgICAgICAgIChvcGVyYXRpb25zW2ldICYgUFJPRklMSU5HX0ZMQUdfQkFTSUNfU1VQUE9SVCkgIT09IDA7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0c1RpbWVsaW5lID1cbiAgICAgICAgICAgICAgKG9wZXJhdGlvbnNbaV0gJiBQUk9GSUxJTkdfRkxBR19USU1FTElORV9TVVBQT1JUKSAhPT0gMDtcbiAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgbGV0IHN1cHBvcnRzU3RyaWN0TW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGhhc093bmVyTWV0YWRhdGEgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3Qga25vdyB0aGUgYnJpZGdlIHByb3RvY29sLCBndWVzcyB0aGF0IHdlJ3JlIGRlYWxpbmcgd2l0aCB0aGUgbGF0ZXN0LlxuICAgICAgICAgICAgLy8gSWYgd2UgZG8ga25vdyBpdCwgd2UgY2FuIHRha2UgaXQgaW50byBjb25zaWRlcmF0aW9uIHdoZW4gcGFyc2luZyBvcGVyYXRpb25zLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0aGlzLl9icmlkZ2VQcm90b2NvbCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICB0aGlzLl9icmlkZ2VQcm90b2NvbC52ZXJzaW9uID49IDJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBzdXBwb3J0c1N0cmljdE1vZGUgPSBvcGVyYXRpb25zW2ldID4gMDtcbiAgICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICAgIGhhc093bmVyTWV0YWRhdGEgPSBvcGVyYXRpb25zW2ldID4gMDtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9yb290cyA9IHRoaXMuX3Jvb3RzLmNvbmNhdChpZCk7XG4gICAgICAgICAgICB0aGlzLl9yb290SURUb1JlbmRlcmVySUQuc2V0KGlkLCByZW5kZXJlcklEKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RJRFRvQ2FwYWJpbGl0aWVzLnNldChpZCwge1xuICAgICAgICAgICAgICBzdXBwb3J0c0Jhc2ljUHJvZmlsaW5nLFxuICAgICAgICAgICAgICBoYXNPd25lck1ldGFkYXRhLFxuICAgICAgICAgICAgICBzdXBwb3J0c1N0cmljdE1vZGUsXG4gICAgICAgICAgICAgIHN1cHBvcnRzVGltZWxpbmUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTm90IGFsbCByb290cyBzdXBwb3J0IFN0cmljdE1vZGU7XG4gICAgICAgICAgICAvLyBkb24ndCBmbGFnIGEgcm9vdCBhcyBub24tY29tcGxpYW50IHVubGVzcyBpdCBhbHNvIHN1cHBvcnRzIFN0cmljdE1vZGUuXG4gICAgICAgICAgICBjb25zdCBpc1N0cmljdE1vZGVOb25Db21wbGlhbnQgPVxuICAgICAgICAgICAgICAhaXNTdHJpY3RNb2RlQ29tcGxpYW50ICYmIHN1cHBvcnRzU3RyaWN0TW9kZTtcblxuICAgICAgICAgICAgdGhpcy5faWRUb0VsZW1lbnQuc2V0KGlkLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgICAgZGVwdGg6IC0xLFxuICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgaG9jRGlzcGxheU5hbWVzOiBudWxsLFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgaXNDb2xsYXBzZWQ6IGZhbHNlLCAvLyBOZXZlciBjb2xsYXBzZSByb290czsgaXQgd291bGQgaGlkZSB0aGUgZW50aXJlIHRyZWUuXG4gICAgICAgICAgICAgIGlzU3RyaWN0TW9kZU5vbkNvbXBsaWFudCxcbiAgICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgICBvd25lcklEOiAwLFxuICAgICAgICAgICAgICBwYXJlbnRJRDogMCxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgd2VpZ2h0OiAwLFxuICAgICAgICAgICAgICBjb21waWxlZFdpdGhGb3JnZXQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGhhdmVSb290c0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJRCA9IG9wZXJhdGlvbnNbaV07XG4gICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgIGNvbnN0IG93bmVySUQgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5TmFtZVN0cmluZ0lEID0gb3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gc3RyaW5nVGFibGVbZGlzcGxheU5hbWVTdHJpbmdJRF07XG4gICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleVN0cmluZ0lEID0gb3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHN0cmluZ1RhYmxlW2tleVN0cmluZ0lEXTtcbiAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAgICAgICAnQWRkJyxcbiAgICAgICAgICAgICAgICBgbm9kZSAke2lkfSAoJHtkaXNwbGF5TmFtZSB8fCAnbnVsbCd9KSBhcyBjaGlsZCBvZiAke3BhcmVudElEfWAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQocGFyZW50SUQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLl90aHJvd0FuZEVtaXRFcnJvcihcbiAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBDYW5ub3QgYWRkIGNoaWxkIFwiJHtpZH1cIiB0byBwYXJlbnQgXCIke3BhcmVudElEfVwiIGJlY2F1c2UgcGFyZW50IG5vZGUgd2FzIG5vdCBmb3VuZCBpbiB0aGUgU3RvcmUuYCxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50LmNoaWxkcmVuLnB1c2goaWQpO1xuXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGZvcm1hdHRlZERpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZVdpdGhvdXRIT0NzLFxuICAgICAgICAgICAgICBob2NEaXNwbGF5TmFtZXMsXG4gICAgICAgICAgICAgIGNvbXBpbGVkV2l0aEZvcmdldCxcbiAgICAgICAgICAgIH0gPSBwYXJzZUVsZW1lbnREaXNwbGF5TmFtZUZyb21CYWNrZW5kKGRpc3BsYXlOYW1lLCB0eXBlKTtcblxuICAgICAgICAgICAgY29uc3QgZWxlbWVudDogRWxlbWVudCA9IHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICBkZXB0aDogcGFyZW50RWxlbWVudC5kZXB0aCArIDEsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZVdpdGhvdXRIT0NzLFxuICAgICAgICAgICAgICBob2NEaXNwbGF5TmFtZXMsXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBpc0NvbGxhcHNlZDogdGhpcy5fY29sbGFwc2VOb2Rlc0J5RGVmYXVsdCxcbiAgICAgICAgICAgICAgaXNTdHJpY3RNb2RlTm9uQ29tcGxpYW50OiBwYXJlbnRFbGVtZW50LmlzU3RyaWN0TW9kZU5vbkNvbXBsaWFudCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBvd25lcklELFxuICAgICAgICAgICAgICBwYXJlbnRJRCxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgd2VpZ2h0OiAxLFxuICAgICAgICAgICAgICBjb21waWxlZFdpdGhGb3JnZXQsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9pZFRvRWxlbWVudC5zZXQoaWQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgYWRkZWRFbGVtZW50SURzLnB1c2goaWQpO1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50VHJlZVdlaWdodChwYXJlbnRFbGVtZW50LCAxKTtcblxuICAgICAgICAgICAgaWYgKG93bmVySUQgPiAwKSB7XG4gICAgICAgICAgICAgIGxldCBzZXQgPSB0aGlzLl9vd25lcnNNYXAuZ2V0KG93bmVySUQpO1xuICAgICAgICAgICAgICBpZiAoc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3duZXJzTWFwLnNldChvd25lcklELCBzZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldC5hZGQoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1JFTU9WRToge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZUxlbmd0aCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICAgIGkgKz0gMjtcblxuICAgICAgICAgIGZvciAobGV0IHJlbW92ZUluZGV4ID0gMDsgcmVtb3ZlSW5kZXggPCByZW1vdmVMZW5ndGg7IHJlbW92ZUluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gb3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQoaWQpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Rocm93QW5kRW1pdEVycm9yKFxuICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgYENhbm5vdCByZW1vdmUgbm9kZSBcIiR7aWR9XCIgYmVjYXVzZSBubyBtYXRjaGluZyBub2RlIHdhcyBmb3VuZCBpbiB0aGUgU3RvcmUuYCxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpICs9IDE7XG5cbiAgICAgICAgICAgIGNvbnN0IHtjaGlsZHJlbiwgb3duZXJJRCwgcGFyZW50SUQsIHdlaWdodH0gPSBlbGVtZW50O1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fdGhyb3dBbmRFbWl0RXJyb3IoXG4gICAgICAgICAgICAgICAgRXJyb3IoYE5vZGUgXCIke2lkfVwiIHdhcyByZW1vdmVkIGJlZm9yZSBpdHMgY2hpbGRyZW4uYCksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lkVG9FbGVtZW50LmRlbGV0ZShpZCk7XG5cbiAgICAgICAgICAgIGxldCBwYXJlbnRFbGVtZW50OiA/RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50SUQgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdSZW1vdmUnLCBgbm9kZSAke2lkfSByb290YCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLl9yb290cyA9IHRoaXMuX3Jvb3RzLmZpbHRlcihyb290SUQgPT4gcm9vdElEICE9PSBpZCk7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RJRFRvUmVuZGVyZXJJRC5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICB0aGlzLl9yb290SURUb0NhcGFiaWxpdGllcy5kZWxldGUoaWQpO1xuXG4gICAgICAgICAgICAgIGhhdmVSb290c0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdSZW1vdmUnLCBgbm9kZSAke2lkfSBmcm9tIHBhcmVudCAke3BhcmVudElEfWApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGFyZW50RWxlbWVudCA9IHRoaXMuX2lkVG9FbGVtZW50LmdldChwYXJlbnRJRCk7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0FuZEVtaXRFcnJvcihcbiAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgQ2Fubm90IHJlbW92ZSBub2RlIFwiJHtpZH1cIiBmcm9tIHBhcmVudCBcIiR7cGFyZW50SUR9XCIgYmVjYXVzZSBubyBtYXRjaGluZyBub2RlIHdhcyBmb3VuZCBpbiB0aGUgU3RvcmUuYCxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRFbGVtZW50LmNoaWxkcmVuLmluZGV4T2YoaWQpO1xuICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2FkanVzdFBhcmVudFRyZWVXZWlnaHQocGFyZW50RWxlbWVudCwgLXdlaWdodCk7XG4gICAgICAgICAgICByZW1vdmVkRWxlbWVudElEcy5zZXQoaWQsIHBhcmVudElEKTtcblxuICAgICAgICAgICAgdGhpcy5fb3duZXJzTWFwLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBpZiAob3duZXJJRCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5fb3duZXJzTWFwLmdldChvd25lcklEKTtcbiAgICAgICAgICAgICAgaWYgKHNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yc0FuZFdhcm5pbmdzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzQW5kV2FybmluZ3MuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgaGF2ZUVycm9yc09yV2FybmluZ3NDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UOiB7XG4gICAgICAgICAgaSArPSAxO1xuXG4gICAgICAgICAgY29uc3QgaWQgPSBvcGVyYXRpb25zWzFdO1xuXG4gICAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgICAgZGVidWcoYFJlbW92ZSByb290ICR7aWR9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVjdXJzaXZlbHlEZWxldGVFbGVtZW50cyA9IChlbGVtZW50SUQ6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2lkVG9FbGVtZW50LmdldChlbGVtZW50SUQpO1xuICAgICAgICAgICAgdGhpcy5faWRUb0VsZW1lbnQuZGVsZXRlKGVsZW1lbnRJRCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAvLyBNb3N0bHkgZm9yIEZsb3cncyBzYWtlXG4gICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5RGVsZXRlRWxlbWVudHMoZWxlbWVudC5jaGlsZHJlbltpbmRleF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9pZFRvRWxlbWVudC5nZXQoaWQpO1xuICAgICAgICAgIGlmIChyb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93QW5kRW1pdEVycm9yKFxuICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICBgQ2Fubm90IHJlbW92ZSByb290IFwiJHtpZH1cIjogbm8gbWF0Y2hpbmcgbm9kZSB3YXMgZm91bmQgaW4gdGhlIFN0b3JlLmAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWN1cnNpdmVseURlbGV0ZUVsZW1lbnRzKGlkKTtcblxuICAgICAgICAgIHRoaXMuX3Jvb3RJRFRvQ2FwYWJpbGl0aWVzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgdGhpcy5fcm9vdElEVG9SZW5kZXJlcklELmRlbGV0ZShpZCk7XG4gICAgICAgICAgdGhpcy5fcm9vdHMgPSB0aGlzLl9yb290cy5maWx0ZXIocm9vdElEID0+IHJvb3RJRCAhPT0gaWQpO1xuICAgICAgICAgIHRoaXMuX3dlaWdodEFjcm9zc1Jvb3RzIC09IHJvb3Qud2VpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gb3BlcmF0aW9uc1tpICsgMV07XG4gICAgICAgICAgY29uc3QgbnVtQ2hpbGRyZW4gPSBvcGVyYXRpb25zW2kgKyAyXTtcbiAgICAgICAgICBpICs9IDM7XG5cbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5faWRUb0VsZW1lbnQuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0FuZEVtaXRFcnJvcihcbiAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgYENhbm5vdCByZW9yZGVyIGNoaWxkcmVuIGZvciBub2RlIFwiJHtpZH1cIiBiZWNhdXNlIG5vIG1hdGNoaW5nIG5vZGUgd2FzIGZvdW5kIGluIHRoZSBTdG9yZS5gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IG51bUNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0FuZEVtaXRFcnJvcihcbiAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgYENoaWxkcmVuIGNhbm5vdCBiZSBhZGRlZCBvciByZW1vdmVkIGR1cmluZyBhIHJlb3JkZXIgb3BlcmF0aW9uLmAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQ2hpbGRyZW47IGorKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRJRCA9IG9wZXJhdGlvbnNbaSArIGpdO1xuICAgICAgICAgICAgY2hpbGRyZW5bal0gPSBjaGlsZElEO1xuICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBtb3JlIGV4cGVuc2l2ZSBzbyBpdCdzIGdhdGVkIGJ5IF9fREVWX18uXG4gICAgICAgICAgICAgIGNvbnN0IGNoaWxkRWxlbWVudCA9IHRoaXMuX2lkVG9FbGVtZW50LmdldChjaGlsZElEKTtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkRWxlbWVudCA9PSBudWxsIHx8IGNoaWxkRWxlbWVudC5wYXJlbnRJRCAhPT0gaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgYENoaWxkcmVuIGNhbm5vdCBiZSBhZGRlZCBvciByZW1vdmVkIGR1cmluZyBhIHJlb3JkZXIgb3BlcmF0aW9uLmAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IG51bUNoaWxkcmVuO1xuXG4gICAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgICAgZGVidWcoJ1JlLW9yZGVyJywgYE5vZGUgJHtpZH0gY2hpbGRyZW4gJHtjaGlsZHJlbi5qb2luKCcsJyl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERToge1xuICAgICAgICAgIGNvbnN0IGlkID0gb3BlcmF0aW9uc1tpICsgMV07XG4gICAgICAgICAgY29uc3QgbW9kZSA9IG9wZXJhdGlvbnNbaSArIDJdO1xuXG4gICAgICAgICAgaSArPSAzO1xuXG4gICAgICAgICAgLy8gSWYgZWxlbWVudHMgaGF2ZSBhbHJlYWR5IGJlZW4gbW91bnRlZCBpbiB0aGlzIHN1YnRyZWUsIHVwZGF0ZSB0aGVtLlxuICAgICAgICAgIC8vIChJbiBwcmFjdGljZSwgdGhpcyBsaWtlbHkgb25seSBhcHBsaWVzIHRvIHRoZSByb290IGVsZW1lbnQuKVxuICAgICAgICAgIGlmIChtb2RlID09PSBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWN1cnNpdmVseVVwZGF0ZVN1YnRyZWUoaWQsIGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICBlbGVtZW50LmlzU3RyaWN0TW9kZU5vbkNvbXBsaWFudCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAgICdTdWJ0cmVlIG1vZGUnLFxuICAgICAgICAgICAgICBgU3VidHJlZSB3aXRoIHJvb3QgJHtpZH0gc2V0IHRvIG1vZGUgJHttb2RlfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT046XG4gICAgICAgICAgLy8gQmFzZSBkdXJhdGlvbiB1cGRhdGVzIGFyZSBvbmx5IHNlbnQgd2hpbGUgcHJvZmlsaW5nIGlzIGluIHByb2dyZXNzLlxuICAgICAgICAgIC8vIFdlIGNhbiBpZ25vcmUgdGhlbSBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgIC8vIFRoZSBwcm9maWxlciBVSSB1c2VzIHRoZW0gbGF6aWx5IGluIG9yZGVyIHRvIGdlbmVyYXRlIHRoZSB0cmVlLlxuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTOlxuICAgICAgICAgIGNvbnN0IGlkID0gb3BlcmF0aW9uc1tpICsgMV07XG4gICAgICAgICAgY29uc3QgZXJyb3JDb3VudCA9IG9wZXJhdGlvbnNbaSArIDJdO1xuICAgICAgICAgIGNvbnN0IHdhcm5pbmdDb3VudCA9IG9wZXJhdGlvbnNbaSArIDNdO1xuXG4gICAgICAgICAgaSArPSA0O1xuXG4gICAgICAgICAgaWYgKGVycm9yQ291bnQgPiAwIHx8IHdhcm5pbmdDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yc0FuZFdhcm5pbmdzLnNldChpZCwge2Vycm9yQ291bnQsIHdhcm5pbmdDb3VudH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZXJyb3JzQW5kV2FybmluZ3MuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzQW5kV2FybmluZ3MuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZUVycm9yc09yV2FybmluZ3NDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLl90aHJvd0FuZEVtaXRFcnJvcihcbiAgICAgICAgICAgIG5ldyBVbnN1cHBvcnRlZEJyaWRnZU9wZXJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgQnJpZGdlIG9wZXJhdGlvbiBcIiR7b3BlcmF0aW9ufVwiYCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yZXZpc2lvbisrO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIHRyZWUgY2hhbmdlcyAoZS5nLiBlbGVtZW50cyBhZGRlZCwgcmVtb3ZlZCwgb3IgcmVvcmRlcmVkKSBjYWNoZWQgaW5kaWNlcyBtYXkgYmUgaW52YWxpZC5cbiAgICB0aGlzLl9jYWNoZWRFcnJvckFuZFdhcm5pbmdUdXBsZXMgPSBudWxsO1xuXG4gICAgaWYgKGhhdmVFcnJvcnNPcldhcm5pbmdzQ2hhbmdlZCkge1xuICAgICAgbGV0IGNvbXBvbmVudFdpdGhFcnJvckNvdW50ID0gMDtcbiAgICAgIGxldCBjb21wb25lbnRXaXRoV2FybmluZ0NvdW50ID0gMDtcblxuICAgICAgdGhpcy5fZXJyb3JzQW5kV2FybmluZ3MuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGlmIChlbnRyeS5lcnJvckNvdW50ID4gMCkge1xuICAgICAgICAgIGNvbXBvbmVudFdpdGhFcnJvckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkud2FybmluZ0NvdW50ID4gMCkge1xuICAgICAgICAgIGNvbXBvbmVudFdpdGhXYXJuaW5nQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZENvbXBvbmVudFdpdGhFcnJvckNvdW50ID0gY29tcG9uZW50V2l0aEVycm9yQ291bnQ7XG4gICAgICB0aGlzLl9jYWNoZWRDb21wb25lbnRXaXRoV2FybmluZ0NvdW50ID0gY29tcG9uZW50V2l0aFdhcm5pbmdDb3VudDtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZVJvb3RzQ2hhbmdlZCkge1xuICAgICAgY29uc3QgcHJldlJvb3RTdXBwb3J0c1Byb2ZpbGluZyA9IHRoaXMuX3Jvb3RTdXBwb3J0c0Jhc2ljUHJvZmlsaW5nO1xuICAgICAgY29uc3QgcHJldlJvb3RTdXBwb3J0c1RpbWVsaW5lUHJvZmlsaW5nID1cbiAgICAgICAgdGhpcy5fcm9vdFN1cHBvcnRzVGltZWxpbmVQcm9maWxpbmc7XG5cbiAgICAgIHRoaXMuX2hhc093bmVyTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Jvb3RTdXBwb3J0c0Jhc2ljUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9yb290U3VwcG9ydHNUaW1lbGluZVByb2ZpbGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fcm9vdElEVG9DYXBhYmlsaXRpZXMuZm9yRWFjaChcbiAgICAgICAgKHtzdXBwb3J0c0Jhc2ljUHJvZmlsaW5nLCBoYXNPd25lck1ldGFkYXRhLCBzdXBwb3J0c1RpbWVsaW5lfSkgPT4ge1xuICAgICAgICAgIGlmIChzdXBwb3J0c0Jhc2ljUHJvZmlsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290U3VwcG9ydHNCYXNpY1Byb2ZpbGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNPd25lck1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNPd25lck1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN1cHBvcnRzVGltZWxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RTdXBwb3J0c1RpbWVsaW5lUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICB0aGlzLmVtaXQoJ3Jvb3RzJyk7XG5cbiAgICAgIGlmICh0aGlzLl9yb290U3VwcG9ydHNCYXNpY1Byb2ZpbGluZyAhPT0gcHJldlJvb3RTdXBwb3J0c1Byb2ZpbGluZykge1xuICAgICAgICB0aGlzLmVtaXQoJ3Jvb3RTdXBwb3J0c0Jhc2ljUHJvZmlsaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fcm9vdFN1cHBvcnRzVGltZWxpbmVQcm9maWxpbmcgIT09XG4gICAgICAgIHByZXZSb290U3VwcG9ydHNUaW1lbGluZVByb2ZpbGluZ1xuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncm9vdFN1cHBvcnRzVGltZWxpbmVQcm9maWxpbmcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBjb25zb2xlLmxvZyhwcmludFN0b3JlKHRoaXMsIHRydWUpKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ211dGF0ZWQnLCBbYWRkZWRFbGVtZW50SURzLCByZW1vdmVkRWxlbWVudElEc10pO1xuICB9O1xuXG4gIC8vIENlcnRhaW4gYmFja2VuZHMgc2F2ZSBmaWx0ZXJzIG9uIGEgcGVyLWRvbWFpbiBiYXNpcy5cbiAgLy8gSW4gb3JkZXIgdG8gcHJldmVudCBmaWx0ZXIgcHJlZmVyZW5jZXMgYW5kIGFwcGxpZWQgZmlsdGVycyBmcm9tIGJlaW5nIG91dCBvZiBzeW5jLFxuICAvLyB0aGlzIG1lc3NhZ2UgZW5hYmxlcyB0aGUgYmFja2VuZCB0byBvdmVycmlkZSB0aGUgZnJvbnRlbmQncyBjdXJyZW50IChcInNhdmVkXCIpIGZpbHRlcnMuXG4gIC8vIFRoaXMgYWN0aW9uIHNob3VsZCBhbHNvIG92ZXJyaWRlIHRoZSBzYXZlZCBmaWx0ZXJzIHRvbyxcbiAgLy8gZWxzZSByZWxvYWRpbmcgdGhlIGZyb250ZW5kIHdpdGhvdXQgcmVsb2FkaW5nIHRoZSBiYWNrZW5kIHdvdWxkIGxlYXZlIHRoaW5ncyBvdXQgb2Ygc3luYy5cbiAgb25CcmlkZ2VPdmVycmlkZUNvbXBvbmVudEZpbHRlcnM6IChcbiAgICBjb21wb25lbnRGaWx0ZXJzOiBBcnJheTxDb21wb25lbnRGaWx0ZXI+LFxuICApID0+IHZvaWQgPSBjb21wb25lbnRGaWx0ZXJzID0+IHtcbiAgICB0aGlzLl9jb21wb25lbnRGaWx0ZXJzID0gY29tcG9uZW50RmlsdGVycztcblxuICAgIHNldFNhdmVkQ29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKTtcbiAgfTtcblxuICBvbkJyaWRnZVNodXRkb3duOiAoKSA9PiB2b2lkID0gKCkgPT4ge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCdvbkJyaWRnZVNodXRkb3duJywgJ3Vuc3Vic2NyaWJpbmcgZnJvbSBCcmlkZ2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBicmlkZ2UgPSB0aGlzLl9icmlkZ2U7XG4gICAgYnJpZGdlLnJlbW92ZUxpc3RlbmVyKCdvcGVyYXRpb25zJywgdGhpcy5vbkJyaWRnZU9wZXJhdGlvbnMpO1xuICAgIGJyaWRnZS5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICdvdmVycmlkZUNvbXBvbmVudEZpbHRlcnMnLFxuICAgICAgdGhpcy5vbkJyaWRnZU92ZXJyaWRlQ29tcG9uZW50RmlsdGVycyxcbiAgICApO1xuICAgIGJyaWRnZS5yZW1vdmVMaXN0ZW5lcignc2h1dGRvd24nLCB0aGlzLm9uQnJpZGdlU2h1dGRvd24pO1xuICAgIGJyaWRnZS5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICdpc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWRCeUJhY2tlbmQnLFxuICAgICAgdGhpcy5vbkJhY2tlbmRSZWxvYWRBbmRQcm9maWxlU3VwcG9ydGVkLFxuICAgICk7XG4gICAgYnJpZGdlLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgJ2lzTmF0aXZlU3R5bGVFZGl0b3JTdXBwb3J0ZWQnLFxuICAgICAgdGhpcy5vbkJyaWRnZU5hdGl2ZVN0eWxlRWRpdG9yU3VwcG9ydGVkLFxuICAgICk7XG4gICAgYnJpZGdlLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgJ3Vuc3VwcG9ydGVkUmVuZGVyZXJWZXJzaW9uJyxcbiAgICAgIHRoaXMub25CcmlkZ2VVbnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbixcbiAgICApO1xuICAgIGJyaWRnZS5yZW1vdmVMaXN0ZW5lcignYmFja2VuZFZlcnNpb24nLCB0aGlzLm9uQnJpZGdlQmFja2VuZFZlcnNpb24pO1xuICAgIGJyaWRnZS5yZW1vdmVMaXN0ZW5lcignYnJpZGdlUHJvdG9jb2wnLCB0aGlzLm9uQnJpZGdlUHJvdG9jb2wpO1xuICAgIGJyaWRnZS5yZW1vdmVMaXN0ZW5lcignc2F2ZVRvQ2xpcGJvYXJkJywgdGhpcy5vblNhdmVUb0NsaXBib2FyZCk7XG5cbiAgICBpZiAodGhpcy5fb25CcmlkZ2VQcm90b2NvbFRpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX29uQnJpZGdlUHJvdG9jb2xUaW1lb3V0SUQpO1xuICAgICAgdGhpcy5fb25CcmlkZ2VQcm90b2NvbFRpbWVvdXRJRCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIG9uQmFja2VuZFJlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQ6IChcbiAgICBpc1JlbG9hZEFuZFByb2ZpbGVTdXBwb3J0ZWQ6IGJvb2xlYW4sXG4gICkgPT4gdm9pZCA9IGlzUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZCA9PiB7XG4gICAgdGhpcy5faXNSZWxvYWRBbmRQcm9maWxlQmFja2VuZFN1cHBvcnRlZCA9IGlzUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZDtcblxuICAgIHRoaXMuZW1pdCgnc3VwcG9ydHNSZWxvYWRBbmRQcm9maWxlJyk7XG4gIH07XG5cbiAgb25CcmlkZ2VVbnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbjogKCkgPT4gdm9pZCA9ICgpID0+IHtcbiAgICB0aGlzLl91bnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbkRldGVjdGVkID0gdHJ1ZTtcblxuICAgIHRoaXMuZW1pdCgndW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb25EZXRlY3RlZCcpO1xuICB9O1xuXG4gIG9uQnJpZGdlQmFja2VuZFZlcnNpb246IChiYWNrZW5kVmVyc2lvbjogc3RyaW5nKSA9PiB2b2lkID0gYmFja2VuZFZlcnNpb24gPT4ge1xuICAgIHRoaXMuX2JhY2tlbmRWZXJzaW9uID0gYmFja2VuZFZlcnNpb247XG4gICAgdGhpcy5lbWl0KCdiYWNrZW5kVmVyc2lvbicpO1xuICB9O1xuXG4gIG9uQnJpZGdlUHJvdG9jb2w6IChicmlkZ2VQcm90b2NvbDogQnJpZGdlUHJvdG9jb2wpID0+IHZvaWQgPVxuICAgIGJyaWRnZVByb3RvY29sID0+IHtcbiAgICAgIGlmICh0aGlzLl9vbkJyaWRnZVByb3RvY29sVGltZW91dElEICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vbkJyaWRnZVByb3RvY29sVGltZW91dElEKTtcbiAgICAgICAgdGhpcy5fb25CcmlkZ2VQcm90b2NvbFRpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2JyaWRnZVByb3RvY29sID0gYnJpZGdlUHJvdG9jb2w7XG5cbiAgICAgIGlmIChicmlkZ2VQcm90b2NvbC52ZXJzaW9uICE9PSBjdXJyZW50QnJpZGdlUHJvdG9jb2wudmVyc2lvbikge1xuICAgICAgICAvLyBUZWNobmljYWxseSBuZXdlciB2ZXJzaW9ucyBvZiB0aGUgZnJvbnRlbmQgY2FuLCBhdCBsZWFzdCBmb3Igbm93LFxuICAgICAgICAvLyBncmFjZWZ1bGx5IGhhbmRsZSBvbGRlciB2ZXJzaW9ucyBvZiB0aGUgYmFja2VuZCBwcm90b2NvbC5cbiAgICAgICAgLy8gU28gZm9yIG5vdyB3ZSBkb24ndCBuZWVkIHRvIGRpc3BsYXkgdGhlIHVuc3VwcG9ydGVkIGRpYWxvZy5cbiAgICAgIH1cbiAgICB9O1xuXG4gIG9uQnJpZGdlUHJvdG9jb2xUaW1lb3V0OiAoKSA9PiB2b2lkID0gKCkgPT4ge1xuICAgIHRoaXMuX29uQnJpZGdlUHJvdG9jb2xUaW1lb3V0SUQgPSBudWxsO1xuXG4gICAgLy8gSWYgd2UgdGltZWQgb3V0LCB0aGF0IGluZGljYXRlcyB0aGUgYmFja2VuZCBwcmVkYXRlcyB0aGUgYnJpZGdlIHByb3RvY29sLFxuICAgIC8vIHNvIHdlIGNhbiBzZXQgYSBmYWtlIHZlcnNpb24gKDApIHRvIHRyaWdnZXIgdGhlIGRvd25ncmFkZSBtZXNzYWdlLlxuICAgIHRoaXMuX2JyaWRnZVByb3RvY29sID0gQlJJREdFX1BST1RPQ09MWzBdO1xuXG4gICAgdGhpcy5lbWl0KCd1bnN1cHBvcnRlZEJyaWRnZVByb3RvY29sRGV0ZWN0ZWQnKTtcbiAgfTtcblxuICBvblNhdmVUb0NsaXBib2FyZDogKHRleHQ6IHN0cmluZykgPT4gdm9pZCA9IHRleHQgPT4ge1xuICAgIGNvcHkodGV4dCk7XG4gIH07XG5cbiAgb25CYWNrZW5kSW5pdGlhbGl6ZWQ6ICgpID0+IHZvaWQgPSAoKSA9PiB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGZyb250ZW5kIHZlcnNpb24gaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjb25uZWN0ZWQgYmFja2VuZC5cbiAgICAvLyBTZWUgZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjEzMjZcbiAgICBpZiAodGhpcy5fc2hvdWxkQ2hlY2tCcmlkZ2VQcm90b2NvbENvbXBhdGliaWxpdHkpIHtcbiAgICAgIC8vIE9sZGVyIGJhY2tlbmRzIGRvbid0IHN1cHBvcnQgYW4gZXhwbGljaXQgYnJpZGdlIHByb3RvY29sLFxuICAgICAgLy8gc28gd2Ugc2hvdWxkIHRpbWVvdXQgZXZlbnR1YWxseSBhbmQgc2hvdyBhIGRvd25ncmFkZSBtZXNzYWdlLlxuICAgICAgdGhpcy5fb25CcmlkZ2VQcm90b2NvbFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoXG4gICAgICAgIHRoaXMub25CcmlkZ2VQcm90b2NvbFRpbWVvdXQsXG4gICAgICAgIDEwMDAwLFxuICAgICAgKTtcblxuICAgICAgdGhpcy5fYnJpZGdlLmFkZExpc3RlbmVyKCdicmlkZ2VQcm90b2NvbCcsIHRoaXMub25CcmlkZ2VQcm90b2NvbCk7XG4gICAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnZ2V0QnJpZGdlUHJvdG9jb2wnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnZ2V0QmFja2VuZFZlcnNpb24nKTtcbiAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnZ2V0SWZIYXNVbnN1cHBvcnRlZFJlbmRlcmVyVmVyc2lvbicpO1xuICAgIHRoaXMuX2JyaWRnZS5zZW5kKCdnZXRIb29rU2V0dGluZ3MnKTsgLy8gV2FybSB1cCBjYWNoZWQgaG9vayBzZXR0aW5nc1xuICB9O1xuXG4gIGdldEhvb2tTZXR0aW5nczogKCkgPT4gdm9pZCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5faG9va1NldHRpbmdzICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZW1pdCgnaG9va1NldHRpbmdzJywgdGhpcy5faG9va1NldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnJpZGdlLnNlbmQoJ2dldEhvb2tTZXR0aW5ncycpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb29rU2V0dGluZ3M6IChzZXR0aW5nczogJFJlYWRPbmx5PERldlRvb2xzSG9va1NldHRpbmdzPikgPT4gdm9pZCA9XG4gICAgc2V0dGluZ3MgPT4ge1xuICAgICAgdGhpcy5faG9va1NldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgICAgIHRoaXMuX2JyaWRnZS5zZW5kKCd1cGRhdGVIb29rU2V0dGluZ3MnLCBzZXR0aW5ncyk7XG4gICAgICB0aGlzLmVtaXQoJ3NldHRpbmdzVXBkYXRlZCcsIHNldHRpbmdzKTtcbiAgICB9O1xuXG4gIG9uSG9va1NldHRpbmdzOiAoc2V0dGluZ3M6ICRSZWFkT25seTxEZXZUb29sc0hvb2tTZXR0aW5ncz4pID0+IHZvaWQgPVxuICAgIHNldHRpbmdzID0+IHtcbiAgICAgIHRoaXMuX2hvb2tTZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgICB0aGlzLnNldFNob3VsZFNob3dXYXJuaW5nc0FuZEVycm9ycyhzZXR0aW5ncy5zaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMpO1xuICAgICAgdGhpcy5lbWl0KCdob29rU2V0dGluZ3MnLCBzZXR0aW5ncyk7XG4gICAgfTtcblxuICBzZXRTaG91bGRTaG93V2FybmluZ3NBbmRFcnJvcnMoc3RhdHVzOiBib29sZWFuKTogdm9pZCB7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0dXMgPSB0aGlzLl9zaG91bGRTaG93V2FybmluZ3NBbmRFcnJvcnM7XG4gICAgdGhpcy5fc2hvdWxkU2hvd1dhcm5pbmdzQW5kRXJyb3JzID0gc3RhdHVzO1xuXG4gICAgaWYgKHByZXZpb3VzU3RhdHVzICE9PSBzdGF0dXMpIHtcbiAgICAgIC8vIFByb3BhZ2F0ZSB0byBzdWJzY3JpYmVycywgYWx0aG91Z2ggdHJlZSBzdGF0ZSBoYXMgbm90IGNoYW5nZWRcbiAgICAgIHRoaXMuZW1pdCgnbXV0YXRlZCcsIFtbXSwgbmV3IE1hcCgpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIFN0b3JlIHNob3VsZCBuZXZlciB0aHJvdyBhbiBFcnJvciB3aXRob3V0IGFsc28gZW1pdHRpbmcgYW4gZXZlbnQuXG4gIC8vIE90aGVyd2lzZSBTdG9yZSBlcnJvcnMgd2lsbCBiZSBpbnZpc2libGUgdG8gdXNlcnMsXG4gIC8vIGJ1dCB0aGUgZG93bnN0cmVhbSBlcnJvcnMgdGhleSBjYXVzZSB3aWxsIGJlIHJlcG9ydGVkIGFzIGJ1Z3MuXG4gIC8vIEZvciBleGFtcGxlLCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNDAyXG4gIC8vIEVtaXR0aW5nIGFuIGVycm9yIGV2ZW50IGFsbG93cyB0aGUgRXJyb3JCb3VuZGFyeSB0byBzaG93IHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgX3Rocm93QW5kRW1pdEVycm9yKGVycm9yOiBFcnJvcik6IGVtcHR5IHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgLy8gVGhyb3dpbmcgaXMgc3RpbGwgdmFsdWFibGUgZm9yIGxvY2FsIGRldmVsb3BtZW50XG4gICAgLy8gYW5kIGZvciB1bml0IHRlc3RpbmcgdGhlIFN0b3JlIGl0c2VsZi5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/store.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/utils.js":
/*!******************************************************!*\
  !*** ../react-devtools-shared/src/devtools/utils.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"printElement\": () => (/* binding */ printElement),\n/* harmony export */   \"printOwnersList\": () => (/* binding */ printOwnersList),\n/* harmony export */   \"printStore\": () => (/* binding */ printStore),\n/* harmony export */   \"sanitizeForParse\": () => (/* binding */ sanitizeForParse),\n/* harmony export */   \"smartParse\": () => (/* binding */ smartParse),\n/* harmony export */   \"smartStringify\": () => (/* binding */ smartStringify),\n/* harmony export */   \"stackToComponentSources\": () => (/* binding */ stackToComponentSources)\n/* harmony export */ });\n/* harmony import */ var json5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json5 */ \"../../node_modules/json5/dist/index.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction printElement(element, includeWeight = false) {\n  let prefix = ' ';\n\n  if (element.children.length > 0) {\n    prefix = element.isCollapsed ? '' : '';\n  }\n\n  let key = '';\n\n  if (element.key !== null) {\n    key = ` key=\"${element.key}\"`;\n  }\n\n  let hocDisplayNames = null;\n\n  if (element.hocDisplayNames !== null) {\n    hocDisplayNames = [...element.hocDisplayNames];\n  }\n\n  const hocs = hocDisplayNames === null ? '' : ` [${hocDisplayNames.join('][')}]`;\n  let suffix = '';\n\n  if (includeWeight) {\n    suffix = ` (${element.isCollapsed ? 1 : element.weight})`;\n  }\n\n  return `${'  '.repeat(element.depth + 1)}${prefix} <${element.displayName || 'null'}${key}>${hocs}${suffix}`;\n}\nfunction printOwnersList(elements, includeWeight = false) {\n  return elements.map(element => printElement(element, includeWeight)).join('\\n');\n}\nfunction printStore(store, includeWeight = false, state = null) {\n  const snapshotLines = [];\n  let rootWeight = 0;\n\n  function printSelectedMarker(index) {\n    if (state === null) {\n      return '';\n    }\n\n    return state.selectedElementIndex === index ? `` : ' ';\n  }\n\n  function printErrorsAndWarnings(element) {\n    const {\n      errorCount,\n      warningCount\n    } = store.getErrorAndWarningCountForElementID(element.id);\n\n    if (errorCount === 0 && warningCount === 0) {\n      return '';\n    }\n\n    return ` ${errorCount > 0 ? '' : ''}${warningCount > 0 ? '' : ''}`;\n  }\n\n  const ownerFlatTree = state !== null ? state.ownerFlatTree : null;\n\n  if (ownerFlatTree !== null) {\n    snapshotLines.push('[owners]' + (includeWeight ? ` (${ownerFlatTree.length})` : ''));\n    ownerFlatTree.forEach((element, index) => {\n      const printedSelectedMarker = printSelectedMarker(index);\n      const printedElement = printElement(element, false);\n      const printedErrorsAndWarnings = printErrorsAndWarnings(element);\n      snapshotLines.push(`${printedSelectedMarker}${printedElement}${printedErrorsAndWarnings}`);\n    });\n  } else {\n    const errorsAndWarnings = store._errorsAndWarnings;\n\n    if (errorsAndWarnings.size > 0) {\n      let errorCount = 0;\n      let warningCount = 0;\n      errorsAndWarnings.forEach(entry => {\n        errorCount += entry.errorCount;\n        warningCount += entry.warningCount;\n      });\n      snapshotLines.push(` ${errorCount},  ${warningCount}`);\n    }\n\n    store.roots.forEach(rootID => {\n      const {\n        weight\n      } = store.getElementByID(rootID);\n      const maybeWeightLabel = includeWeight ? ` (${weight})` : ''; // Store does not (yet) expose a way to get errors/warnings per root.\n\n      snapshotLines.push(`[root]${maybeWeightLabel}`);\n\n      for (let i = rootWeight; i < rootWeight + weight; i++) {\n        const element = store.getElementAtIndex(i);\n\n        if (element == null) {\n          throw Error(`Could not find element at index \"${i}\"`);\n        }\n\n        const printedSelectedMarker = printSelectedMarker(i);\n        const printedElement = printElement(element, includeWeight);\n        const printedErrorsAndWarnings = printErrorsAndWarnings(element);\n        snapshotLines.push(`${printedSelectedMarker}${printedElement}${printedErrorsAndWarnings}`);\n      }\n\n      rootWeight += weight;\n    }); // Make sure the pretty-printed test align with the Store's reported number of total rows.\n\n    if (rootWeight !== store.numElements) {\n      throw Error(`Inconsistent Store state. Individual root weights (\"${rootWeight}\") do not match total weight (\"${store.numElements}\")`);\n    } // If roots have been unmounted, verify that they've been removed from maps.\n    // This helps ensure the Store doesn't leak memory.\n\n\n    store.assertExpectedRootMapSizes();\n  }\n\n  return snapshotLines.join('\\n');\n} // We use JSON.parse to parse string values\n// e.g. 'foo' is not valid JSON but it is a valid string\n// so this method replaces e.g. 'foo' with \"foo\"\n\nfunction sanitizeForParse(value) {\n  if (typeof value === 'string') {\n    if (value.length >= 2 && value.charAt(0) === \"'\" && value.charAt(value.length - 1) === \"'\") {\n      return '\"' + value.slice(1, value.length - 1) + '\"';\n    }\n  }\n\n  return value;\n}\nfunction smartParse(value) {\n  switch (value) {\n    case 'Infinity':\n      return Infinity;\n\n    case 'NaN':\n      return NaN;\n\n    case 'undefined':\n      return undefined;\n\n    default:\n      return json5__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parse(sanitizeForParse(value));\n  }\n}\nfunction smartStringify(value) {\n  if (typeof value === 'number') {\n    if (Number.isNaN(value)) {\n      return 'NaN';\n    } else if (!Number.isFinite(value)) {\n      return 'Infinity';\n    }\n  } else if (value === undefined) {\n    return 'undefined';\n  }\n\n  return JSON.stringify(value);\n} // [url, row, column]\n\nconst STACK_DELIMETER = /\\n\\s+at /;\nconst STACK_SOURCE_LOCATION = /([^\\s]+) \\((.+):(.+):(.+)\\)/;\nfunction stackToComponentSources(stack) {\n  const out = [];\n  stack.split(STACK_DELIMETER).slice(1).forEach(entry => {\n    const match = STACK_SOURCE_LOCATION.exec(entry);\n\n    if (match) {\n      const [, component, url, row, column] = match;\n      out.push([component, [url, parseInt(row, 10), parseInt(column, 10)]]);\n    } else {\n      out.push([entry, null]);\n    }\n  });\n  return out;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBTUE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBRUE7QUFJQTtBQUdBO0FBRUE7QUFLQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUdBO0FBR0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUtBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvdXRpbHMuanM/MGRmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgSlNPTjUgZnJvbSAnanNvbjUnO1xuXG5pbXBvcnQgdHlwZSB7RWxlbWVudH0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7U3RhdGVDb250ZXh0fSBmcm9tICcuL3ZpZXdzL0NvbXBvbmVudHMvVHJlZUNvbnRleHQnO1xuaW1wb3J0IHR5cGUgU3RvcmUgZnJvbSAnLi9zdG9yZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmludEVsZW1lbnQoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGluY2x1ZGVXZWlnaHQ6IGJvb2xlYW4gPSBmYWxzZSxcbik6IHN0cmluZyB7XG4gIGxldCBwcmVmaXggPSAnICc7XG4gIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICBwcmVmaXggPSBlbGVtZW50LmlzQ29sbGFwc2VkID8gJ+KWuCcgOiAn4pa+JztcbiAgfVxuXG4gIGxldCBrZXkgPSAnJztcbiAgaWYgKGVsZW1lbnQua2V5ICE9PSBudWxsKSB7XG4gICAga2V5ID0gYCBrZXk9XCIke2VsZW1lbnQua2V5fVwiYDtcbiAgfVxuXG4gIGxldCBob2NEaXNwbGF5TmFtZXMgPSBudWxsO1xuICBpZiAoZWxlbWVudC5ob2NEaXNwbGF5TmFtZXMgIT09IG51bGwpIHtcbiAgICBob2NEaXNwbGF5TmFtZXMgPSBbLi4uZWxlbWVudC5ob2NEaXNwbGF5TmFtZXNdO1xuICB9XG5cbiAgY29uc3QgaG9jcyA9XG4gICAgaG9jRGlzcGxheU5hbWVzID09PSBudWxsID8gJycgOiBgIFske2hvY0Rpc3BsYXlOYW1lcy5qb2luKCddWycpfV1gO1xuXG4gIGxldCBzdWZmaXggPSAnJztcbiAgaWYgKGluY2x1ZGVXZWlnaHQpIHtcbiAgICBzdWZmaXggPSBgICgke2VsZW1lbnQuaXNDb2xsYXBzZWQgPyAxIDogZWxlbWVudC53ZWlnaHR9KWA7XG4gIH1cblxuICByZXR1cm4gYCR7JyAgJy5yZXBlYXQoZWxlbWVudC5kZXB0aCArIDEpfSR7cHJlZml4fSA8JHtcbiAgICBlbGVtZW50LmRpc3BsYXlOYW1lIHx8ICdudWxsJ1xuICB9JHtrZXl9PiR7aG9jc30ke3N1ZmZpeH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRPd25lcnNMaXN0KFxuICBlbGVtZW50czogQXJyYXk8RWxlbWVudD4sXG4gIGluY2x1ZGVXZWlnaHQ6IGJvb2xlYW4gPSBmYWxzZSxcbik6IHN0cmluZyB7XG4gIHJldHVybiBlbGVtZW50c1xuICAgIC5tYXAoZWxlbWVudCA9PiBwcmludEVsZW1lbnQoZWxlbWVudCwgaW5jbHVkZVdlaWdodCkpXG4gICAgLmpvaW4oJ1xcbicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRTdG9yZShcbiAgc3RvcmU6IFN0b3JlLFxuICBpbmNsdWRlV2VpZ2h0OiBib29sZWFuID0gZmFsc2UsXG4gIHN0YXRlOiBTdGF0ZUNvbnRleHQgfCBudWxsID0gbnVsbCxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHNuYXBzaG90TGluZXMgPSBbXTtcblxuICBsZXQgcm9vdFdlaWdodCA9IDA7XG5cbiAgZnVuY3Rpb24gcHJpbnRTZWxlY3RlZE1hcmtlcihpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnNlbGVjdGVkRWxlbWVudEluZGV4ID09PSBpbmRleCA/IGDihpJgIDogJyAnO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRFcnJvcnNBbmRXYXJuaW5ncyhlbGVtZW50OiBFbGVtZW50KTogc3RyaW5nIHtcbiAgICBjb25zdCB7ZXJyb3JDb3VudCwgd2FybmluZ0NvdW50fSA9XG4gICAgICBzdG9yZS5nZXRFcnJvckFuZFdhcm5pbmdDb3VudEZvckVsZW1lbnRJRChlbGVtZW50LmlkKTtcbiAgICBpZiAoZXJyb3JDb3VudCA9PT0gMCAmJiB3YXJuaW5nQ291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGAgJHtlcnJvckNvdW50ID4gMCA/ICfinJUnIDogJyd9JHt3YXJuaW5nQ291bnQgPiAwID8gJ+KaoCcgOiAnJ31gO1xuICB9XG5cbiAgY29uc3Qgb3duZXJGbGF0VHJlZSA9IHN0YXRlICE9PSBudWxsID8gc3RhdGUub3duZXJGbGF0VHJlZSA6IG51bGw7XG4gIGlmIChvd25lckZsYXRUcmVlICE9PSBudWxsKSB7XG4gICAgc25hcHNob3RMaW5lcy5wdXNoKFxuICAgICAgJ1tvd25lcnNdJyArIChpbmNsdWRlV2VpZ2h0ID8gYCAoJHtvd25lckZsYXRUcmVlLmxlbmd0aH0pYCA6ICcnKSxcbiAgICApO1xuICAgIG93bmVyRmxhdFRyZWUuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHByaW50ZWRTZWxlY3RlZE1hcmtlciA9IHByaW50U2VsZWN0ZWRNYXJrZXIoaW5kZXgpO1xuICAgICAgY29uc3QgcHJpbnRlZEVsZW1lbnQgPSBwcmludEVsZW1lbnQoZWxlbWVudCwgZmFsc2UpO1xuICAgICAgY29uc3QgcHJpbnRlZEVycm9yc0FuZFdhcm5pbmdzID0gcHJpbnRFcnJvcnNBbmRXYXJuaW5ncyhlbGVtZW50KTtcbiAgICAgIHNuYXBzaG90TGluZXMucHVzaChcbiAgICAgICAgYCR7cHJpbnRlZFNlbGVjdGVkTWFya2VyfSR7cHJpbnRlZEVsZW1lbnR9JHtwcmludGVkRXJyb3JzQW5kV2FybmluZ3N9YCxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXJyb3JzQW5kV2FybmluZ3MgPSBzdG9yZS5fZXJyb3JzQW5kV2FybmluZ3M7XG4gICAgaWYgKGVycm9yc0FuZFdhcm5pbmdzLnNpemUgPiAwKSB7XG4gICAgICBsZXQgZXJyb3JDb3VudCA9IDA7XG4gICAgICBsZXQgd2FybmluZ0NvdW50ID0gMDtcbiAgICAgIGVycm9yc0FuZFdhcm5pbmdzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICBlcnJvckNvdW50ICs9IGVudHJ5LmVycm9yQ291bnQ7XG4gICAgICAgIHdhcm5pbmdDb3VudCArPSBlbnRyeS53YXJuaW5nQ291bnQ7XG4gICAgICB9KTtcblxuICAgICAgc25hcHNob3RMaW5lcy5wdXNoKGDinJUgJHtlcnJvckNvdW50fSwg4pqgICR7d2FybmluZ0NvdW50fWApO1xuICAgIH1cblxuICAgIHN0b3JlLnJvb3RzLmZvckVhY2gocm9vdElEID0+IHtcbiAgICAgIGNvbnN0IHt3ZWlnaHR9ID0gKChzdG9yZS5nZXRFbGVtZW50QnlJRChyb290SUQpOiBhbnkpOiBFbGVtZW50KTtcbiAgICAgIGNvbnN0IG1heWJlV2VpZ2h0TGFiZWwgPSBpbmNsdWRlV2VpZ2h0ID8gYCAoJHt3ZWlnaHR9KWAgOiAnJztcblxuICAgICAgLy8gU3RvcmUgZG9lcyBub3QgKHlldCkgZXhwb3NlIGEgd2F5IHRvIGdldCBlcnJvcnMvd2FybmluZ3MgcGVyIHJvb3QuXG4gICAgICBzbmFwc2hvdExpbmVzLnB1c2goYFtyb290XSR7bWF5YmVXZWlnaHRMYWJlbH1gKTtcblxuICAgICAgZm9yIChsZXQgaSA9IHJvb3RXZWlnaHQ7IGkgPCByb290V2VpZ2h0ICsgd2VpZ2h0OyBpKyspIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHN0b3JlLmdldEVsZW1lbnRBdEluZGV4KGkpO1xuXG4gICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGZpbmQgZWxlbWVudCBhdCBpbmRleCBcIiR7aX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJpbnRlZFNlbGVjdGVkTWFya2VyID0gcHJpbnRTZWxlY3RlZE1hcmtlcihpKTtcbiAgICAgICAgY29uc3QgcHJpbnRlZEVsZW1lbnQgPSBwcmludEVsZW1lbnQoZWxlbWVudCwgaW5jbHVkZVdlaWdodCk7XG4gICAgICAgIGNvbnN0IHByaW50ZWRFcnJvcnNBbmRXYXJuaW5ncyA9IHByaW50RXJyb3JzQW5kV2FybmluZ3MoZWxlbWVudCk7XG4gICAgICAgIHNuYXBzaG90TGluZXMucHVzaChcbiAgICAgICAgICBgJHtwcmludGVkU2VsZWN0ZWRNYXJrZXJ9JHtwcmludGVkRWxlbWVudH0ke3ByaW50ZWRFcnJvcnNBbmRXYXJuaW5nc31gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByb290V2VpZ2h0ICs9IHdlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgcHJldHR5LXByaW50ZWQgdGVzdCBhbGlnbiB3aXRoIHRoZSBTdG9yZSdzIHJlcG9ydGVkIG51bWJlciBvZiB0b3RhbCByb3dzLlxuICAgIGlmIChyb290V2VpZ2h0ICE9PSBzdG9yZS5udW1FbGVtZW50cykge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBJbmNvbnNpc3RlbnQgU3RvcmUgc3RhdGUuIEluZGl2aWR1YWwgcm9vdCB3ZWlnaHRzIChcIiR7cm9vdFdlaWdodH1cIikgZG8gbm90IG1hdGNoIHRvdGFsIHdlaWdodCAoXCIke3N0b3JlLm51bUVsZW1lbnRzfVwiKWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIHJvb3RzIGhhdmUgYmVlbiB1bm1vdW50ZWQsIHZlcmlmeSB0aGF0IHRoZXkndmUgYmVlbiByZW1vdmVkIGZyb20gbWFwcy5cbiAgICAvLyBUaGlzIGhlbHBzIGVuc3VyZSB0aGUgU3RvcmUgZG9lc24ndCBsZWFrIG1lbW9yeS5cbiAgICBzdG9yZS5hc3NlcnRFeHBlY3RlZFJvb3RNYXBTaXplcygpO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBzaG90TGluZXMuam9pbignXFxuJyk7XG59XG5cbi8vIFdlIHVzZSBKU09OLnBhcnNlIHRvIHBhcnNlIHN0cmluZyB2YWx1ZXNcbi8vIGUuZy4gJ2ZvbycgaXMgbm90IHZhbGlkIEpTT04gYnV0IGl0IGlzIGEgdmFsaWQgc3RyaW5nXG4vLyBzbyB0aGlzIG1ldGhvZCByZXBsYWNlcyBlLmcuICdmb28nIHdpdGggXCJmb29cIlxuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplRm9yUGFyc2UodmFsdWU6IGFueSk6IGFueSB8IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUubGVuZ3RoID49IDIgJiZcbiAgICAgIHZhbHVlLmNoYXJBdCgwKSA9PT0gXCInXCIgJiZcbiAgICAgIHZhbHVlLmNoYXJBdCh2YWx1ZS5sZW5ndGggLSAxKSA9PT0gXCInXCJcbiAgICApIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsdWUuc2xpY2UoMSwgdmFsdWUubGVuZ3RoIC0gMSkgKyAnXCInO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbWFydFBhcnNlKHZhbHVlOiBhbnkpOiBhbnkgfCB2b2lkIHwgbnVtYmVyIHtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgJ0luZmluaXR5JzpcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICBjYXNlICdOYU4nOlxuICAgICAgcmV0dXJuIE5hTjtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEpTT041LnBhcnNlKHNhbml0aXplRm9yUGFyc2UodmFsdWUpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc21hcnRTdHJpbmdpZnkodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiAnTmFOJztcbiAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ0luZmluaXR5JztcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59XG5cbi8vIFt1cmwsIHJvdywgY29sdW1uXVxuZXhwb3J0IHR5cGUgU3RhY2sgPSBbc3RyaW5nLCBudW1iZXIsIG51bWJlcl07XG5cbmNvbnN0IFNUQUNLX0RFTElNRVRFUiA9IC9cXG5cXHMrYXQgLztcbmNvbnN0IFNUQUNLX1NPVVJDRV9MT0NBVElPTiA9IC8oW15cXHNdKykgXFwoKC4rKTooLispOiguKylcXCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhY2tUb0NvbXBvbmVudFNvdXJjZXMoXG4gIHN0YWNrOiBzdHJpbmcsXG4pOiBBcnJheTxbc3RyaW5nLCA/U3RhY2tdPiB7XG4gIGNvbnN0IG91dDogQXJyYXk8W3N0cmluZywgP1N0YWNrXT4gPSBbXTtcbiAgc3RhY2tcbiAgICAuc3BsaXQoU1RBQ0tfREVMSU1FVEVSKVxuICAgIC5zbGljZSgxKVxuICAgIC5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gU1RBQ0tfU09VUkNFX0xPQ0FUSU9OLmV4ZWMoZW50cnkpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IFssIGNvbXBvbmVudCwgdXJsLCByb3csIGNvbHVtbl0gPSBtYXRjaDtcbiAgICAgICAgb3V0LnB1c2goW2NvbXBvbmVudCwgW3VybCwgcGFyc2VJbnQocm93LCAxMCksIHBhcnNlSW50KGNvbHVtbiwgMTApXV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0LnB1c2goW2VudHJ5LCBudWxsXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/utils.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/views/Profiler/CommitTreeBuilder.js":
/*!*********************************************************************************!*\
  !*** ../react-devtools-shared/src/devtools/views/Profiler/CommitTreeBuilder.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getCommitTree\": () => (/* binding */ getCommitTree),\n/* harmony export */   \"invalidateCommitTrees\": () => (/* binding */ invalidateCommitTrees)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/* harmony import */ var react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/frontend/types */ \"../react-devtools-shared/src/frontend/types.js\");\n/* harmony import */ var react_devtools_shared_src_devtools_ProfilerStore__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-devtools-shared/src/devtools/ProfilerStore */ \"../react-devtools-shared/src/devtools/ProfilerStore.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\nconst debug = (methodName, ...args) => {\n  if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n    console.log(`%cCommitTreeBuilder %c${methodName}`, 'color: pink; font-weight: bold;', 'font-weight: bold;', ...args);\n  }\n};\n\nconst rootToCommitTreeMap = new Map();\nfunction getCommitTree({\n  commitIndex,\n  profilerStore,\n  rootID\n}) {\n  if (!rootToCommitTreeMap.has(rootID)) {\n    rootToCommitTreeMap.set(rootID, []);\n  }\n\n  const commitTrees = rootToCommitTreeMap.get(rootID);\n\n  if (commitIndex < commitTrees.length) {\n    return commitTrees[commitIndex];\n  }\n\n  const {\n    profilingData\n  } = profilerStore;\n\n  if (profilingData === null) {\n    throw Error(`No profiling data available`);\n  }\n\n  const dataForRoot = profilingData.dataForRoots.get(rootID);\n\n  if (dataForRoot == null) {\n    throw Error(`Could not find profiling data for root \"${rootID}\"`);\n  }\n\n  const {\n    operations\n  } = dataForRoot;\n\n  if (operations.length <= commitIndex) {\n    throw Error(`getCommitTree(): Invalid commit \"${commitIndex}\" for root \"${rootID}\". There are only \"${operations.length}\" commits.`);\n  }\n\n  let commitTree = null;\n\n  for (let index = commitTrees.length; index <= commitIndex; index++) {\n    // Commits are generated sequentially and cached.\n    // If this is the very first commit, start with the cached snapshot and apply the first mutation.\n    // Otherwise load (or generate) the previous commit and append a mutation to it.\n    if (index === 0) {\n      const nodes = new Map(); // Construct the initial tree.\n\n      recursivelyInitializeTree(rootID, 0, nodes, dataForRoot); // Mutate the tree\n\n      if (operations != null && index < operations.length) {\n        commitTree = updateTree({\n          nodes,\n          rootID\n        }, operations[index]);\n\n        if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n          __printTree(commitTree);\n        }\n\n        commitTrees.push(commitTree);\n      }\n    } else {\n      const previousCommitTree = commitTrees[index - 1];\n      commitTree = updateTree(previousCommitTree, operations[index]);\n\n      if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n        __printTree(commitTree);\n      }\n\n      commitTrees.push(commitTree);\n    }\n  }\n\n  return commitTree;\n}\n\nfunction recursivelyInitializeTree(id, parentID, nodes, dataForRoot) {\n  const node = dataForRoot.snapshots.get(id);\n\n  if (node != null) {\n    nodes.set(id, {\n      id,\n      children: node.children,\n      displayName: node.displayName,\n      hocDisplayNames: node.hocDisplayNames,\n      key: node.key,\n      parentID,\n      treeBaseDuration: dataForRoot.initialTreeBaseDurations.get(id),\n      type: node.type,\n      compiledWithForget: node.compiledWithForget\n    });\n    node.children.forEach(childID => recursivelyInitializeTree(childID, id, nodes, dataForRoot));\n  }\n}\n\nfunction updateTree(commitTree, operations) {\n  // Clone the original tree so edits don't affect it.\n  const nodes = new Map(commitTree.nodes); // Clone nodes before mutating them so edits don't affect them.\n\n  const getClonedNode = id => {\n    // $FlowFixMe[prop-missing] - recommended fix is to use object spread operator\n    const clonedNode = Object.assign({}, nodes.get(id));\n    nodes.set(id, clonedNode);\n    return clonedNode;\n  };\n\n  let i = 2;\n  let id = null; // Reassemble the string table.\n\n  const stringTable = [null // ID = 0 corresponds to the null string.\n  ];\n  const stringTableSize = operations[i++];\n  const stringTableEnd = i + stringTableSize;\n\n  while (i < stringTableEnd) {\n    const nextLength = operations[i++];\n    const nextString = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.utfDecodeStringWithRanges)(operations, i, i + nextLength - 1);\n    stringTable.push(nextString);\n    i += nextLength;\n  }\n\n  while (i < operations.length) {\n    const operation = operations[i];\n\n    switch (operation) {\n      case react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.TREE_OPERATION_ADD:\n        {\n          id = operations[i + 1];\n          const type = operations[i + 2];\n          i += 3;\n\n          if (nodes.has(id)) {\n            throw new Error(`Commit tree already contains fiber \"${id}\". This is a bug in React DevTools.`);\n          }\n\n          if (type === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_2__.ElementTypeRoot) {\n            i++; // isStrictModeCompliant\n\n            i++; // Profiling flag\n\n            i++; // supportsStrictMode flag\n\n            i++; // hasOwnerMetadata flag\n\n            if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n              debug('Add', `new root fiber ${id}`);\n            }\n\n            const node = {\n              children: [],\n              displayName: null,\n              hocDisplayNames: null,\n              id,\n              key: null,\n              parentID: 0,\n              treeBaseDuration: 0,\n              // This will be updated by a subsequent operation\n              type,\n              compiledWithForget: false\n            };\n            nodes.set(id, node);\n          } else {\n            const parentID = operations[i];\n            i++;\n            i++; // ownerID\n\n            const displayNameStringID = operations[i];\n            const displayName = stringTable[displayNameStringID];\n            i++;\n            const keyStringID = operations[i];\n            const key = stringTable[keyStringID];\n            i++;\n\n            if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n              debug('Add', `fiber ${id} (${displayName || 'null'}) as child of ${parentID}`);\n            }\n\n            const parentNode = getClonedNode(parentID);\n            parentNode.children = parentNode.children.concat(id);\n            const {\n              formattedDisplayName,\n              hocDisplayNames,\n              compiledWithForget\n            } = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.parseElementDisplayNameFromBackend)(displayName, type);\n            const node = {\n              children: [],\n              displayName: formattedDisplayName,\n              hocDisplayNames: hocDisplayNames,\n              id,\n              key,\n              parentID,\n              treeBaseDuration: 0,\n              // This will be updated by a subsequent operation\n              type,\n              compiledWithForget\n            };\n            nodes.set(id, node);\n          }\n\n          break;\n        }\n\n      case react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.TREE_OPERATION_REMOVE:\n        {\n          const removeLength = operations[i + 1];\n          i += 2;\n\n          for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {\n            id = operations[i];\n            i++;\n\n            if (!nodes.has(id)) {\n              throw new Error(`Commit tree does not contain fiber \"${id}\". This is a bug in React DevTools.`);\n            }\n\n            const node = getClonedNode(id);\n            const parentID = node.parentID;\n            nodes.delete(id);\n\n            if (!nodes.has(parentID)) {// No-op\n            } else {\n              const parentNode = getClonedNode(parentID);\n\n              if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n                debug('Remove', `fiber ${id} from parent ${parentID}`);\n              }\n\n              parentNode.children = parentNode.children.filter(childID => childID !== id);\n            }\n          }\n\n          break;\n        }\n\n      case react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.TREE_OPERATION_REMOVE_ROOT:\n        {\n          throw Error('Operation REMOVE_ROOT is not supported while profiling.');\n        }\n\n      case react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.TREE_OPERATION_REORDER_CHILDREN:\n        {\n          id = operations[i + 1];\n          const numChildren = operations[i + 2];\n          const children = operations.slice(i + 3, i + 3 + numChildren);\n          i = i + 3 + numChildren;\n\n          if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n            debug('Re-order', `fiber ${id} children ${children.join(',')}`);\n          }\n\n          const node = getClonedNode(id);\n          node.children = Array.from(children);\n          break;\n        }\n\n      case react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.TREE_OPERATION_SET_SUBTREE_MODE:\n        {\n          id = operations[i + 1];\n          const mode = operations[i + 1];\n          i += 3;\n\n          if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n            debug('Subtree mode', `Subtree with root ${id} set to mode ${mode}`);\n          }\n\n          break;\n        }\n\n      case react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.TREE_OPERATION_UPDATE_TREE_BASE_DURATION:\n        {\n          id = operations[i + 1];\n          const node = getClonedNode(id);\n          node.treeBaseDuration = operations[i + 2] / 1000; // Convert microseconds back to milliseconds;\n\n          if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n            debug('Update', `fiber ${id} treeBaseDuration to ${node.treeBaseDuration}`);\n          }\n\n          i += 3;\n          break;\n        }\n\n      case react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:\n        {\n          id = operations[i + 1];\n          const numErrors = operations[i + 2];\n          const numWarnings = operations[i + 3];\n          i += 4;\n\n          if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n            debug('Warnings and Errors update', `fiber ${id} has ${numErrors} errors and ${numWarnings} warnings`);\n          }\n\n          break;\n        }\n\n      default:\n        throw Error(`Unsupported Bridge operation \"${operation}\"`);\n    }\n  }\n\n  return {\n    nodes,\n    rootID: commitTree.rootID\n  };\n}\n\nfunction invalidateCommitTrees() {\n  rootToCommitTreeMap.clear();\n} // DEBUG\n\nconst __printTree = commitTree => {\n  if (react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.__DEBUG__) {\n    const {\n      nodes,\n      rootID\n    } = commitTree;\n    console.group('__printTree()');\n    const queue = [rootID, 0];\n\n    while (queue.length > 0) {\n      const id = queue.shift();\n      const depth = queue.shift(); // $FlowFixMe[incompatible-call]\n\n      const node = nodes.get(id);\n\n      if (node == null) {\n        // $FlowFixMe[incompatible-type]\n        throw Error(`Could not find node with id \"${id}\" in commit tree`);\n      }\n\n      console.log( // $FlowFixMe[incompatible-call]\n      `${''.repeat(depth)}${node.id}:${node.displayName || ''} ${node.key ? `key:\"${node.key}\"` : ''} (${node.treeBaseDuration})`);\n      node.children.forEach(childID => {\n        // $FlowFixMe[unsafe-addition]\n        queue.push(childID, depth + 1);\n      });\n    }\n\n    console.groupEnd();\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy92aWV3cy9Qcm9maWxlci9Db21taXRUcmVlQnVpbGRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQVVBO0FBSUE7QUFDQTs7QUFTQTtBQUNBO0FBQ0E7QUFNQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQVNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFHQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFNQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBWEE7QUFjQTtBQUdBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQUE7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVRBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVRBO0FBWUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUlBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQXJMQTtBQXVMQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvdmlld3MvUHJvZmlsZXIvQ29tbWl0VHJlZUJ1aWxkZXIuanM/ZDJlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge1xuICBfX0RFQlVHX18sXG4gIFRSRUVfT1BFUkFUSU9OX0FERCxcbiAgVFJFRV9PUEVSQVRJT05fUkVNT1ZFLFxuICBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCxcbiAgVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTixcbiAgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSxcbiAgVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTixcbiAgVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgcGFyc2VFbGVtZW50RGlzcGxheU5hbWVGcm9tQmFja2VuZCxcbiAgdXRmRGVjb2RlU3RyaW5nV2l0aFJhbmdlcyxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy91dGlscyc7XG5pbXBvcnQge0VsZW1lbnRUeXBlUm9vdH0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5pbXBvcnQgUHJvZmlsZXJTdG9yZSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL1Byb2ZpbGVyU3RvcmUnO1xuXG5pbXBvcnQgdHlwZSB7RWxlbWVudFR5cGV9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZnJvbnRlbmQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBDb21taXRUcmVlLFxuICBDb21taXRUcmVlTm9kZSxcbiAgUHJvZmlsaW5nRGF0YUZvclJvb3RGcm9udGVuZCxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy92aWV3cy9Qcm9maWxlci90eXBlcyc7XG5cbmNvbnN0IGRlYnVnID0gKG1ldGhvZE5hbWU6IHN0cmluZywgLi4uYXJnczogQXJyYXk8c3RyaW5nPikgPT4ge1xuICBpZiAoX19ERUJVR19fKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgJWNDb21taXRUcmVlQnVpbGRlciAlYyR7bWV0aG9kTmFtZX1gLFxuICAgICAgJ2NvbG9yOiBwaW5rOyBmb250LXdlaWdodDogYm9sZDsnLFxuICAgICAgJ2ZvbnQtd2VpZ2h0OiBib2xkOycsXG4gICAgICAuLi5hcmdzLFxuICAgICk7XG4gIH1cbn07XG5cbmNvbnN0IHJvb3RUb0NvbW1pdFRyZWVNYXA6IE1hcDxudW1iZXIsIEFycmF5PENvbW1pdFRyZWU+PiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdFRyZWUoe1xuICBjb21taXRJbmRleCxcbiAgcHJvZmlsZXJTdG9yZSxcbiAgcm9vdElELFxufToge1xuICBjb21taXRJbmRleDogbnVtYmVyLFxuICBwcm9maWxlclN0b3JlOiBQcm9maWxlclN0b3JlLFxuICByb290SUQ6IG51bWJlcixcbn0pOiBDb21taXRUcmVlIHtcbiAgaWYgKCFyb290VG9Db21taXRUcmVlTWFwLmhhcyhyb290SUQpKSB7XG4gICAgcm9vdFRvQ29tbWl0VHJlZU1hcC5zZXQocm9vdElELCBbXSk7XG4gIH1cblxuICBjb25zdCBjb21taXRUcmVlcyA9ICgocm9vdFRvQ29tbWl0VHJlZU1hcC5nZXQoXG4gICAgcm9vdElELFxuICApOiBhbnkpOiBBcnJheTxDb21taXRUcmVlPik7XG4gIGlmIChjb21taXRJbmRleCA8IGNvbW1pdFRyZWVzLmxlbmd0aCkge1xuICAgIHJldHVybiBjb21taXRUcmVlc1tjb21taXRJbmRleF07XG4gIH1cblxuICBjb25zdCB7cHJvZmlsaW5nRGF0YX0gPSBwcm9maWxlclN0b3JlO1xuICBpZiAocHJvZmlsaW5nRGF0YSA9PT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKGBObyBwcm9maWxpbmcgZGF0YSBhdmFpbGFibGVgKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGFGb3JSb290ID0gcHJvZmlsaW5nRGF0YS5kYXRhRm9yUm9vdHMuZ2V0KHJvb3RJRCk7XG4gIGlmIChkYXRhRm9yUm9vdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHByb2ZpbGluZyBkYXRhIGZvciByb290IFwiJHtyb290SUR9XCJgKTtcbiAgfVxuXG4gIGNvbnN0IHtvcGVyYXRpb25zfSA9IGRhdGFGb3JSb290O1xuICBpZiAob3BlcmF0aW9ucy5sZW5ndGggPD0gY29tbWl0SW5kZXgpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIGBnZXRDb21taXRUcmVlKCk6IEludmFsaWQgY29tbWl0IFwiJHtjb21taXRJbmRleH1cIiBmb3Igcm9vdCBcIiR7cm9vdElEfVwiLiBUaGVyZSBhcmUgb25seSBcIiR7b3BlcmF0aW9ucy5sZW5ndGh9XCIgY29tbWl0cy5gLFxuICAgICk7XG4gIH1cblxuICBsZXQgY29tbWl0VHJlZTogQ29tbWl0VHJlZSA9ICgobnVsbDogYW55KTogQ29tbWl0VHJlZSk7XG4gIGZvciAobGV0IGluZGV4ID0gY29tbWl0VHJlZXMubGVuZ3RoOyBpbmRleCA8PSBjb21taXRJbmRleDsgaW5kZXgrKykge1xuICAgIC8vIENvbW1pdHMgYXJlIGdlbmVyYXRlZCBzZXF1ZW50aWFsbHkgYW5kIGNhY2hlZC5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSB2ZXJ5IGZpcnN0IGNvbW1pdCwgc3RhcnQgd2l0aCB0aGUgY2FjaGVkIHNuYXBzaG90IGFuZCBhcHBseSB0aGUgZmlyc3QgbXV0YXRpb24uXG4gICAgLy8gT3RoZXJ3aXNlIGxvYWQgKG9yIGdlbmVyYXRlKSB0aGUgcHJldmlvdXMgY29tbWl0IGFuZCBhcHBlbmQgYSBtdXRhdGlvbiB0byBpdC5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gbmV3IE1hcDxudW1iZXIsIENvbW1pdFRyZWVOb2RlPigpO1xuXG4gICAgICAvLyBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgdHJlZS5cbiAgICAgIHJlY3Vyc2l2ZWx5SW5pdGlhbGl6ZVRyZWUocm9vdElELCAwLCBub2RlcywgZGF0YUZvclJvb3QpO1xuXG4gICAgICAvLyBNdXRhdGUgdGhlIHRyZWVcbiAgICAgIGlmIChvcGVyYXRpb25zICE9IG51bGwgJiYgaW5kZXggPCBvcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBjb21taXRUcmVlID0gdXBkYXRlVHJlZSh7bm9kZXMsIHJvb3RJRH0sIG9wZXJhdGlvbnNbaW5kZXhdKTtcblxuICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgX19wcmludFRyZWUoY29tbWl0VHJlZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21taXRUcmVlcy5wdXNoKGNvbW1pdFRyZWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91c0NvbW1pdFRyZWUgPSBjb21taXRUcmVlc1tpbmRleCAtIDFdO1xuICAgICAgY29tbWl0VHJlZSA9IHVwZGF0ZVRyZWUocHJldmlvdXNDb21taXRUcmVlLCBvcGVyYXRpb25zW2luZGV4XSk7XG5cbiAgICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgICAgX19wcmludFRyZWUoY29tbWl0VHJlZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbW1pdFRyZWVzLnB1c2goY29tbWl0VHJlZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbW1pdFRyZWU7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5SW5pdGlhbGl6ZVRyZWUoXG4gIGlkOiBudW1iZXIsXG4gIHBhcmVudElEOiBudW1iZXIsXG4gIG5vZGVzOiBNYXA8bnVtYmVyLCBDb21taXRUcmVlTm9kZT4sXG4gIGRhdGFGb3JSb290OiBQcm9maWxpbmdEYXRhRm9yUm9vdEZyb250ZW5kLFxuKTogdm9pZCB7XG4gIGNvbnN0IG5vZGUgPSBkYXRhRm9yUm9vdC5zbmFwc2hvdHMuZ2V0KGlkKTtcbiAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgIG5vZGVzLnNldChpZCwge1xuICAgICAgaWQsXG4gICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbixcbiAgICAgIGRpc3BsYXlOYW1lOiBub2RlLmRpc3BsYXlOYW1lLFxuICAgICAgaG9jRGlzcGxheU5hbWVzOiBub2RlLmhvY0Rpc3BsYXlOYW1lcyxcbiAgICAgIGtleTogbm9kZS5rZXksXG4gICAgICBwYXJlbnRJRCxcbiAgICAgIHRyZWVCYXNlRHVyYXRpb246ICgoZGF0YUZvclJvb3QuaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zLmdldChcbiAgICAgICAgaWQsXG4gICAgICApOiBhbnkpOiBudW1iZXIpLFxuICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgY29tcGlsZWRXaXRoRm9yZ2V0OiBub2RlLmNvbXBpbGVkV2l0aEZvcmdldCxcbiAgICB9KTtcblxuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZElEID0+XG4gICAgICByZWN1cnNpdmVseUluaXRpYWxpemVUcmVlKGNoaWxkSUQsIGlkLCBub2RlcywgZGF0YUZvclJvb3QpLFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlVHJlZShcbiAgY29tbWl0VHJlZTogQ29tbWl0VHJlZSxcbiAgb3BlcmF0aW9uczogQXJyYXk8bnVtYmVyPixcbik6IENvbW1pdFRyZWUge1xuICAvLyBDbG9uZSB0aGUgb3JpZ2luYWwgdHJlZSBzbyBlZGl0cyBkb24ndCBhZmZlY3QgaXQuXG4gIGNvbnN0IG5vZGVzID0gbmV3IE1hcChjb21taXRUcmVlLm5vZGVzKTtcblxuICAvLyBDbG9uZSBub2RlcyBiZWZvcmUgbXV0YXRpbmcgdGhlbSBzbyBlZGl0cyBkb24ndCBhZmZlY3QgdGhlbS5cbiAgY29uc3QgZ2V0Q2xvbmVkTm9kZSA9IChpZDogbnVtYmVyKTogQ29tbWl0VHJlZU5vZGUgPT4ge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSAtIHJlY29tbWVuZGVkIGZpeCBpcyB0byB1c2Ugb2JqZWN0IHNwcmVhZCBvcGVyYXRvclxuICAgIGNvbnN0IGNsb25lZE5vZGUgPSAoKE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIG5vZGVzLmdldChpZCksXG4gICAgKTogYW55KTogQ29tbWl0VHJlZU5vZGUpO1xuICAgIG5vZGVzLnNldChpZCwgY2xvbmVkTm9kZSk7XG4gICAgcmV0dXJuIGNsb25lZE5vZGU7XG4gIH07XG5cbiAgbGV0IGkgPSAyO1xuICBsZXQgaWQ6IG51bWJlciA9ICgobnVsbDogYW55KTogbnVtYmVyKTtcblxuICAvLyBSZWFzc2VtYmxlIHRoZSBzdHJpbmcgdGFibGUuXG4gIGNvbnN0IHN0cmluZ1RhYmxlOiBBcnJheTxudWxsIHwgc3RyaW5nPiA9IFtcbiAgICBudWxsLCAvLyBJRCA9IDAgY29ycmVzcG9uZHMgdG8gdGhlIG51bGwgc3RyaW5nLlxuICBdO1xuICBjb25zdCBzdHJpbmdUYWJsZVNpemUgPSBvcGVyYXRpb25zW2krK107XG4gIGNvbnN0IHN0cmluZ1RhYmxlRW5kID0gaSArIHN0cmluZ1RhYmxlU2l6ZTtcbiAgd2hpbGUgKGkgPCBzdHJpbmdUYWJsZUVuZCkge1xuICAgIGNvbnN0IG5leHRMZW5ndGggPSBvcGVyYXRpb25zW2krK107XG4gICAgY29uc3QgbmV4dFN0cmluZyA9IHV0ZkRlY29kZVN0cmluZ1dpdGhSYW5nZXMoXG4gICAgICBvcGVyYXRpb25zLFxuICAgICAgaSxcbiAgICAgIGkgKyBuZXh0TGVuZ3RoIC0gMSxcbiAgICApO1xuICAgIHN0cmluZ1RhYmxlLnB1c2gobmV4dFN0cmluZyk7XG4gICAgaSArPSBuZXh0TGVuZ3RoO1xuICB9XG5cbiAgd2hpbGUgKGkgPCBvcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbaV07XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9BREQ6IHtcbiAgICAgICAgaWQgPSAoKG9wZXJhdGlvbnNbaSArIDFdOiBhbnkpOiBudW1iZXIpO1xuICAgICAgICBjb25zdCB0eXBlID0gKChvcGVyYXRpb25zW2kgKyAyXTogYW55KTogRWxlbWVudFR5cGUpO1xuXG4gICAgICAgIGkgKz0gMztcblxuICAgICAgICBpZiAobm9kZXMuaGFzKGlkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDb21taXQgdHJlZSBhbHJlYWR5IGNvbnRhaW5zIGZpYmVyIFwiJHtpZH1cIi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBEZXZUb29scy5gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gRWxlbWVudFR5cGVSb290KSB7XG4gICAgICAgICAgaSsrOyAvLyBpc1N0cmljdE1vZGVDb21wbGlhbnRcbiAgICAgICAgICBpKys7IC8vIFByb2ZpbGluZyBmbGFnXG4gICAgICAgICAgaSsrOyAvLyBzdXBwb3J0c1N0cmljdE1vZGUgZmxhZ1xuICAgICAgICAgIGkrKzsgLy8gaGFzT3duZXJNZXRhZGF0YSBmbGFnXG5cbiAgICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgICBkZWJ1ZygnQWRkJywgYG5ldyByb290IGZpYmVyICR7aWR9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgbm9kZTogQ29tbWl0VHJlZU5vZGUgPSB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgICAgICAgIGhvY0Rpc3BsYXlOYW1lczogbnVsbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgcGFyZW50SUQ6IDAsXG4gICAgICAgICAgICB0cmVlQmFzZUR1cmF0aW9uOiAwLCAvLyBUaGlzIHdpbGwgYmUgdXBkYXRlZCBieSBhIHN1YnNlcXVlbnQgb3BlcmF0aW9uXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY29tcGlsZWRXaXRoRm9yZ2V0OiBmYWxzZSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbm9kZXMuc2V0KGlkLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJRCA9ICgob3BlcmF0aW9uc1tpXTogYW55KTogbnVtYmVyKTtcbiAgICAgICAgICBpKys7XG5cbiAgICAgICAgICBpKys7IC8vIG93bmVySURcblxuICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lU3RyaW5nSUQgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gc3RyaW5nVGFibGVbZGlzcGxheU5hbWVTdHJpbmdJRF07XG4gICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgY29uc3Qga2V5U3RyaW5nSUQgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgIGNvbnN0IGtleSA9IHN0cmluZ1RhYmxlW2tleVN0cmluZ0lEXTtcbiAgICAgICAgICBpKys7XG5cbiAgICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAgICAgJ0FkZCcsXG4gICAgICAgICAgICAgIGBmaWJlciAke2lkfSAoJHtkaXNwbGF5TmFtZSB8fCAnbnVsbCd9KSBhcyBjaGlsZCBvZiAke3BhcmVudElEfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRDbG9uZWROb2RlKHBhcmVudElEKTtcbiAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQoaWQpO1xuXG4gICAgICAgICAgY29uc3Qge2Zvcm1hdHRlZERpc3BsYXlOYW1lLCBob2NEaXNwbGF5TmFtZXMsIGNvbXBpbGVkV2l0aEZvcmdldH0gPVxuICAgICAgICAgICAgcGFyc2VFbGVtZW50RGlzcGxheU5hbWVGcm9tQmFja2VuZChkaXNwbGF5TmFtZSwgdHlwZSk7XG5cbiAgICAgICAgICBjb25zdCBub2RlOiBDb21taXRUcmVlTm9kZSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBmb3JtYXR0ZWREaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIGhvY0Rpc3BsYXlOYW1lczogaG9jRGlzcGxheU5hbWVzLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwYXJlbnRJRCxcbiAgICAgICAgICAgIHRyZWVCYXNlRHVyYXRpb246IDAsIC8vIFRoaXMgd2lsbCBiZSB1cGRhdGVkIGJ5IGEgc3Vic2VxdWVudCBvcGVyYXRpb25cbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjb21waWxlZFdpdGhGb3JnZXQsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG5vZGVzLnNldChpZCwgbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fUkVNT1ZFOiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUxlbmd0aCA9ICgob3BlcmF0aW9uc1tpICsgMV06IGFueSk6IG51bWJlcik7XG4gICAgICAgIGkgKz0gMjtcblxuICAgICAgICBmb3IgKGxldCByZW1vdmVJbmRleCA9IDA7IHJlbW92ZUluZGV4IDwgcmVtb3ZlTGVuZ3RoOyByZW1vdmVJbmRleCsrKSB7XG4gICAgICAgICAgaWQgPSAoKG9wZXJhdGlvbnNbaV06IGFueSk6IG51bWJlcik7XG4gICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgaWYgKCFub2Rlcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBDb21taXQgdHJlZSBkb2VzIG5vdCBjb250YWluIGZpYmVyIFwiJHtpZH1cIi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBEZXZUb29scy5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBub2RlID0gZ2V0Q2xvbmVkTm9kZShpZCk7XG4gICAgICAgICAgY29uc3QgcGFyZW50SUQgPSBub2RlLnBhcmVudElEO1xuXG4gICAgICAgICAgbm9kZXMuZGVsZXRlKGlkKTtcblxuICAgICAgICAgIGlmICghbm9kZXMuaGFzKHBhcmVudElEKSkge1xuICAgICAgICAgICAgLy8gTm8tb3BcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGdldENsb25lZE5vZGUocGFyZW50SUQpO1xuXG4gICAgICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdSZW1vdmUnLCBgZmliZXIgJHtpZH0gZnJvbSBwYXJlbnQgJHtwYXJlbnRJRH1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbiA9IHBhcmVudE5vZGUuY2hpbGRyZW4uZmlsdGVyKFxuICAgICAgICAgICAgICBjaGlsZElEID0+IGNoaWxkSUQgIT09IGlkLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UOiB7XG4gICAgICAgIHRocm93IEVycm9yKCdPcGVyYXRpb24gUkVNT1ZFX1JPT1QgaXMgbm90IHN1cHBvcnRlZCB3aGlsZSBwcm9maWxpbmcuJyk7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU46IHtcbiAgICAgICAgaWQgPSAoKG9wZXJhdGlvbnNbaSArIDFdOiBhbnkpOiBudW1iZXIpO1xuICAgICAgICBjb25zdCBudW1DaGlsZHJlbiA9ICgob3BlcmF0aW9uc1tpICsgMl06IGFueSk6IG51bWJlcik7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gKChvcGVyYXRpb25zLnNsaWNlKFxuICAgICAgICAgIGkgKyAzLFxuICAgICAgICAgIGkgKyAzICsgbnVtQ2hpbGRyZW4sXG4gICAgICAgICk6IGFueSk6IEFycmF5PG51bWJlcj4pO1xuXG4gICAgICAgIGkgPSBpICsgMyArIG51bUNoaWxkcmVuO1xuXG4gICAgICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgICAgICBkZWJ1ZygnUmUtb3JkZXInLCBgZmliZXIgJHtpZH0gY2hpbGRyZW4gJHtjaGlsZHJlbi5qb2luKCcsJyl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlID0gZ2V0Q2xvbmVkTm9kZShpZCk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4gPSBBcnJheS5mcm9tKGNoaWxkcmVuKTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERToge1xuICAgICAgICBpZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICBjb25zdCBtb2RlID0gb3BlcmF0aW9uc1tpICsgMV07XG5cbiAgICAgICAgaSArPSAzO1xuXG4gICAgICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgICAgICBkZWJ1ZygnU3VidHJlZSBtb2RlJywgYFN1YnRyZWUgd2l0aCByb290ICR7aWR9IHNldCB0byBtb2RlICR7bW9kZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTjoge1xuICAgICAgICBpZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuXG4gICAgICAgIGNvbnN0IG5vZGUgPSBnZXRDbG9uZWROb2RlKGlkKTtcbiAgICAgICAgbm9kZS50cmVlQmFzZUR1cmF0aW9uID0gb3BlcmF0aW9uc1tpICsgMl0gLyAxMDAwOyAvLyBDb252ZXJ0IG1pY3Jvc2Vjb25kcyBiYWNrIHRvIG1pbGxpc2Vjb25kcztcblxuICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgZGVidWcoXG4gICAgICAgICAgICAnVXBkYXRlJyxcbiAgICAgICAgICAgIGBmaWJlciAke2lkfSB0cmVlQmFzZUR1cmF0aW9uIHRvICR7bm9kZS50cmVlQmFzZUR1cmF0aW9ufWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1M6IHtcbiAgICAgICAgaWQgPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgY29uc3QgbnVtRXJyb3JzID0gb3BlcmF0aW9uc1tpICsgMl07XG4gICAgICAgIGNvbnN0IG51bVdhcm5pbmdzID0gb3BlcmF0aW9uc1tpICsgM107XG5cbiAgICAgICAgaSArPSA0O1xuXG4gICAgICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAgICdXYXJuaW5ncyBhbmQgRXJyb3JzIHVwZGF0ZScsXG4gICAgICAgICAgICBgZmliZXIgJHtpZH0gaGFzICR7bnVtRXJyb3JzfSBlcnJvcnMgYW5kICR7bnVtV2FybmluZ3N9IHdhcm5pbmdzYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgQnJpZGdlIG9wZXJhdGlvbiBcIiR7b3BlcmF0aW9ufVwiYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlcyxcbiAgICByb290SUQ6IGNvbW1pdFRyZWUucm9vdElELFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZUNvbW1pdFRyZWVzKCk6IHZvaWQge1xuICByb290VG9Db21taXRUcmVlTWFwLmNsZWFyKCk7XG59XG5cbi8vIERFQlVHXG5jb25zdCBfX3ByaW50VHJlZSA9IChjb21taXRUcmVlOiBDb21taXRUcmVlKSA9PiB7XG4gIGlmIChfX0RFQlVHX18pIHtcbiAgICBjb25zdCB7bm9kZXMsIHJvb3RJRH0gPSBjb21taXRUcmVlO1xuICAgIGNvbnNvbGUuZ3JvdXAoJ19fcHJpbnRUcmVlKCknKTtcbiAgICBjb25zdCBxdWV1ZSA9IFtyb290SUQsIDBdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBpZCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICBjb25zdCBkZXB0aCA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICAgICBjb25zdCBub2RlID0gbm9kZXMuZ2V0KGlkKTtcbiAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cbiAgICAgICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgaW4gY29tbWl0IHRyZWVgKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICAgICAgIGAkeyfigKInLnJlcGVhdChkZXB0aCl9JHtub2RlLmlkfToke25vZGUuZGlzcGxheU5hbWUgfHwgJyd9ICR7XG4gICAgICAgICAgbm9kZS5rZXkgPyBga2V5OlwiJHtub2RlLmtleX1cImAgOiAnJ1xuICAgICAgICB9ICgke25vZGUudHJlZUJhc2VEdXJhdGlvbn0pYCxcbiAgICAgICk7XG5cbiAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZElEID0+IHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dXG4gICAgICAgIHF1ZXVlLnB1c2goY2hpbGRJRCwgZGVwdGggKyAxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/views/Profiler/CommitTreeBuilder.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/views/Profiler/FlamegraphChartBuilder.js":
/*!**************************************************************************************!*\
  !*** ../react-devtools-shared/src/devtools/views/Profiler/FlamegraphChartBuilder.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getChartData\": () => (/* binding */ getChartData),\n/* harmony export */   \"invalidateChartData\": () => (/* binding */ invalidateChartData)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"../react-devtools-shared/src/devtools/views/Profiler/utils.js\");\n/* harmony import */ var react_devtools_shared_src_devtools_ProfilerStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/devtools/ProfilerStore */ \"../react-devtools-shared/src/devtools/ProfilerStore.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nconst cachedChartData = new Map();\nfunction getChartData({\n  commitIndex,\n  commitTree,\n  profilerStore,\n  rootID\n}) {\n  const commitDatum = profilerStore.getCommitData(rootID, commitIndex);\n  const {\n    fiberActualDurations,\n    fiberSelfDurations\n  } = commitDatum;\n  const {\n    nodes\n  } = commitTree;\n  const chartDataKey = `${rootID}-${commitIndex}`;\n\n  if (cachedChartData.has(chartDataKey)) {\n    return cachedChartData.get(chartDataKey);\n  }\n\n  const idToDepthMap = new Map();\n  const renderPathNodes = new Set();\n  const rows = [];\n  let maxDepth = 0;\n  let maxSelfDuration = 0; // Generate flame graph structure using tree base durations.\n\n  const walkTree = (id, rightOffset, currentDepth) => {\n    idToDepthMap.set(id, currentDepth);\n    const node = nodes.get(id);\n\n    if (node == null) {\n      throw Error(`Could not find node with id \"${id}\" in commit tree`);\n    }\n\n    const {\n      children,\n      displayName,\n      hocDisplayNames,\n      key,\n      treeBaseDuration,\n      compiledWithForget\n    } = node;\n    const actualDuration = fiberActualDurations.get(id) || 0;\n    const selfDuration = fiberSelfDurations.get(id) || 0;\n    const didRender = fiberActualDurations.has(id);\n    const name = displayName || 'Anonymous';\n    const maybeKey = key !== null ? ` key=\"${key}\"` : '';\n    let maybeBadge = '';\n    const maybeForgetBadge = compiledWithForget ? ' ' : '';\n\n    if (hocDisplayNames !== null && hocDisplayNames.length > 0) {\n      maybeBadge = ` (${hocDisplayNames[0]})`;\n    }\n\n    let label = `${maybeForgetBadge}${name}${maybeBadge}${maybeKey}`;\n\n    if (didRender) {\n      label += ` (${(0,_utils__WEBPACK_IMPORTED_MODULE_0__.formatDuration)(selfDuration)}ms of ${(0,_utils__WEBPACK_IMPORTED_MODULE_0__.formatDuration)(actualDuration)}ms)`;\n    }\n\n    maxDepth = Math.max(maxDepth, currentDepth);\n    maxSelfDuration = Math.max(maxSelfDuration, selfDuration);\n    const chartNode = {\n      actualDuration,\n      didRender,\n      id,\n      label,\n      name,\n      offset: rightOffset - treeBaseDuration,\n      selfDuration,\n      treeBaseDuration\n    };\n\n    if (currentDepth > rows.length) {\n      rows.push([chartNode]);\n    } else {\n      rows[currentDepth - 1].push(chartNode);\n    }\n\n    for (let i = children.length - 1; i >= 0; i--) {\n      const childID = children[i];\n      const childChartNode = walkTree(childID, rightOffset, currentDepth + 1);\n      rightOffset -= childChartNode.treeBaseDuration;\n    }\n\n    return chartNode;\n  };\n\n  let baseDuration = 0; // Special case to handle unmounted roots.\n\n  if (nodes.size > 0) {\n    // Skip over the root; we don't want to show it in the flamegraph.\n    const root = nodes.get(rootID);\n\n    if (root == null) {\n      throw Error(`Could not find root node with id \"${rootID}\" in commit tree`);\n    } // Don't assume a single root.\n    // Component filters or Fragments might lead to multiple \"roots\" in a flame graph.\n\n\n    for (let i = root.children.length - 1; i >= 0; i--) {\n      const id = root.children[i];\n      const node = nodes.get(id);\n\n      if (node == null) {\n        throw Error(`Could not find node with id \"${id}\" in commit tree`);\n      }\n\n      baseDuration += node.treeBaseDuration;\n      walkTree(id, baseDuration, 1);\n    }\n\n    fiberActualDurations.forEach((duration, id) => {\n      let node = nodes.get(id);\n\n      if (node != null) {\n        let currentID = node.parentID;\n\n        while (currentID !== 0) {\n          if (renderPathNodes.has(currentID)) {\n            // We've already walked this path; we can skip it.\n            break;\n          } else {\n            renderPathNodes.add(currentID);\n          }\n\n          node = nodes.get(currentID);\n          currentID = node != null ? node.parentID : 0;\n        }\n      }\n    });\n  }\n\n  const chartData = {\n    baseDuration,\n    depth: maxDepth,\n    idToDepthMap,\n    maxSelfDuration,\n    renderPathNodes,\n    rows\n  };\n  cachedChartData.set(chartDataKey, chartData);\n  return chartData;\n}\nfunction invalidateChartData() {\n  cachedChartData.clear();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy92aWV3cy9Qcm9maWxlci9GbGFtZWdyYXBoQ2hhcnRCdWlsZGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBd0JBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBV0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBS0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBOztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL3ZpZXdzL1Byb2ZpbGVyL0ZsYW1lZ3JhcGhDaGFydEJ1aWxkZXIuanM/NjY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge2Zvcm1hdER1cmF0aW9ufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBQcm9maWxlclN0b3JlIGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZGV2dG9vbHMvUHJvZmlsZXJTdG9yZSc7XG5cbmltcG9ydCB0eXBlIHtDb21taXRUcmVlfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgQ2hhcnROb2RlID0ge1xuICBhY3R1YWxEdXJhdGlvbjogbnVtYmVyLFxuICBkaWRSZW5kZXI6IGJvb2xlYW4sXG4gIGlkOiBudW1iZXIsXG4gIGxhYmVsOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNlbGZEdXJhdGlvbjogbnVtYmVyLFxuICB0cmVlQmFzZUR1cmF0aW9uOiBudW1iZXIsXG59O1xuXG5leHBvcnQgdHlwZSBDaGFydERhdGEgPSB7XG4gIGJhc2VEdXJhdGlvbjogbnVtYmVyLFxuICBkZXB0aDogbnVtYmVyLFxuICBpZFRvRGVwdGhNYXA6IE1hcDxudW1iZXIsIG51bWJlcj4sXG4gIG1heFNlbGZEdXJhdGlvbjogbnVtYmVyLFxuICByZW5kZXJQYXRoTm9kZXM6IFNldDxudW1iZXI+LFxuICByb3dzOiBBcnJheTxBcnJheTxDaGFydE5vZGU+Pixcbn07XG5cbmNvbnN0IGNhY2hlZENoYXJ0RGF0YTogTWFwPHN0cmluZywgQ2hhcnREYXRhPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYXJ0RGF0YSh7XG4gIGNvbW1pdEluZGV4LFxuICBjb21taXRUcmVlLFxuICBwcm9maWxlclN0b3JlLFxuICByb290SUQsXG59OiB7XG4gIGNvbW1pdEluZGV4OiBudW1iZXIsXG4gIGNvbW1pdFRyZWU6IENvbW1pdFRyZWUsXG4gIHByb2ZpbGVyU3RvcmU6IFByb2ZpbGVyU3RvcmUsXG4gIHJvb3RJRDogbnVtYmVyLFxufSk6IENoYXJ0RGF0YSB7XG4gIGNvbnN0IGNvbW1pdERhdHVtID0gcHJvZmlsZXJTdG9yZS5nZXRDb21taXREYXRhKHJvb3RJRCwgY29tbWl0SW5kZXgpO1xuXG4gIGNvbnN0IHtmaWJlckFjdHVhbER1cmF0aW9ucywgZmliZXJTZWxmRHVyYXRpb25zfSA9IGNvbW1pdERhdHVtO1xuICBjb25zdCB7bm9kZXN9ID0gY29tbWl0VHJlZTtcblxuICBjb25zdCBjaGFydERhdGFLZXkgPSBgJHtyb290SUR9LSR7Y29tbWl0SW5kZXh9YDtcbiAgaWYgKGNhY2hlZENoYXJ0RGF0YS5oYXMoY2hhcnREYXRhS2V5KSkge1xuICAgIHJldHVybiAoKGNhY2hlZENoYXJ0RGF0YS5nZXQoY2hhcnREYXRhS2V5KTogYW55KTogQ2hhcnREYXRhKTtcbiAgfVxuXG4gIGNvbnN0IGlkVG9EZXB0aE1hcDogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgY29uc3QgcmVuZGVyUGF0aE5vZGVzOiBTZXQ8bnVtYmVyPiA9IG5ldyBTZXQoKTtcbiAgY29uc3Qgcm93czogQXJyYXk8QXJyYXk8Q2hhcnROb2RlPj4gPSBbXTtcblxuICBsZXQgbWF4RGVwdGggPSAwO1xuICBsZXQgbWF4U2VsZkR1cmF0aW9uID0gMDtcblxuICAvLyBHZW5lcmF0ZSBmbGFtZSBncmFwaCBzdHJ1Y3R1cmUgdXNpbmcgdHJlZSBiYXNlIGR1cmF0aW9ucy5cbiAgY29uc3Qgd2Fsa1RyZWUgPSAoXG4gICAgaWQ6IG51bWJlcixcbiAgICByaWdodE9mZnNldDogbnVtYmVyLFxuICAgIGN1cnJlbnREZXB0aDogbnVtYmVyLFxuICApOiBDaGFydE5vZGUgPT4ge1xuICAgIGlkVG9EZXB0aE1hcC5zZXQoaWQsIGN1cnJlbnREZXB0aCk7XG5cbiAgICBjb25zdCBub2RlID0gbm9kZXMuZ2V0KGlkKTtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGZpbmQgbm9kZSB3aXRoIGlkIFwiJHtpZH1cIiBpbiBjb21taXQgdHJlZWApO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICBob2NEaXNwbGF5TmFtZXMsXG4gICAgICBrZXksXG4gICAgICB0cmVlQmFzZUR1cmF0aW9uLFxuICAgICAgY29tcGlsZWRXaXRoRm9yZ2V0LFxuICAgIH0gPSBub2RlO1xuXG4gICAgY29uc3QgYWN0dWFsRHVyYXRpb24gPSBmaWJlckFjdHVhbER1cmF0aW9ucy5nZXQoaWQpIHx8IDA7XG4gICAgY29uc3Qgc2VsZkR1cmF0aW9uID0gZmliZXJTZWxmRHVyYXRpb25zLmdldChpZCkgfHwgMDtcbiAgICBjb25zdCBkaWRSZW5kZXIgPSBmaWJlckFjdHVhbER1cmF0aW9ucy5oYXMoaWQpO1xuXG4gICAgY29uc3QgbmFtZSA9IGRpc3BsYXlOYW1lIHx8ICdBbm9ueW1vdXMnO1xuICAgIGNvbnN0IG1heWJlS2V5ID0ga2V5ICE9PSBudWxsID8gYCBrZXk9XCIke2tleX1cImAgOiAnJztcblxuICAgIGxldCBtYXliZUJhZGdlID0gJyc7XG4gICAgY29uc3QgbWF5YmVGb3JnZXRCYWRnZSA9IGNvbXBpbGVkV2l0aEZvcmdldCA/ICfinKggJyA6ICcnO1xuXG4gICAgaWYgKGhvY0Rpc3BsYXlOYW1lcyAhPT0gbnVsbCAmJiBob2NEaXNwbGF5TmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWF5YmVCYWRnZSA9IGAgKCR7aG9jRGlzcGxheU5hbWVzWzBdfSlgO1xuICAgIH1cblxuICAgIGxldCBsYWJlbCA9IGAke21heWJlRm9yZ2V0QmFkZ2V9JHtuYW1lfSR7bWF5YmVCYWRnZX0ke21heWJlS2V5fWA7XG4gICAgaWYgKGRpZFJlbmRlcikge1xuICAgICAgbGFiZWwgKz0gYCAoJHtmb3JtYXREdXJhdGlvbihzZWxmRHVyYXRpb24pfW1zIG9mICR7Zm9ybWF0RHVyYXRpb24oXG4gICAgICAgIGFjdHVhbER1cmF0aW9uLFxuICAgICAgKX1tcylgO1xuICAgIH1cblxuICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGN1cnJlbnREZXB0aCk7XG4gICAgbWF4U2VsZkR1cmF0aW9uID0gTWF0aC5tYXgobWF4U2VsZkR1cmF0aW9uLCBzZWxmRHVyYXRpb24pO1xuXG4gICAgY29uc3QgY2hhcnROb2RlOiBDaGFydE5vZGUgPSB7XG4gICAgICBhY3R1YWxEdXJhdGlvbixcbiAgICAgIGRpZFJlbmRlcixcbiAgICAgIGlkLFxuICAgICAgbGFiZWwsXG4gICAgICBuYW1lLFxuICAgICAgb2Zmc2V0OiByaWdodE9mZnNldCAtIHRyZWVCYXNlRHVyYXRpb24sXG4gICAgICBzZWxmRHVyYXRpb24sXG4gICAgICB0cmVlQmFzZUR1cmF0aW9uLFxuICAgIH07XG5cbiAgICBpZiAoY3VycmVudERlcHRoID4gcm93cy5sZW5ndGgpIHtcbiAgICAgIHJvd3MucHVzaChbY2hhcnROb2RlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvd3NbY3VycmVudERlcHRoIC0gMV0ucHVzaChjaGFydE5vZGUpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY2hpbGRJRCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY2hpbGRDaGFydE5vZGU6ICRGbG93Rml4TWUgPSB3YWxrVHJlZShcbiAgICAgICAgY2hpbGRJRCxcbiAgICAgICAgcmlnaHRPZmZzZXQsXG4gICAgICAgIGN1cnJlbnREZXB0aCArIDEsXG4gICAgICApO1xuICAgICAgcmlnaHRPZmZzZXQgLT0gY2hpbGRDaGFydE5vZGUudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnROb2RlO1xuICB9O1xuXG4gIGxldCBiYXNlRHVyYXRpb24gPSAwO1xuXG4gIC8vIFNwZWNpYWwgY2FzZSB0byBoYW5kbGUgdW5tb3VudGVkIHJvb3RzLlxuICBpZiAobm9kZXMuc2l6ZSA+IDApIHtcbiAgICAvLyBTa2lwIG92ZXIgdGhlIHJvb3Q7IHdlIGRvbid0IHdhbnQgdG8gc2hvdyBpdCBpbiB0aGUgZmxhbWVncmFwaC5cbiAgICBjb25zdCByb290ID0gbm9kZXMuZ2V0KHJvb3RJRCk7XG4gICAgaWYgKHJvb3QgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3QgZmluZCByb290IG5vZGUgd2l0aCBpZCBcIiR7cm9vdElEfVwiIGluIGNvbW1pdCB0cmVlYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgYXNzdW1lIGEgc2luZ2xlIHJvb3QuXG4gICAgLy8gQ29tcG9uZW50IGZpbHRlcnMgb3IgRnJhZ21lbnRzIG1pZ2h0IGxlYWQgdG8gbXVsdGlwbGUgXCJyb290c1wiIGluIGEgZmxhbWUgZ3JhcGguXG4gICAgZm9yIChsZXQgaSA9IHJvb3QuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGlkID0gcm9vdC5jaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5nZXQoaWQpO1xuICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGZpbmQgbm9kZSB3aXRoIGlkIFwiJHtpZH1cIiBpbiBjb21taXQgdHJlZWApO1xuICAgICAgfVxuICAgICAgYmFzZUR1cmF0aW9uICs9IG5vZGUudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIHdhbGtUcmVlKGlkLCBiYXNlRHVyYXRpb24sIDEpO1xuICAgIH1cblxuICAgIGZpYmVyQWN0dWFsRHVyYXRpb25zLmZvckVhY2goKGR1cmF0aW9uLCBpZCkgPT4ge1xuICAgICAgbGV0IG5vZGUgPSBub2Rlcy5nZXQoaWQpO1xuICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICBsZXQgY3VycmVudElEID0gbm9kZS5wYXJlbnRJRDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRJRCAhPT0gMCkge1xuICAgICAgICAgIGlmIChyZW5kZXJQYXRoTm9kZXMuaGFzKGN1cnJlbnRJRCkpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgd2Fsa2VkIHRoaXMgcGF0aDsgd2UgY2FuIHNraXAgaXQuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyUGF0aE5vZGVzLmFkZChjdXJyZW50SUQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUgPSBub2Rlcy5nZXQoY3VycmVudElEKTtcbiAgICAgICAgICBjdXJyZW50SUQgPSBub2RlICE9IG51bGwgPyBub2RlLnBhcmVudElEIDogMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgY2hhcnREYXRhID0ge1xuICAgIGJhc2VEdXJhdGlvbixcbiAgICBkZXB0aDogbWF4RGVwdGgsXG4gICAgaWRUb0RlcHRoTWFwLFxuICAgIG1heFNlbGZEdXJhdGlvbixcbiAgICByZW5kZXJQYXRoTm9kZXMsXG4gICAgcm93cyxcbiAgfTtcblxuICBjYWNoZWRDaGFydERhdGEuc2V0KGNoYXJ0RGF0YUtleSwgY2hhcnREYXRhKTtcblxuICByZXR1cm4gY2hhcnREYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZUNoYXJ0RGF0YSgpOiB2b2lkIHtcbiAgY2FjaGVkQ2hhcnREYXRhLmNsZWFyKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/views/Profiler/FlamegraphChartBuilder.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/views/Profiler/RankedChartBuilder.js":
/*!**********************************************************************************!*\
  !*** ../react-devtools-shared/src/devtools/views/Profiler/RankedChartBuilder.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getChartData\": () => (/* binding */ getChartData),\n/* harmony export */   \"invalidateChartData\": () => (/* binding */ invalidateChartData)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/frontend/types */ \"../react-devtools-shared/src/frontend/types.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"../react-devtools-shared/src/devtools/views/Profiler/utils.js\");\n/* harmony import */ var react_devtools_shared_src_devtools_ProfilerStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-devtools-shared/src/devtools/ProfilerStore */ \"../react-devtools-shared/src/devtools/ProfilerStore.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\nconst cachedChartData = new Map();\nfunction getChartData({\n  commitIndex,\n  commitTree,\n  profilerStore,\n  rootID\n}) {\n  const commitDatum = profilerStore.getCommitData(rootID, commitIndex);\n  const {\n    fiberActualDurations,\n    fiberSelfDurations\n  } = commitDatum;\n  const {\n    nodes\n  } = commitTree;\n  const chartDataKey = `${rootID}-${commitIndex}`;\n\n  if (cachedChartData.has(chartDataKey)) {\n    return cachedChartData.get(chartDataKey);\n  }\n\n  let maxSelfDuration = 0;\n  const chartNodes = [];\n  fiberActualDurations.forEach((actualDuration, id) => {\n    const node = nodes.get(id);\n\n    if (node == null) {\n      throw Error(`Could not find node with id \"${id}\" in commit tree`);\n    }\n\n    const {\n      displayName,\n      key,\n      parentID,\n      type,\n      compiledWithForget\n    } = node; // Don't show the root node in this chart.\n\n    if (parentID === 0) {\n      return;\n    }\n\n    const selfDuration = fiberSelfDurations.get(id) || 0;\n    maxSelfDuration = Math.max(maxSelfDuration, selfDuration);\n    const name = displayName || 'Anonymous';\n    const maybeKey = key !== null ? ` key=\"${key}\"` : '';\n    const maybeForgetBadge = compiledWithForget ? ' ' : '';\n    let maybeBadge = '';\n\n    if (type === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeForwardRef) {\n      maybeBadge = ' (ForwardRef)';\n    } else if (type === react_devtools_shared_src_frontend_types__WEBPACK_IMPORTED_MODULE_0__.ElementTypeMemo) {\n      maybeBadge = ' (Memo)';\n    }\n\n    const label = `${maybeForgetBadge}${name}${maybeBadge}${maybeKey} (${(0,_utils__WEBPACK_IMPORTED_MODULE_1__.formatDuration)(selfDuration)}ms)`;\n    chartNodes.push({\n      id,\n      label,\n      name,\n      value: selfDuration\n    });\n  });\n  const chartData = {\n    maxValue: maxSelfDuration,\n    nodes: chartNodes.sort((a, b) => b.value - a.value)\n  };\n  cachedChartData.set(chartDataKey, chartData);\n  return chartData;\n}\nfunction invalidateChartData() {\n  cachedChartData.clear();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy92aWV3cy9Qcm9maWxlci9SYW5rZWRDaGFydEJ1aWxkZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUlBO0FBQ0E7QUFnQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFXQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL3ZpZXdzL1Byb2ZpbGVyL1JhbmtlZENoYXJ0QnVpbGRlci5qcz9kNmVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7XG4gIEVsZW1lbnRUeXBlRm9yd2FyZFJlZixcbiAgRWxlbWVudFR5cGVNZW1vLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2Zyb250ZW5kL3R5cGVzJztcbmltcG9ydCB7Zm9ybWF0RHVyYXRpb259IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IFByb2ZpbGVyU3RvcmUgZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy9Qcm9maWxlclN0b3JlJztcblxuaW1wb3J0IHR5cGUge0NvbW1pdFRyZWV9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgdHlwZSBDaGFydE5vZGUgPSB7XG4gIGlkOiBudW1iZXIsXG4gIGxhYmVsOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbn07XG5cbmV4cG9ydCB0eXBlIENoYXJ0RGF0YSA9IHtcbiAgbWF4VmFsdWU6IG51bWJlcixcbiAgbm9kZXM6IEFycmF5PENoYXJ0Tm9kZT4sXG59O1xuXG5jb25zdCBjYWNoZWRDaGFydERhdGE6IE1hcDxzdHJpbmcsIENoYXJ0RGF0YT4gPSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFydERhdGEoe1xuICBjb21taXRJbmRleCxcbiAgY29tbWl0VHJlZSxcbiAgcHJvZmlsZXJTdG9yZSxcbiAgcm9vdElELFxufToge1xuICBjb21taXRJbmRleDogbnVtYmVyLFxuICBjb21taXRUcmVlOiBDb21taXRUcmVlLFxuICBwcm9maWxlclN0b3JlOiBQcm9maWxlclN0b3JlLFxuICByb290SUQ6IG51bWJlcixcbn0pOiBDaGFydERhdGEge1xuICBjb25zdCBjb21taXREYXR1bSA9IHByb2ZpbGVyU3RvcmUuZ2V0Q29tbWl0RGF0YShyb290SUQsIGNvbW1pdEluZGV4KTtcblxuICBjb25zdCB7ZmliZXJBY3R1YWxEdXJhdGlvbnMsIGZpYmVyU2VsZkR1cmF0aW9uc30gPSBjb21taXREYXR1bTtcbiAgY29uc3Qge25vZGVzfSA9IGNvbW1pdFRyZWU7XG5cbiAgY29uc3QgY2hhcnREYXRhS2V5ID0gYCR7cm9vdElEfS0ke2NvbW1pdEluZGV4fWA7XG4gIGlmIChjYWNoZWRDaGFydERhdGEuaGFzKGNoYXJ0RGF0YUtleSkpIHtcbiAgICByZXR1cm4gKChjYWNoZWRDaGFydERhdGEuZ2V0KGNoYXJ0RGF0YUtleSk6IGFueSk6IENoYXJ0RGF0YSk7XG4gIH1cblxuICBsZXQgbWF4U2VsZkR1cmF0aW9uID0gMDtcblxuICBjb25zdCBjaGFydE5vZGVzOiBBcnJheTxDaGFydE5vZGU+ID0gW107XG4gIGZpYmVyQWN0dWFsRHVyYXRpb25zLmZvckVhY2goKGFjdHVhbER1cmF0aW9uLCBpZCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5nZXQoaWQpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCBmaW5kIG5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgaW4gY29tbWl0IHRyZWVgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7ZGlzcGxheU5hbWUsIGtleSwgcGFyZW50SUQsIHR5cGUsIGNvbXBpbGVkV2l0aEZvcmdldH0gPSBub2RlO1xuXG4gICAgLy8gRG9uJ3Qgc2hvdyB0aGUgcm9vdCBub2RlIGluIHRoaXMgY2hhcnQuXG4gICAgaWYgKHBhcmVudElEID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGZEdXJhdGlvbiA9IGZpYmVyU2VsZkR1cmF0aW9ucy5nZXQoaWQpIHx8IDA7XG4gICAgbWF4U2VsZkR1cmF0aW9uID0gTWF0aC5tYXgobWF4U2VsZkR1cmF0aW9uLCBzZWxmRHVyYXRpb24pO1xuXG4gICAgY29uc3QgbmFtZSA9IGRpc3BsYXlOYW1lIHx8ICdBbm9ueW1vdXMnO1xuICAgIGNvbnN0IG1heWJlS2V5ID0ga2V5ICE9PSBudWxsID8gYCBrZXk9XCIke2tleX1cImAgOiAnJztcbiAgICBjb25zdCBtYXliZUZvcmdldEJhZGdlID0gY29tcGlsZWRXaXRoRm9yZ2V0ID8gJ+KcqCAnIDogJyc7XG5cbiAgICBsZXQgbWF5YmVCYWRnZSA9ICcnO1xuICAgIGlmICh0eXBlID09PSBFbGVtZW50VHlwZUZvcndhcmRSZWYpIHtcbiAgICAgIG1heWJlQmFkZ2UgPSAnIChGb3J3YXJkUmVmKSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBFbGVtZW50VHlwZU1lbW8pIHtcbiAgICAgIG1heWJlQmFkZ2UgPSAnIChNZW1vKSc7XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWwgPSBgJHttYXliZUZvcmdldEJhZGdlfSR7bmFtZX0ke21heWJlQmFkZ2V9JHttYXliZUtleX0gKCR7Zm9ybWF0RHVyYXRpb24oXG4gICAgICBzZWxmRHVyYXRpb24sXG4gICAgKX1tcylgO1xuICAgIGNoYXJ0Tm9kZXMucHVzaCh7XG4gICAgICBpZCxcbiAgICAgIGxhYmVsLFxuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlOiBzZWxmRHVyYXRpb24sXG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IGNoYXJ0RGF0YSA9IHtcbiAgICBtYXhWYWx1ZTogbWF4U2VsZkR1cmF0aW9uLFxuICAgIG5vZGVzOiBjaGFydE5vZGVzLnNvcnQoKGEsIGIpID0+IGIudmFsdWUgLSBhLnZhbHVlKSxcbiAgfTtcblxuICBjYWNoZWRDaGFydERhdGEuc2V0KGNoYXJ0RGF0YUtleSwgY2hhcnREYXRhKTtcblxuICByZXR1cm4gY2hhcnREYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZUNoYXJ0RGF0YSgpOiB2b2lkIHtcbiAgY2FjaGVkQ2hhcnREYXRhLmNsZWFyKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/views/Profiler/RankedChartBuilder.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/devtools/views/Profiler/utils.js":
/*!*********************************************************************!*\
  !*** ../react-devtools-shared/src/devtools/views/Profiler/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"formatDuration\": () => (/* binding */ formatDuration),\n/* harmony export */   \"formatPercentage\": () => (/* binding */ formatPercentage),\n/* harmony export */   \"formatTime\": () => (/* binding */ formatTime),\n/* harmony export */   \"getGradientColor\": () => (/* binding */ getGradientColor),\n/* harmony export */   \"prepareProfilingDataExport\": () => (/* binding */ prepareProfilingDataExport),\n/* harmony export */   \"prepareProfilingDataFrontendFromBackendAndStore\": () => (/* binding */ prepareProfilingDataFrontendFromBackendAndStore),\n/* harmony export */   \"prepareProfilingDataFrontendFromExport\": () => (/* binding */ prepareProfilingDataFrontendFromExport),\n/* harmony export */   \"scale\": () => (/* binding */ scale)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nconst commitGradient = ['var(--color-commit-gradient-0)', 'var(--color-commit-gradient-1)', 'var(--color-commit-gradient-2)', 'var(--color-commit-gradient-3)', 'var(--color-commit-gradient-4)', 'var(--color-commit-gradient-5)', 'var(--color-commit-gradient-6)', 'var(--color-commit-gradient-7)', 'var(--color-commit-gradient-8)', 'var(--color-commit-gradient-9)']; // Combines info from the Store (frontend) and renderer interfaces (backend) into the format required by the Profiler UI.\n// This format can then be quickly exported (and re-imported).\n\nfunction prepareProfilingDataFrontendFromBackendAndStore(dataBackends, operationsByRootID, snapshotsByRootID) {\n  const dataForRoots = new Map();\n  const timelineDataArray = [];\n  dataBackends.forEach(dataBackend => {\n    const {\n      timelineData\n    } = dataBackend;\n\n    if (timelineData != null) {\n      const {\n        batchUIDToMeasuresKeyValueArray,\n        internalModuleSourceToRanges,\n        laneToLabelKeyValueArray,\n        laneToReactMeasureKeyValueArray,\n        ...rest\n      } = timelineData;\n      timelineDataArray.push({ ...rest,\n        // Most of the data is safe to parse as-is,\n        // but we need to convert the nested Arrays back to Maps.\n        batchUIDToMeasuresMap: new Map(batchUIDToMeasuresKeyValueArray),\n        internalModuleSourceToRanges: new Map(internalModuleSourceToRanges),\n        laneToLabelMap: new Map(laneToLabelKeyValueArray),\n        laneToReactMeasureMap: new Map(laneToReactMeasureKeyValueArray)\n      });\n    }\n\n    dataBackend.dataForRoots.forEach(({\n      commitData,\n      displayName,\n      initialTreeBaseDurations,\n      rootID\n    }) => {\n      const operations = operationsByRootID.get(rootID);\n\n      if (operations == null) {\n        throw Error(`Could not find profiling operations for root \"${rootID}\"`);\n      }\n\n      const snapshots = snapshotsByRootID.get(rootID);\n\n      if (snapshots == null) {\n        throw Error(`Could not find profiling snapshots for root \"${rootID}\"`);\n      } // Do not filter empty commits from the profiler data!\n      // Hiding \"empty\" commits might cause confusion too.\n      // A commit *did happen* even if none of the components the Profiler is showing were involved.\n\n\n      const convertedCommitData = commitData.map((commitDataBackend, commitIndex) => ({\n        changeDescriptions: commitDataBackend.changeDescriptions != null ? new Map(commitDataBackend.changeDescriptions) : null,\n        duration: commitDataBackend.duration,\n        effectDuration: commitDataBackend.effectDuration,\n        fiberActualDurations: new Map(commitDataBackend.fiberActualDurations),\n        fiberSelfDurations: new Map(commitDataBackend.fiberSelfDurations),\n        passiveEffectDuration: commitDataBackend.passiveEffectDuration,\n        priorityLevel: commitDataBackend.priorityLevel,\n        timestamp: commitDataBackend.timestamp,\n        updaters: commitDataBackend.updaters !== null ? commitDataBackend.updaters.map(react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_1__.backendToFrontendSerializedElementMapper) : null\n      }));\n      dataForRoots.set(rootID, {\n        commitData: convertedCommitData,\n        displayName,\n        initialTreeBaseDurations: new Map(initialTreeBaseDurations),\n        operations,\n        rootID,\n        snapshots\n      });\n    });\n  });\n  return {\n    dataForRoots,\n    imported: false,\n    timelineData: timelineDataArray\n  };\n} // Converts a Profiling data export into the format required by the Store.\n\nfunction prepareProfilingDataFrontendFromExport(profilingDataExport) {\n  const {\n    version\n  } = profilingDataExport;\n\n  if (version !== react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.PROFILER_EXPORT_VERSION) {\n    throw Error(`Unsupported profile export version \"${version}\". Supported version is \"${react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.PROFILER_EXPORT_VERSION}\".`);\n  }\n\n  const timelineData = profilingDataExport.timelineData ? profilingDataExport.timelineData.map(({\n    batchUIDToMeasuresKeyValueArray,\n    componentMeasures,\n    duration,\n    flamechart,\n    internalModuleSourceToRanges,\n    laneToLabelKeyValueArray,\n    laneToReactMeasureKeyValueArray,\n    nativeEvents,\n    networkMeasures,\n    otherUserTimingMarks,\n    reactVersion,\n    schedulingEvents,\n    snapshots,\n    snapshotHeight,\n    startTime,\n    suspenseEvents,\n    thrownErrors\n  }) => ({\n    // Most of the data is safe to parse as-is,\n    // but we need to convert the nested Arrays back to Maps.\n    batchUIDToMeasuresMap: new Map(batchUIDToMeasuresKeyValueArray),\n    componentMeasures,\n    duration,\n    flamechart,\n    internalModuleSourceToRanges: new Map(internalModuleSourceToRanges),\n    laneToLabelMap: new Map(laneToLabelKeyValueArray),\n    laneToReactMeasureMap: new Map(laneToReactMeasureKeyValueArray),\n    nativeEvents,\n    networkMeasures,\n    otherUserTimingMarks,\n    reactVersion,\n    schedulingEvents,\n    snapshots,\n    snapshotHeight,\n    startTime,\n    suspenseEvents,\n    thrownErrors\n  })) : [];\n  const dataForRoots = new Map();\n  profilingDataExport.dataForRoots.forEach(({\n    commitData,\n    displayName,\n    initialTreeBaseDurations,\n    operations,\n    rootID,\n    snapshots\n  }) => {\n    dataForRoots.set(rootID, {\n      commitData: commitData.map(({\n        changeDescriptions,\n        duration,\n        effectDuration,\n        fiberActualDurations,\n        fiberSelfDurations,\n        passiveEffectDuration,\n        priorityLevel,\n        timestamp,\n        updaters\n      }) => ({\n        changeDescriptions: changeDescriptions != null ? new Map(changeDescriptions) : null,\n        duration,\n        effectDuration,\n        fiberActualDurations: new Map(fiberActualDurations),\n        fiberSelfDurations: new Map(fiberSelfDurations),\n        passiveEffectDuration,\n        priorityLevel,\n        timestamp,\n        updaters\n      })),\n      displayName,\n      initialTreeBaseDurations: new Map(initialTreeBaseDurations),\n      operations,\n      rootID,\n      snapshots: new Map(snapshots)\n    });\n  });\n  return {\n    dataForRoots,\n    imported: true,\n    timelineData\n  };\n} // Converts a Store Profiling data into a format that can be safely (JSON) serialized for export.\n\nfunction prepareProfilingDataExport(profilingDataFrontend) {\n  const timelineData = profilingDataFrontend.timelineData.map(({\n    batchUIDToMeasuresMap,\n    componentMeasures,\n    duration,\n    flamechart,\n    internalModuleSourceToRanges,\n    laneToLabelMap,\n    laneToReactMeasureMap,\n    nativeEvents,\n    networkMeasures,\n    otherUserTimingMarks,\n    reactVersion,\n    schedulingEvents,\n    snapshots,\n    snapshotHeight,\n    startTime,\n    suspenseEvents,\n    thrownErrors\n  }) => ({\n    // Most of the data is safe to serialize as-is,\n    // but we need to convert the Maps to nested Arrays.\n    batchUIDToMeasuresKeyValueArray: Array.from(batchUIDToMeasuresMap.entries()),\n    componentMeasures: componentMeasures,\n    duration,\n    flamechart,\n    internalModuleSourceToRanges: Array.from(internalModuleSourceToRanges.entries()),\n    laneToLabelKeyValueArray: Array.from(laneToLabelMap.entries()),\n    laneToReactMeasureKeyValueArray: Array.from(laneToReactMeasureMap.entries()),\n    nativeEvents,\n    networkMeasures,\n    otherUserTimingMarks,\n    reactVersion,\n    schedulingEvents,\n    snapshots,\n    snapshotHeight,\n    startTime,\n    suspenseEvents,\n    thrownErrors\n  }));\n  const dataForRoots = [];\n  profilingDataFrontend.dataForRoots.forEach(({\n    commitData,\n    displayName,\n    initialTreeBaseDurations,\n    operations,\n    rootID,\n    snapshots\n  }) => {\n    dataForRoots.push({\n      commitData: commitData.map(({\n        changeDescriptions,\n        duration,\n        effectDuration,\n        fiberActualDurations,\n        fiberSelfDurations,\n        passiveEffectDuration,\n        priorityLevel,\n        timestamp,\n        updaters\n      }) => ({\n        changeDescriptions: changeDescriptions != null ? Array.from(changeDescriptions.entries()) : null,\n        duration,\n        effectDuration,\n        fiberActualDurations: Array.from(fiberActualDurations.entries()),\n        fiberSelfDurations: Array.from(fiberSelfDurations.entries()),\n        passiveEffectDuration,\n        priorityLevel,\n        timestamp,\n        updaters\n      })),\n      displayName,\n      initialTreeBaseDurations: Array.from(initialTreeBaseDurations.entries()),\n      operations,\n      rootID,\n      snapshots: Array.from(snapshots.entries())\n    });\n  });\n  return {\n    version: react_devtools_shared_src_constants__WEBPACK_IMPORTED_MODULE_0__.PROFILER_EXPORT_VERSION,\n    dataForRoots,\n    timelineData\n  };\n}\nconst getGradientColor = value => {\n  const maxIndex = commitGradient.length - 1;\n  let index;\n\n  if (Number.isNaN(value)) {\n    index = 0;\n  } else if (!Number.isFinite(value)) {\n    index = maxIndex;\n  } else {\n    index = Math.max(0, Math.min(maxIndex, value)) * maxIndex;\n  }\n\n  return commitGradient[Math.round(index)];\n};\nconst formatDuration = duration => Math.round(duration * 10) / 10 || '<0.1';\nconst formatPercentage = percentage => Math.round(percentage * 100);\nconst formatTime = timestamp => Math.round(Math.round(timestamp) / 100) / 10;\nconst scale = (minValue, maxValue, minRange, maxRange) => (value, fallbackValue) => maxValue - minValue === 0 ? fallbackValue : (value - minValue) / (maxValue - minValue) * (maxRange - minRange);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9kZXZ0b29scy92aWV3cy9Qcm9maWxlci91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQWVBO0FBY0E7O0FBQ0E7QUFLQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBR0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTs7O0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFHQTtBQUdBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBd0JBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdCQTtBQStCQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpCQTtBQTZCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFqQ0E7QUFtQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL3ZpZXdzL1Byb2ZpbGVyL3V0aWxzLmpzPzA1MDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuaW1wb3J0IHtQUk9GSUxFUl9FWFBPUlRfVkVSU0lPTn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9jb25zdGFudHMnO1xuaW1wb3J0IHtiYWNrZW5kVG9Gcm9udGVuZFNlcmlhbGl6ZWRFbGVtZW50TWFwcGVyfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3V0aWxzJztcblxuaW1wb3J0IHR5cGUge1Byb2ZpbGluZ0RhdGFCYWNrZW5kfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBQcm9maWxpbmdEYXRhRXhwb3J0LFxuICBQcm9maWxpbmdEYXRhRm9yUm9vdEV4cG9ydCxcbiAgUHJvZmlsaW5nRGF0YUZvclJvb3RGcm9udGVuZCxcbiAgUHJvZmlsaW5nRGF0YUZyb250ZW5kLFxuICBTbmFwc2hvdE5vZGUsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBUaW1lbGluZURhdGEsXG4gIFRpbWVsaW5lRGF0YUV4cG9ydCxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtdGltZWxpbmUvc3JjL3R5cGVzJztcblxuY29uc3QgY29tbWl0R3JhZGllbnQgPSBbXG4gICd2YXIoLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMCknLFxuICAndmFyKC0tY29sb3ItY29tbWl0LWdyYWRpZW50LTEpJyxcbiAgJ3ZhcigtLWNvbG9yLWNvbW1pdC1ncmFkaWVudC0yKScsXG4gICd2YXIoLS1jb2xvci1jb21taXQtZ3JhZGllbnQtMyknLFxuICAndmFyKC0tY29sb3ItY29tbWl0LWdyYWRpZW50LTQpJyxcbiAgJ3ZhcigtLWNvbG9yLWNvbW1pdC1ncmFkaWVudC01KScsXG4gICd2YXIoLS1jb2xvci1jb21taXQtZ3JhZGllbnQtNiknLFxuICAndmFyKC0tY29sb3ItY29tbWl0LWdyYWRpZW50LTcpJyxcbiAgJ3ZhcigtLWNvbG9yLWNvbW1pdC1ncmFkaWVudC04KScsXG4gICd2YXIoLS1jb2xvci1jb21taXQtZ3JhZGllbnQtOSknLFxuXTtcblxuLy8gQ29tYmluZXMgaW5mbyBmcm9tIHRoZSBTdG9yZSAoZnJvbnRlbmQpIGFuZCByZW5kZXJlciBpbnRlcmZhY2VzIChiYWNrZW5kKSBpbnRvIHRoZSBmb3JtYXQgcmVxdWlyZWQgYnkgdGhlIFByb2ZpbGVyIFVJLlxuLy8gVGhpcyBmb3JtYXQgY2FuIHRoZW4gYmUgcXVpY2tseSBleHBvcnRlZCAoYW5kIHJlLWltcG9ydGVkKS5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUHJvZmlsaW5nRGF0YUZyb250ZW5kRnJvbUJhY2tlbmRBbmRTdG9yZShcbiAgZGF0YUJhY2tlbmRzOiBBcnJheTxQcm9maWxpbmdEYXRhQmFja2VuZD4sXG4gIG9wZXJhdGlvbnNCeVJvb3RJRDogTWFwPG51bWJlciwgQXJyYXk8QXJyYXk8bnVtYmVyPj4+LFxuICBzbmFwc2hvdHNCeVJvb3RJRDogTWFwPG51bWJlciwgTWFwPG51bWJlciwgU25hcHNob3ROb2RlPj4sXG4pOiBQcm9maWxpbmdEYXRhRnJvbnRlbmQge1xuICBjb25zdCBkYXRhRm9yUm9vdHM6IE1hcDxudW1iZXIsIFByb2ZpbGluZ0RhdGFGb3JSb290RnJvbnRlbmQ+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0IHRpbWVsaW5lRGF0YUFycmF5ID0gW107XG5cbiAgZGF0YUJhY2tlbmRzLmZvckVhY2goZGF0YUJhY2tlbmQgPT4ge1xuICAgIGNvbnN0IHt0aW1lbGluZURhdGF9ID0gZGF0YUJhY2tlbmQ7XG4gICAgaWYgKHRpbWVsaW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJhdGNoVUlEVG9NZWFzdXJlc0tleVZhbHVlQXJyYXksXG4gICAgICAgIGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMsXG4gICAgICAgIGxhbmVUb0xhYmVsS2V5VmFsdWVBcnJheSxcbiAgICAgICAgbGFuZVRvUmVhY3RNZWFzdXJlS2V5VmFsdWVBcnJheSxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSA9IHRpbWVsaW5lRGF0YTtcblxuICAgICAgdGltZWxpbmVEYXRhQXJyYXkucHVzaCh7XG4gICAgICAgIC4uLnJlc3QsXG5cbiAgICAgICAgLy8gTW9zdCBvZiB0aGUgZGF0YSBpcyBzYWZlIHRvIHBhcnNlIGFzLWlzLFxuICAgICAgICAvLyBidXQgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBuZXN0ZWQgQXJyYXlzIGJhY2sgdG8gTWFwcy5cbiAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwOiBuZXcgTWFwKGJhdGNoVUlEVG9NZWFzdXJlc0tleVZhbHVlQXJyYXkpLFxuICAgICAgICBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzOiBuZXcgTWFwKGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMpLFxuICAgICAgICBsYW5lVG9MYWJlbE1hcDogbmV3IE1hcChsYW5lVG9MYWJlbEtleVZhbHVlQXJyYXkpLFxuICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVNYXA6IG5ldyBNYXAobGFuZVRvUmVhY3RNZWFzdXJlS2V5VmFsdWVBcnJheSksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkYXRhQmFja2VuZC5kYXRhRm9yUm9vdHMuZm9yRWFjaChcbiAgICAgICh7Y29tbWl0RGF0YSwgZGlzcGxheU5hbWUsIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucywgcm9vdElEfSkgPT4ge1xuICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gb3BlcmF0aW9uc0J5Um9vdElELmdldChyb290SUQpO1xuICAgICAgICBpZiAob3BlcmF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBgQ291bGQgbm90IGZpbmQgcHJvZmlsaW5nIG9wZXJhdGlvbnMgZm9yIHJvb3QgXCIke3Jvb3RJRH1cImAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNuYXBzaG90cyA9IHNuYXBzaG90c0J5Um9vdElELmdldChyb290SUQpO1xuICAgICAgICBpZiAoc25hcHNob3RzID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBwcm9maWxpbmcgc25hcHNob3RzIGZvciByb290IFwiJHtyb290SUR9XCJgLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBub3QgZmlsdGVyIGVtcHR5IGNvbW1pdHMgZnJvbSB0aGUgcHJvZmlsZXIgZGF0YSFcbiAgICAgICAgLy8gSGlkaW5nIFwiZW1wdHlcIiBjb21taXRzIG1pZ2h0IGNhdXNlIGNvbmZ1c2lvbiB0b28uXG4gICAgICAgIC8vIEEgY29tbWl0ICpkaWQgaGFwcGVuKiBldmVuIGlmIG5vbmUgb2YgdGhlIGNvbXBvbmVudHMgdGhlIFByb2ZpbGVyIGlzIHNob3dpbmcgd2VyZSBpbnZvbHZlZC5cbiAgICAgICAgY29uc3QgY29udmVydGVkQ29tbWl0RGF0YSA9IGNvbW1pdERhdGEubWFwKFxuICAgICAgICAgIChjb21taXREYXRhQmFja2VuZCwgY29tbWl0SW5kZXgpID0+ICh7XG4gICAgICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6XG4gICAgICAgICAgICAgIGNvbW1pdERhdGFCYWNrZW5kLmNoYW5nZURlc2NyaXB0aW9ucyAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyBuZXcgTWFwKGNvbW1pdERhdGFCYWNrZW5kLmNoYW5nZURlc2NyaXB0aW9ucylcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICBkdXJhdGlvbjogY29tbWl0RGF0YUJhY2tlbmQuZHVyYXRpb24sXG4gICAgICAgICAgICBlZmZlY3REdXJhdGlvbjogY29tbWl0RGF0YUJhY2tlbmQuZWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBmaWJlckFjdHVhbER1cmF0aW9uczogbmV3IE1hcChcbiAgICAgICAgICAgICAgY29tbWl0RGF0YUJhY2tlbmQuZmliZXJBY3R1YWxEdXJhdGlvbnMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZmliZXJTZWxmRHVyYXRpb25zOiBuZXcgTWFwKGNvbW1pdERhdGFCYWNrZW5kLmZpYmVyU2VsZkR1cmF0aW9ucyksXG4gICAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IGNvbW1pdERhdGFCYWNrZW5kLnBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIHByaW9yaXR5TGV2ZWw6IGNvbW1pdERhdGFCYWNrZW5kLnByaW9yaXR5TGV2ZWwsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGNvbW1pdERhdGFCYWNrZW5kLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHVwZGF0ZXJzOlxuICAgICAgICAgICAgICBjb21taXREYXRhQmFja2VuZC51cGRhdGVycyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gY29tbWl0RGF0YUJhY2tlbmQudXBkYXRlcnMubWFwKFxuICAgICAgICAgICAgICAgICAgICBiYWNrZW5kVG9Gcm9udGVuZFNlcmlhbGl6ZWRFbGVtZW50TWFwcGVyLFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICBkYXRhRm9yUm9vdHMuc2V0KHJvb3RJRCwge1xuICAgICAgICAgIGNvbW1pdERhdGE6IGNvbnZlcnRlZENvbW1pdERhdGEsXG4gICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgICAgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zOiBuZXcgTWFwKGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucyksXG4gICAgICAgICAgb3BlcmF0aW9ucyxcbiAgICAgICAgICByb290SUQsXG4gICAgICAgICAgc25hcHNob3RzLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtkYXRhRm9yUm9vdHMsIGltcG9ydGVkOiBmYWxzZSwgdGltZWxpbmVEYXRhOiB0aW1lbGluZURhdGFBcnJheX07XG59XG5cbi8vIENvbnZlcnRzIGEgUHJvZmlsaW5nIGRhdGEgZXhwb3J0IGludG8gdGhlIGZvcm1hdCByZXF1aXJlZCBieSB0aGUgU3RvcmUuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVByb2ZpbGluZ0RhdGFGcm9udGVuZEZyb21FeHBvcnQoXG4gIHByb2ZpbGluZ0RhdGFFeHBvcnQ6IFByb2ZpbGluZ0RhdGFFeHBvcnQsXG4pOiBQcm9maWxpbmdEYXRhRnJvbnRlbmQge1xuICBjb25zdCB7dmVyc2lvbn0gPSBwcm9maWxpbmdEYXRhRXhwb3J0O1xuXG4gIGlmICh2ZXJzaW9uICE9PSBQUk9GSUxFUl9FWFBPUlRfVkVSU0lPTikge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb2ZpbGUgZXhwb3J0IHZlcnNpb24gXCIke3ZlcnNpb259XCIuIFN1cHBvcnRlZCB2ZXJzaW9uIGlzIFwiJHtQUk9GSUxFUl9FWFBPUlRfVkVSU0lPTn1cIi5gLFxuICAgICk7XG4gIH1cblxuICBjb25zdCB0aW1lbGluZURhdGE6IEFycmF5PFRpbWVsaW5lRGF0YT4gPSBwcm9maWxpbmdEYXRhRXhwb3J0LnRpbWVsaW5lRGF0YVxuICAgID8gcHJvZmlsaW5nRGF0YUV4cG9ydC50aW1lbGluZURhdGEubWFwKFxuICAgICAgICAoe1xuICAgICAgICAgIGJhdGNoVUlEVG9NZWFzdXJlc0tleVZhbHVlQXJyYXksXG4gICAgICAgICAgY29tcG9uZW50TWVhc3VyZXMsXG4gICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgZmxhbWVjaGFydCxcbiAgICAgICAgICBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzLFxuICAgICAgICAgIGxhbmVUb0xhYmVsS2V5VmFsdWVBcnJheSxcbiAgICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVLZXlWYWx1ZUFycmF5LFxuICAgICAgICAgIG5hdGl2ZUV2ZW50cyxcbiAgICAgICAgICBuZXR3b3JrTWVhc3VyZXMsXG4gICAgICAgICAgb3RoZXJVc2VyVGltaW5nTWFya3MsXG4gICAgICAgICAgcmVhY3RWZXJzaW9uLFxuICAgICAgICAgIHNjaGVkdWxpbmdFdmVudHMsXG4gICAgICAgICAgc25hcHNob3RzLFxuICAgICAgICAgIHNuYXBzaG90SGVpZ2h0LFxuICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICBzdXNwZW5zZUV2ZW50cyxcbiAgICAgICAgICB0aHJvd25FcnJvcnMsXG4gICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgLy8gTW9zdCBvZiB0aGUgZGF0YSBpcyBzYWZlIHRvIHBhcnNlIGFzLWlzLFxuICAgICAgICAgIC8vIGJ1dCB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIG5lc3RlZCBBcnJheXMgYmFjayB0byBNYXBzLlxuICAgICAgICAgIGJhdGNoVUlEVG9NZWFzdXJlc01hcDogbmV3IE1hcChiYXRjaFVJRFRvTWVhc3VyZXNLZXlWYWx1ZUFycmF5KSxcbiAgICAgICAgICBjb21wb25lbnRNZWFzdXJlcyxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICBmbGFtZWNoYXJ0LFxuICAgICAgICAgIGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXM6IG5ldyBNYXAoaW50ZXJuYWxNb2R1bGVTb3VyY2VUb1JhbmdlcyksXG4gICAgICAgICAgbGFuZVRvTGFiZWxNYXA6IG5ldyBNYXAobGFuZVRvTGFiZWxLZXlWYWx1ZUFycmF5KSxcbiAgICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVNYXA6IG5ldyBNYXAobGFuZVRvUmVhY3RNZWFzdXJlS2V5VmFsdWVBcnJheSksXG4gICAgICAgICAgbmF0aXZlRXZlbnRzLFxuICAgICAgICAgIG5ldHdvcmtNZWFzdXJlcyxcbiAgICAgICAgICBvdGhlclVzZXJUaW1pbmdNYXJrcyxcbiAgICAgICAgICByZWFjdFZlcnNpb24sXG4gICAgICAgICAgc2NoZWR1bGluZ0V2ZW50cyxcbiAgICAgICAgICBzbmFwc2hvdHMsXG4gICAgICAgICAgc25hcHNob3RIZWlnaHQsXG4gICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgIHN1c3BlbnNlRXZlbnRzLFxuICAgICAgICAgIHRocm93bkVycm9ycyxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgOiBbXTtcblxuICBjb25zdCBkYXRhRm9yUm9vdHM6IE1hcDxudW1iZXIsIFByb2ZpbGluZ0RhdGFGb3JSb290RnJvbnRlbmQ+ID0gbmV3IE1hcCgpO1xuICBwcm9maWxpbmdEYXRhRXhwb3J0LmRhdGFGb3JSb290cy5mb3JFYWNoKFxuICAgICh7XG4gICAgICBjb21taXREYXRhLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMsXG4gICAgICBvcGVyYXRpb25zLFxuICAgICAgcm9vdElELFxuICAgICAgc25hcHNob3RzLFxuICAgIH0pID0+IHtcbiAgICAgIGRhdGFGb3JSb290cy5zZXQocm9vdElELCB7XG4gICAgICAgIGNvbW1pdERhdGE6IGNvbW1pdERhdGEubWFwKFxuICAgICAgICAgICh7XG4gICAgICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnMsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIGVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgZmliZXJBY3R1YWxEdXJhdGlvbnMsXG4gICAgICAgICAgICBmaWJlclNlbGZEdXJhdGlvbnMsXG4gICAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBwcmlvcml0eUxldmVsLFxuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgdXBkYXRlcnMsXG4gICAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICAgIGNoYW5nZURlc2NyaXB0aW9uczpcbiAgICAgICAgICAgICAgY2hhbmdlRGVzY3JpcHRpb25zICE9IG51bGwgPyBuZXcgTWFwKGNoYW5nZURlc2NyaXB0aW9ucykgOiBudWxsLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBlZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIGZpYmVyQWN0dWFsRHVyYXRpb25zOiBuZXcgTWFwKGZpYmVyQWN0dWFsRHVyYXRpb25zKSxcbiAgICAgICAgICAgIGZpYmVyU2VsZkR1cmF0aW9uczogbmV3IE1hcChmaWJlclNlbGZEdXJhdGlvbnMpLFxuICAgICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHVwZGF0ZXJzLFxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zOiBuZXcgTWFwKGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucyksXG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgc25hcHNob3RzOiBuZXcgTWFwKHNuYXBzaG90cyksXG4gICAgICB9KTtcbiAgICB9LFxuICApO1xuXG4gIHJldHVybiB7XG4gICAgZGF0YUZvclJvb3RzLFxuICAgIGltcG9ydGVkOiB0cnVlLFxuICAgIHRpbWVsaW5lRGF0YSxcbiAgfTtcbn1cblxuLy8gQ29udmVydHMgYSBTdG9yZSBQcm9maWxpbmcgZGF0YSBpbnRvIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHNhZmVseSAoSlNPTikgc2VyaWFsaXplZCBmb3IgZXhwb3J0LlxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQcm9maWxpbmdEYXRhRXhwb3J0KFxuICBwcm9maWxpbmdEYXRhRnJvbnRlbmQ6IFByb2ZpbGluZ0RhdGFGcm9udGVuZCxcbik6IFByb2ZpbGluZ0RhdGFFeHBvcnQge1xuICBjb25zdCB0aW1lbGluZURhdGE6IEFycmF5PFRpbWVsaW5lRGF0YUV4cG9ydD4gPVxuICAgIHByb2ZpbGluZ0RhdGFGcm9udGVuZC50aW1lbGluZURhdGEubWFwKFxuICAgICAgKHtcbiAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwLFxuICAgICAgICBjb21wb25lbnRNZWFzdXJlcyxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGZsYW1lY2hhcnQsXG4gICAgICAgIGludGVybmFsTW9kdWxlU291cmNlVG9SYW5nZXMsXG4gICAgICAgIGxhbmVUb0xhYmVsTWFwLFxuICAgICAgICBsYW5lVG9SZWFjdE1lYXN1cmVNYXAsXG4gICAgICAgIG5hdGl2ZUV2ZW50cyxcbiAgICAgICAgbmV0d29ya01lYXN1cmVzLFxuICAgICAgICBvdGhlclVzZXJUaW1pbmdNYXJrcyxcbiAgICAgICAgcmVhY3RWZXJzaW9uLFxuICAgICAgICBzY2hlZHVsaW5nRXZlbnRzLFxuICAgICAgICBzbmFwc2hvdHMsXG4gICAgICAgIHNuYXBzaG90SGVpZ2h0LFxuICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIHN1c3BlbnNlRXZlbnRzLFxuICAgICAgICB0aHJvd25FcnJvcnMsXG4gICAgICB9KSA9PiAoe1xuICAgICAgICAvLyBNb3N0IG9mIHRoZSBkYXRhIGlzIHNhZmUgdG8gc2VyaWFsaXplIGFzLWlzLFxuICAgICAgICAvLyBidXQgd2UgbmVlZCB0byBjb252ZXJ0IHRoZSBNYXBzIHRvIG5lc3RlZCBBcnJheXMuXG4gICAgICAgIGJhdGNoVUlEVG9NZWFzdXJlc0tleVZhbHVlQXJyYXk6IEFycmF5LmZyb20oXG4gICAgICAgICAgYmF0Y2hVSURUb01lYXN1cmVzTWFwLmVudHJpZXMoKSxcbiAgICAgICAgKSxcbiAgICAgICAgY29tcG9uZW50TWVhc3VyZXM6IGNvbXBvbmVudE1lYXN1cmVzLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZmxhbWVjaGFydCxcbiAgICAgICAgaW50ZXJuYWxNb2R1bGVTb3VyY2VUb1JhbmdlczogQXJyYXkuZnJvbShcbiAgICAgICAgICBpbnRlcm5hbE1vZHVsZVNvdXJjZVRvUmFuZ2VzLmVudHJpZXMoKSxcbiAgICAgICAgKSxcbiAgICAgICAgbGFuZVRvTGFiZWxLZXlWYWx1ZUFycmF5OiBBcnJheS5mcm9tKGxhbmVUb0xhYmVsTWFwLmVudHJpZXMoKSksXG4gICAgICAgIGxhbmVUb1JlYWN0TWVhc3VyZUtleVZhbHVlQXJyYXk6IEFycmF5LmZyb20oXG4gICAgICAgICAgbGFuZVRvUmVhY3RNZWFzdXJlTWFwLmVudHJpZXMoKSxcbiAgICAgICAgKSxcbiAgICAgICAgbmF0aXZlRXZlbnRzLFxuICAgICAgICBuZXR3b3JrTWVhc3VyZXMsXG4gICAgICAgIG90aGVyVXNlclRpbWluZ01hcmtzLFxuICAgICAgICByZWFjdFZlcnNpb24sXG4gICAgICAgIHNjaGVkdWxpbmdFdmVudHMsXG4gICAgICAgIHNuYXBzaG90cyxcbiAgICAgICAgc25hcHNob3RIZWlnaHQsXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgc3VzcGVuc2VFdmVudHMsXG4gICAgICAgIHRocm93bkVycm9ycyxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgY29uc3QgZGF0YUZvclJvb3RzOiBBcnJheTxQcm9maWxpbmdEYXRhRm9yUm9vdEV4cG9ydD4gPSBbXTtcbiAgcHJvZmlsaW5nRGF0YUZyb250ZW5kLmRhdGFGb3JSb290cy5mb3JFYWNoKFxuICAgICh7XG4gICAgICBjb21taXREYXRhLFxuICAgICAgZGlzcGxheU5hbWUsXG4gICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMsXG4gICAgICBvcGVyYXRpb25zLFxuICAgICAgcm9vdElELFxuICAgICAgc25hcHNob3RzLFxuICAgIH0pID0+IHtcbiAgICAgIGRhdGFGb3JSb290cy5wdXNoKHtcbiAgICAgICAgY29tbWl0RGF0YTogY29tbWl0RGF0YS5tYXAoXG4gICAgICAgICAgKHtcbiAgICAgICAgICAgIGNoYW5nZURlc2NyaXB0aW9ucyxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgZWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBmaWJlckFjdHVhbER1cmF0aW9ucyxcbiAgICAgICAgICAgIGZpYmVyU2VsZkR1cmF0aW9ucyxcbiAgICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICB1cGRhdGVycyxcbiAgICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgICAgY2hhbmdlRGVzY3JpcHRpb25zOlxuICAgICAgICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnMgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbShjaGFuZ2VEZXNjcmlwdGlvbnMuZW50cmllcygpKVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgZWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgICBmaWJlckFjdHVhbER1cmF0aW9uczogQXJyYXkuZnJvbShmaWJlckFjdHVhbER1cmF0aW9ucy5lbnRyaWVzKCkpLFxuICAgICAgICAgICAgZmliZXJTZWxmRHVyYXRpb25zOiBBcnJheS5mcm9tKGZpYmVyU2VsZkR1cmF0aW9ucy5lbnRyaWVzKCkpLFxuICAgICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHVwZGF0ZXJzLFxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgaW5pdGlhbFRyZWVCYXNlRHVyYXRpb25zOiBBcnJheS5mcm9tKFxuICAgICAgICAgIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucy5lbnRyaWVzKCksXG4gICAgICAgICksXG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgc25hcHNob3RzOiBBcnJheS5mcm9tKHNuYXBzaG90cy5lbnRyaWVzKCkpLFxuICAgICAgfSk7XG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb246IFBST0ZJTEVSX0VYUE9SVF9WRVJTSU9OLFxuICAgIGRhdGFGb3JSb290cyxcbiAgICB0aW1lbGluZURhdGEsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBnZXRHcmFkaWVudENvbG9yID0gKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCBtYXhJbmRleCA9IGNvbW1pdEdyYWRpZW50Lmxlbmd0aCAtIDE7XG4gIGxldCBpbmRleDtcbiAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICBpbmRleCA9IDA7XG4gIH0gZWxzZSBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICBpbmRleCA9IG1heEluZGV4O1xuICB9IGVsc2Uge1xuICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4SW5kZXgsIHZhbHVlKSkgKiBtYXhJbmRleDtcbiAgfVxuICByZXR1cm4gY29tbWl0R3JhZGllbnRbTWF0aC5yb3VuZChpbmRleCldO1xufTtcblxuZXhwb3J0IGNvbnN0IGZvcm1hdER1cmF0aW9uID0gKGR1cmF0aW9uOiBudW1iZXIpOiBudW1iZXIgfCBzdHJpbmcgPT5cbiAgTWF0aC5yb3VuZChkdXJhdGlvbiAqIDEwKSAvIDEwIHx8ICc8MC4xJztcbmV4cG9ydCBjb25zdCBmb3JtYXRQZXJjZW50YWdlID0gKHBlcmNlbnRhZ2U6IG51bWJlcik6IG51bWJlciA9PlxuICBNYXRoLnJvdW5kKHBlcmNlbnRhZ2UgKiAxMDApO1xuZXhwb3J0IGNvbnN0IGZvcm1hdFRpbWUgPSAodGltZXN0YW1wOiBudW1iZXIpOiBudW1iZXIgPT5cbiAgTWF0aC5yb3VuZChNYXRoLnJvdW5kKHRpbWVzdGFtcCkgLyAxMDApIC8gMTA7XG5cbmV4cG9ydCBjb25zdCBzY2FsZSA9XG4gIChcbiAgICBtaW5WYWx1ZTogbnVtYmVyLFxuICAgIG1heFZhbHVlOiBudW1iZXIsXG4gICAgbWluUmFuZ2U6IG51bWJlcixcbiAgICBtYXhSYW5nZTogbnVtYmVyLFxuICApOiAoKHZhbHVlOiBudW1iZXIsIGZhbGxiYWNrVmFsdWU6IG51bWJlcikgPT4gbnVtYmVyKSA9PlxuICAodmFsdWU6IG51bWJlciwgZmFsbGJhY2tWYWx1ZTogbnVtYmVyKSA9PlxuICAgIG1heFZhbHVlIC0gbWluVmFsdWUgPT09IDBcbiAgICAgID8gZmFsbGJhY2tWYWx1ZVxuICAgICAgOiAoKHZhbHVlIC0gbWluVmFsdWUpIC8gKG1heFZhbHVlIC0gbWluVmFsdWUpKSAqIChtYXhSYW5nZSAtIG1pblJhbmdlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/devtools/views/Profiler/utils.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/events.js":
/*!**********************************************!*\
  !*** ../react-devtools-shared/src/events.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EventEmitter)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nclass EventEmitter {\n  constructor() {\n    _defineProperty(this, \"listenersMap\", new Map());\n  }\n\n  addListener(event, listener) {\n    const listeners = this.listenersMap.get(event);\n\n    if (listeners === undefined) {\n      this.listenersMap.set(event, [listener]);\n    } else {\n      const index = listeners.indexOf(listener);\n\n      if (index < 0) {\n        listeners.push(listener);\n      }\n    }\n  }\n\n  emit(event, ...args) {\n    const listeners = this.listenersMap.get(event);\n\n    if (listeners !== undefined) {\n      if (listeners.length === 1) {\n        // No need to clone or try/catch\n        const listener = listeners[0];\n        listener.apply(null, args);\n      } else {\n        let didThrow = false;\n        let caughtError = null;\n        const clonedListeners = Array.from(listeners);\n\n        for (let i = 0; i < clonedListeners.length; i++) {\n          const listener = clonedListeners[i];\n\n          try {\n            listener.apply(null, args);\n          } catch (error) {\n            if (caughtError === null) {\n              didThrow = true;\n              caughtError = error;\n            }\n          }\n        }\n\n        if (didThrow) {\n          throw caughtError;\n        }\n      }\n    }\n  }\n\n  removeAllListeners() {\n    this.listenersMap.clear();\n  }\n\n  removeListener(event, listener) {\n    const listeners = this.listenersMap.get(event);\n\n    if (listeners !== undefined) {\n      const index = listeners.indexOf(listener);\n\n      if (index >= 0) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9ldmVudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBaEVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2V2ZW50cy5qcz85ZDIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50RW1pdHRlcjxFdmVudHM6IE9iamVjdD4ge1xuICBsaXN0ZW5lcnNNYXA6IE1hcDxzdHJpbmcsIEFycmF5PEZ1bmN0aW9uPj4gPSBuZXcgTWFwKCk7XG5cbiAgYWRkTGlzdGVuZXI8RXZlbnQ6ICRLZXlzPEV2ZW50cz4+KFxuICAgIGV2ZW50OiBFdmVudCxcbiAgICBsaXN0ZW5lcjogKC4uLiRFbGVtZW50VHlwZTxFdmVudHMsIEV2ZW50PikgPT4gYW55LFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc01hcC5nZXQoZXZlbnQpO1xuICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNNYXAuc2V0KGV2ZW50LCBbbGlzdGVuZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbWl0PEV2ZW50OiAkS2V5czxFdmVudHM+PihcbiAgICBldmVudDogRXZlbnQsXG4gICAgLi4uYXJnczogJEVsZW1lbnRUeXBlPEV2ZW50cywgRXZlbnQ+XG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzTWFwLmdldChldmVudCk7XG4gICAgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNsb25lIG9yIHRyeS9jYXRjaFxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyc1swXTtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGlkVGhyb3cgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhdWdodEVycm9yID0gbnVsbDtcblxuICAgICAgICBjb25zdCBjbG9uZWRMaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGxpc3RlbmVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvbmVkTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBjbG9uZWRMaXN0ZW5lcnNbaV07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGlkVGhyb3cgPSB0cnVlO1xuICAgICAgICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaWRUaHJvdykge1xuICAgICAgICAgIHRocm93IGNhdWdodEVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMubGlzdGVuZXJzTWFwLmNsZWFyKCk7XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcihldmVudDogJEtleXM8RXZlbnRzPiwgbGlzdGVuZXI6IEZ1bmN0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNNYXAuZ2V0KGV2ZW50KTtcbiAgICBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/events.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/frontend/types.js":
/*!******************************************************!*\
  !*** ../react-devtools-shared/src/frontend/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ComponentFilterDisplayName\": () => (/* binding */ ComponentFilterDisplayName),\n/* harmony export */   \"ComponentFilterElementType\": () => (/* binding */ ComponentFilterElementType),\n/* harmony export */   \"ComponentFilterEnvironmentName\": () => (/* binding */ ComponentFilterEnvironmentName),\n/* harmony export */   \"ComponentFilterHOC\": () => (/* binding */ ComponentFilterHOC),\n/* harmony export */   \"ComponentFilterLocation\": () => (/* binding */ ComponentFilterLocation),\n/* harmony export */   \"ElementTypeClass\": () => (/* binding */ ElementTypeClass),\n/* harmony export */   \"ElementTypeContext\": () => (/* binding */ ElementTypeContext),\n/* harmony export */   \"ElementTypeForwardRef\": () => (/* binding */ ElementTypeForwardRef),\n/* harmony export */   \"ElementTypeFunction\": () => (/* binding */ ElementTypeFunction),\n/* harmony export */   \"ElementTypeHostComponent\": () => (/* binding */ ElementTypeHostComponent),\n/* harmony export */   \"ElementTypeMemo\": () => (/* binding */ ElementTypeMemo),\n/* harmony export */   \"ElementTypeOtherOrUnknown\": () => (/* binding */ ElementTypeOtherOrUnknown),\n/* harmony export */   \"ElementTypeProfiler\": () => (/* binding */ ElementTypeProfiler),\n/* harmony export */   \"ElementTypeRoot\": () => (/* binding */ ElementTypeRoot),\n/* harmony export */   \"ElementTypeSuspense\": () => (/* binding */ ElementTypeSuspense),\n/* harmony export */   \"ElementTypeSuspenseList\": () => (/* binding */ ElementTypeSuspenseList),\n/* harmony export */   \"ElementTypeTracingMarker\": () => (/* binding */ ElementTypeTracingMarker),\n/* harmony export */   \"ElementTypeVirtual\": () => (/* binding */ ElementTypeVirtual),\n/* harmony export */   \"StrictMode\": () => (/* binding */ StrictMode)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * WARNING:\n * This file contains types that are designed for React DevTools UI and how it interacts with the backend.\n * They might be used in different versions of DevTools backends.\n * Be mindful of backwards compatibility when making changes.\n */\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new element types are added, use new numbers rather than re-ordering existing ones.\n//\n// Changing these types is also a backwards breaking change for the standalone shell,\n// since the frontend and backend must share the same values-\n// and the backend is embedded in certain environments (like React Native).\nconst ElementTypeClass = 1;\nconst ElementTypeContext = 2;\nconst ElementTypeFunction = 5;\nconst ElementTypeForwardRef = 6;\nconst ElementTypeHostComponent = 7;\nconst ElementTypeMemo = 8;\nconst ElementTypeOtherOrUnknown = 9;\nconst ElementTypeProfiler = 10;\nconst ElementTypeRoot = 11;\nconst ElementTypeSuspense = 12;\nconst ElementTypeSuspenseList = 13;\nconst ElementTypeTracingMarker = 14;\nconst ElementTypeVirtual = 15; // Different types of elements displayed in the Elements tree.\n// These types may be used to visually distinguish types,\n// or to enable/disable certain functionality.\n\n// WARNING\n// The values below are referenced by ComponentFilters (which are saved via localStorage).\n// Do not change them or it will break previously saved user customizations.\n// If new filter types are added, use new numbers rather than re-ordering existing ones.\nconst ComponentFilterElementType = 1;\nconst ComponentFilterDisplayName = 2;\nconst ComponentFilterLocation = 3;\nconst ComponentFilterHOC = 4;\nconst ComponentFilterEnvironmentName = 5;\nconst StrictMode = 1; // Each element on the frontend corresponds to an ElementID (e.g. a Fiber) on the backend.\n// Some of its information (e.g. id, type, displayName) come from the backend.\n// Other bits (e.g. weight and depth) are computed on the frontend for windowing and display purposes.\n// Elements are updated on a push basis meaning the backend pushes updates to the frontend when needed.//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztBQVNBOzs7Ozs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ0VBO0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2Zyb250ZW5kL3R5cGVzLmpzP2IwMzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKi9cblxuLyoqXG4gKiBXQVJOSU5HOlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHR5cGVzIHRoYXQgYXJlIGRlc2lnbmVkIGZvciBSZWFjdCBEZXZUb29scyBVSSBhbmQgaG93IGl0IGludGVyYWN0cyB3aXRoIHRoZSBiYWNrZW5kLlxuICogVGhleSBtaWdodCBiZSB1c2VkIGluIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBEZXZUb29scyBiYWNrZW5kcy5cbiAqIEJlIG1pbmRmdWwgb2YgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2hlbiBtYWtpbmcgY2hhbmdlcy5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gIERlaHlkcmF0ZWQsXG4gIFVuc2VyaWFsaXphYmxlLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2h5ZHJhdGlvbic7XG5pbXBvcnQgdHlwZSB7U291cmNlfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIEJyb3dzZXJUaGVtZSA9ICdkYXJrJyB8ICdsaWdodCc7XG5cbmV4cG9ydCB0eXBlIFdhbGwgPSB7XG4gIC8vIGBsaXN0ZW5gIHJldHVybnMgdGhlIFwidW5saXN0ZW5cIiBmdW5jdGlvbi5cbiAgbGlzdGVuOiAoZm46IEZ1bmN0aW9uKSA9PiBGdW5jdGlvbixcbiAgc2VuZDogKGV2ZW50OiBzdHJpbmcsIHBheWxvYWQ6IGFueSwgdHJhbnNmZXJhYmxlPzogQXJyYXk8YW55PikgPT4gdm9pZCxcbn07XG5cbi8vIFdBUk5JTkdcbi8vIFRoZSB2YWx1ZXMgYmVsb3cgYXJlIHJlZmVyZW5jZWQgYnkgQ29tcG9uZW50RmlsdGVycyAod2hpY2ggYXJlIHNhdmVkIHZpYSBsb2NhbFN0b3JhZ2UpLlxuLy8gRG8gbm90IGNoYW5nZSB0aGVtIG9yIGl0IHdpbGwgYnJlYWsgcHJldmlvdXNseSBzYXZlZCB1c2VyIGN1c3RvbWl6YXRpb25zLlxuLy8gSWYgbmV3IGVsZW1lbnQgdHlwZXMgYXJlIGFkZGVkLCB1c2UgbmV3IG51bWJlcnMgcmF0aGVyIHRoYW4gcmUtb3JkZXJpbmcgZXhpc3Rpbmcgb25lcy5cbi8vXG4vLyBDaGFuZ2luZyB0aGVzZSB0eXBlcyBpcyBhbHNvIGEgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZSBmb3IgdGhlIHN0YW5kYWxvbmUgc2hlbGwsXG4vLyBzaW5jZSB0aGUgZnJvbnRlbmQgYW5kIGJhY2tlbmQgbXVzdCBzaGFyZSB0aGUgc2FtZSB2YWx1ZXMtXG4vLyBhbmQgdGhlIGJhY2tlbmQgaXMgZW1iZWRkZWQgaW4gY2VydGFpbiBlbnZpcm9ubWVudHMgKGxpa2UgUmVhY3QgTmF0aXZlKS5cbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZUNsYXNzID0gMTtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZUNvbnRleHQgPSAyO1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlRnVuY3Rpb24gPSA1O1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlRm9yd2FyZFJlZiA9IDY7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50ID0gNztcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZU1lbW8gPSA4O1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gPSA5O1xuZXhwb3J0IGNvbnN0IEVsZW1lbnRUeXBlUHJvZmlsZXIgPSAxMDtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZVJvb3QgPSAxMTtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZVN1c3BlbnNlID0gMTI7XG5leHBvcnQgY29uc3QgRWxlbWVudFR5cGVTdXNwZW5zZUxpc3QgPSAxMztcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZVRyYWNpbmdNYXJrZXIgPSAxNDtcbmV4cG9ydCBjb25zdCBFbGVtZW50VHlwZVZpcnR1YWwgPSAxNTtcblxuLy8gRGlmZmVyZW50IHR5cGVzIG9mIGVsZW1lbnRzIGRpc3BsYXllZCBpbiB0aGUgRWxlbWVudHMgdHJlZS5cbi8vIFRoZXNlIHR5cGVzIG1heSBiZSB1c2VkIHRvIHZpc3VhbGx5IGRpc3Rpbmd1aXNoIHR5cGVzLFxuLy8gb3IgdG8gZW5hYmxlL2Rpc2FibGUgY2VydGFpbiBmdW5jdGlvbmFsaXR5LlxuZXhwb3J0IHR5cGUgRWxlbWVudFR5cGUgPVxuICB8IDFcbiAgfCAyXG4gIHwgNVxuICB8IDZcbiAgfCA3XG4gIHwgOFxuICB8IDlcbiAgfCAxMFxuICB8IDExXG4gIHwgMTJcbiAgfCAxM1xuICB8IDE0XG4gIHwgMTU7XG5cbi8vIFdBUk5JTkdcbi8vIFRoZSB2YWx1ZXMgYmVsb3cgYXJlIHJlZmVyZW5jZWQgYnkgQ29tcG9uZW50RmlsdGVycyAod2hpY2ggYXJlIHNhdmVkIHZpYSBsb2NhbFN0b3JhZ2UpLlxuLy8gRG8gbm90IGNoYW5nZSB0aGVtIG9yIGl0IHdpbGwgYnJlYWsgcHJldmlvdXNseSBzYXZlZCB1c2VyIGN1c3RvbWl6YXRpb25zLlxuLy8gSWYgbmV3IGZpbHRlciB0eXBlcyBhcmUgYWRkZWQsIHVzZSBuZXcgbnVtYmVycyByYXRoZXIgdGhhbiByZS1vcmRlcmluZyBleGlzdGluZyBvbmVzLlxuZXhwb3J0IGNvbnN0IENvbXBvbmVudEZpbHRlckVsZW1lbnRUeXBlID0gMTtcbmV4cG9ydCBjb25zdCBDb21wb25lbnRGaWx0ZXJEaXNwbGF5TmFtZSA9IDI7XG5leHBvcnQgY29uc3QgQ29tcG9uZW50RmlsdGVyTG9jYXRpb24gPSAzO1xuZXhwb3J0IGNvbnN0IENvbXBvbmVudEZpbHRlckhPQyA9IDQ7XG5leHBvcnQgY29uc3QgQ29tcG9uZW50RmlsdGVyRW52aXJvbm1lbnROYW1lID0gNTtcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50RmlsdGVyVHlwZSA9IDEgfCAyIHwgMyB8IDQgfCA1O1xuXG4vLyBIaWRlIGFsbCBlbGVtZW50cyBvZiB0eXBlcyBpbiB0aGlzIFNldC5cbi8vIFdlIGhpZGUgaG9zdCBjb21wb25lbnRzIG9ubHkgYnkgZGVmYXVsdC5cbmV4cG9ydCB0eXBlIEVsZW1lbnRUeXBlQ29tcG9uZW50RmlsdGVyID0ge1xuICBpc0VuYWJsZWQ6IGJvb2xlYW4sXG4gIHR5cGU6IDEsXG4gIHZhbHVlOiBFbGVtZW50VHlwZSxcbn07XG5cbi8vIEhpZGUgYWxsIGVsZW1lbnRzIHdpdGggZGlzcGxheU5hbWVzIG9yIHBhdGhzIG1hdGNoaW5nIG9uZSBvciBtb3JlIG9mIHRoZSBSZWdFeHBzIGluIHRoaXMgU2V0LlxuLy8gUGF0aCBmaWx0ZXJzIGFyZSBvbmx5IHVzZWQgd2hlbiBlbGVtZW50cyBpbmNsdWRlIGRlYnVnIHNvdXJjZSBsb2NhdGlvbi5cbmV4cG9ydCB0eXBlIFJlZ0V4cENvbXBvbmVudEZpbHRlciA9IHtcbiAgaXNFbmFibGVkOiBib29sZWFuLFxuICBpc1ZhbGlkOiBib29sZWFuLFxuICB0eXBlOiAyIHwgMyxcbiAgdmFsdWU6IHN0cmluZyxcbn07XG5cbmV4cG9ydCB0eXBlIEJvb2xlYW5Db21wb25lbnRGaWx0ZXIgPSB7XG4gIGlzRW5hYmxlZDogYm9vbGVhbixcbiAgaXNWYWxpZDogYm9vbGVhbixcbiAgdHlwZTogNCxcbn07XG5cbmV4cG9ydCB0eXBlIEVudmlyb25tZW50TmFtZUNvbXBvbmVudEZpbHRlciA9IHtcbiAgaXNFbmFibGVkOiBib29sZWFuLFxuICBpc1ZhbGlkOiBib29sZWFuLFxuICB0eXBlOiA1LFxuICB2YWx1ZTogc3RyaW5nLFxufTtcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50RmlsdGVyID1cbiAgfCBCb29sZWFuQ29tcG9uZW50RmlsdGVyXG4gIHwgRWxlbWVudFR5cGVDb21wb25lbnRGaWx0ZXJcbiAgfCBSZWdFeHBDb21wb25lbnRGaWx0ZXJcbiAgfCBFbnZpcm9ubWVudE5hbWVDb21wb25lbnRGaWx0ZXI7XG5cbmV4cG9ydCB0eXBlIEhvb2tOYW1lID0gc3RyaW5nIHwgbnVsbDtcbi8vIE1hcCBvZiBob29rIHNvdXJjZSAoXCI8ZmlsZW5hbWU+OjxsaW5lLW51bWJlcj46PGNvbHVtbi1udW1iZXI+XCIpIHRvIG5hbWUuXG4vLyBIb29rIHNvdXJjZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIGhvb2sgaXRzZWxmIGJlY2F1c2UgdGhlIGxhdHRlciBpcyBub3Qgc3RhYmxlIGJldHdlZW4gZWxlbWVudCBpbnNwZWN0aW9ucy5cbi8vIFdlIHVzZSBhIE1hcCByYXRoZXIgdGhhbiBhbiBBcnJheSBiZWNhdXNlIG9mIG5lc3RlZCBob29rcyBhbmQgdHJhdmVyc2FsIG9yZGVyaW5nLlxuZXhwb3J0IHR5cGUgSG9va1NvdXJjZUxvY2F0aW9uS2V5ID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgSG9va05hbWVzID0gTWFwPEhvb2tTb3VyY2VMb2NhdGlvbktleSwgSG9va05hbWU+O1xuXG5leHBvcnQgdHlwZSBMUlVDYWNoZTxLLCBWPiA9IHtcbiAgZGVsOiAoa2V5OiBLKSA9PiB2b2lkLFxuICBnZXQ6IChrZXk6IEspID0+IFYsXG4gIGhhczogKGtleTogSykgPT4gYm9vbGVhbixcbiAgcmVzZXQ6ICgpID0+IHZvaWQsXG4gIHNldDogKGtleTogSywgdmFsdWU6IFYpID0+IHZvaWQsXG59O1xuXG5leHBvcnQgdHlwZSBTdHlsZVhQbHVnaW4gPSB7XG4gIHNvdXJjZXM6IEFycmF5PHN0cmluZz4sXG4gIHJlc29sdmVkU3R5bGVzOiBPYmplY3QsXG59O1xuXG5leHBvcnQgdHlwZSBQbHVnaW5zID0ge1xuICBzdHlsZXg6IFN0eWxlWFBsdWdpbiB8IG51bGwsXG59O1xuXG5leHBvcnQgY29uc3QgU3RyaWN0TW9kZSA9IDE7XG5cbi8vIEVhY2ggZWxlbWVudCBvbiB0aGUgZnJvbnRlbmQgY29ycmVzcG9uZHMgdG8gYW4gRWxlbWVudElEIChlLmcuIGEgRmliZXIpIG9uIHRoZSBiYWNrZW5kLlxuLy8gU29tZSBvZiBpdHMgaW5mb3JtYXRpb24gKGUuZy4gaWQsIHR5cGUsIGRpc3BsYXlOYW1lKSBjb21lIGZyb20gdGhlIGJhY2tlbmQuXG4vLyBPdGhlciBiaXRzIChlLmcuIHdlaWdodCBhbmQgZGVwdGgpIGFyZSBjb21wdXRlZCBvbiB0aGUgZnJvbnRlbmQgZm9yIHdpbmRvd2luZyBhbmQgZGlzcGxheSBwdXJwb3Nlcy5cbi8vIEVsZW1lbnRzIGFyZSB1cGRhdGVkIG9uIGEgcHVzaCBiYXNpc+KAkyBtZWFuaW5nIHRoZSBiYWNrZW5kIHB1c2hlcyB1cGRhdGVzIHRvIHRoZSBmcm9udGVuZCB3aGVuIG5lZWRlZC5cbmV4cG9ydCB0eXBlIEVsZW1lbnQgPSB7XG4gIGlkOiBudW1iZXIsXG4gIHBhcmVudElEOiBudW1iZXIsXG4gIGNoaWxkcmVuOiBBcnJheTxudW1iZXI+LFxuICB0eXBlOiBFbGVtZW50VHlwZSxcbiAgZGlzcGxheU5hbWU6IHN0cmluZyB8IG51bGwsXG4gIGtleTogbnVtYmVyIHwgc3RyaW5nIHwgbnVsbCxcblxuICBob2NEaXNwbGF5TmFtZXM6IG51bGwgfCBBcnJheTxzdHJpbmc+LFxuXG4gIC8vIFNob3VsZCB0aGUgZWxlbWVudHMgY2hpbGRyZW4gYmUgdmlzaWJsZSBpbiB0aGUgdHJlZT9cbiAgaXNDb2xsYXBzZWQ6IGJvb2xlYW4sXG5cbiAgLy8gT3duZXIgKGlmIGF2YWlsYWJsZSlcbiAgb3duZXJJRDogbnVtYmVyLFxuXG4gIC8vIEhvdyBtYW55IGxldmVscyBkZWVwIHdpdGhpbiB0aGUgdHJlZSBpcyB0aGlzIGVsZW1lbnQ/XG4gIC8vIFRoaXMgZGV0ZXJtaW5lcyBob3cgbXVjaCBpbmRlbnRhdGlvbiAobGVmdCBwYWRkaW5nKSBzaG91bGQgYmUgdXNlZCBpbiB0aGUgRWxlbWVudHMgdHJlZS5cbiAgZGVwdGg6IG51bWJlcixcblxuICAvLyBIb3cgbWFueSBub2RlcyAoaW5jbHVkaW5nIGl0c2VsZikgYXJlIGJlbG93IHRoaXMgRWxlbWVudCB3aXRoaW4gdGhlIHRyZWUuXG4gIC8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCB0byBxdWlja2x5IGRldGVybWluZSB0aGUgdG90YWwgbnVtYmVyIG9mIEVsZW1lbnRzLFxuICAvLyBhbmQgdGhlIEVsZW1lbnQgYXQgYW55IGdpdmVuIGluZGV4IChmb3Igd2luZG93aW5nIHB1cnBvc2VzKS5cbiAgd2VpZ2h0OiBudW1iZXIsXG5cbiAgLy8gVGhpcyBlbGVtZW50IGlzIG5vdCBpbiBhIFN0cmljdE1vZGUgY29tcGxpYW50IHN1YnRyZWUuXG4gIC8vIE9ubHkgdHJ1ZSBmb3IgUmVhY3QgdmVyc2lvbnMgc3VwcG9ydGluZyBTdHJpY3RNb2RlLlxuICBpc1N0cmljdE1vZGVOb25Db21wbGlhbnQ6IGJvb2xlYW4sXG5cbiAgLy8gSWYgY29tcG9uZW50IGlzIGNvbXBpbGVkIHdpdGggRm9yZ2V0LCB0aGUgYmFja2VuZCB3aWxsIHNlbmQgaXRzIG5hbWUgYXMgRm9yZ2V0KC4uLilcbiAgLy8gTGF0ZXIsIG9uIHRoZSBmcm9udGVuZCBzaWRlLCB3ZSB3aWxsIHN0cmlwIEhPQyBuYW1lcyBhbmQgRm9yZ2V0IHByZWZpeC5cbiAgY29tcGlsZWRXaXRoRm9yZ2V0OiBib29sZWFuLFxufTtcblxuZXhwb3J0IHR5cGUgU2VyaWFsaXplZEVsZW1lbnQgPSB7XG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsLFxuICBpZDogbnVtYmVyLFxuICBrZXk6IG51bWJlciB8IHN0cmluZyB8IG51bGwsXG4gIGhvY0Rpc3BsYXlOYW1lczogQXJyYXk8c3RyaW5nPiB8IG51bGwsXG4gIGNvbXBpbGVkV2l0aEZvcmdldDogYm9vbGVhbixcbiAgdHlwZTogRWxlbWVudFR5cGUsXG59O1xuXG5leHBvcnQgdHlwZSBPd25lcnNMaXN0ID0ge1xuICBpZDogbnVtYmVyLFxuICBvd25lcnM6IEFycmF5PFNlcmlhbGl6ZWRFbGVtZW50PiB8IG51bGwsXG59O1xuXG5leHBvcnQgdHlwZSBJbnNwZWN0ZWRFbGVtZW50UmVzcG9uc2VUeXBlID1cbiAgfCAnZXJyb3InXG4gIHwgJ2Z1bGwtZGF0YSdcbiAgfCAnaHlkcmF0ZWQtcGF0aCdcbiAgfCAnbm8tY2hhbmdlJ1xuICB8ICdub3QtZm91bmQnO1xuXG5leHBvcnQgdHlwZSBJbnNwZWN0ZWRFbGVtZW50UGF0aCA9IEFycmF5PHN0cmluZyB8IG51bWJlcj47XG5cbmV4cG9ydCB0eXBlIEluc3BlY3RlZEVsZW1lbnQgPSB7XG4gIGlkOiBudW1iZXIsXG5cbiAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGVkaXRhYmxlIGhvb2tzIGFuZCBmdW5jdGlvbiBwcm9wcz9cbiAgY2FuRWRpdEhvb2tzOiBib29sZWFuLFxuICBjYW5FZGl0RnVuY3Rpb25Qcm9wczogYm9vbGVhbixcblxuICAvLyBEb2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnQgYWR2YW5jZWQgZWRpdGluZyBpbnRlcmZhY2U/XG4gIGNhbkVkaXRIb29rc0FuZERlbGV0ZVBhdGhzOiBib29sZWFuLFxuICBjYW5FZGl0SG9va3NBbmRSZW5hbWVQYXRoczogYm9vbGVhbixcbiAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNEZWxldGVQYXRoczogYm9vbGVhbixcbiAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNSZW5hbWVQYXRoczogYm9vbGVhbixcblxuICAvLyBJcyB0aGlzIEVycm9yLCBhbmQgY2FuIGl0cyB2YWx1ZSBiZSBvdmVycmlkZGVuIG5vdz9cbiAgaXNFcnJvcmVkOiBib29sZWFuLFxuICBjYW5Ub2dnbGVFcnJvcjogYm9vbGVhbixcblxuICAvLyBJcyB0aGlzIFN1c3BlbnNlLCBhbmQgY2FuIGl0cyB2YWx1ZSBiZSBvdmVycmlkZGVuIG5vdz9cbiAgY2FuVG9nZ2xlU3VzcGVuc2U6IGJvb2xlYW4sXG5cbiAgLy8gQ2FuIHZpZXcgY29tcG9uZW50IHNvdXJjZSBsb2NhdGlvbi5cbiAgY2FuVmlld1NvdXJjZTogYm9vbGVhbixcblxuICAvLyBEb2VzIHRoZSBjb21wb25lbnQgaGF2ZSBsZWdhY3kgY29udGV4dCBhdHRhY2hlZCB0byBpdC5cbiAgaGFzTGVnYWN5Q29udGV4dDogYm9vbGVhbixcblxuICAvLyBJbnNwZWN0YWJsZSBwcm9wZXJ0aWVzLlxuICBjb250ZXh0OiBPYmplY3QgfCBudWxsLFxuICBob29rczogT2JqZWN0IHwgbnVsbCxcbiAgcHJvcHM6IE9iamVjdCB8IG51bGwsXG4gIHN0YXRlOiBPYmplY3QgfCBudWxsLFxuICBrZXk6IG51bWJlciB8IHN0cmluZyB8IG51bGwsXG4gIGVycm9yczogQXJyYXk8W3N0cmluZywgbnVtYmVyXT4sXG4gIHdhcm5pbmdzOiBBcnJheTxbc3RyaW5nLCBudW1iZXJdPixcblxuICAvLyBMaXN0IG9mIG93bmVyc1xuICBvd25lcnM6IEFycmF5PFNlcmlhbGl6ZWRFbGVtZW50PiB8IG51bGwsXG5cbiAgLy8gTG9jYXRpb24gb2YgY29tcG9uZW50IGluIHNvdXJjZSBjb2RlLlxuICBzb3VyY2U6IFNvdXJjZSB8IG51bGwsXG5cbiAgdHlwZTogRWxlbWVudFR5cGUsXG5cbiAgLy8gTWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0by5cbiAgcm9vdFR5cGU6IHN0cmluZyB8IG51bGwsXG5cbiAgLy8gTWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVuZGVyZXIgdGhhdCBjcmVhdGVkIHRoaXMgZWxlbWVudC5cbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgcmVuZGVyZXJWZXJzaW9uOiBzdHJpbmcgfCBudWxsLFxuXG4gIC8vIFVJIHBsdWdpbnMvdmlzdWFsaXphdGlvbnMgZm9yIHRoZSBpbnNwZWN0ZWQgZWxlbWVudC5cbiAgcGx1Z2luczogUGx1Z2lucyxcbn07XG5cbi8vIFRPRE86IEFkZCBwcm9maWxpbmcgdHlwZVxuXG50eXBlIERhdGEgPVxuICB8IHN0cmluZ1xuICB8IERlaHlkcmF0ZWRcbiAgfCBVbnNlcmlhbGl6YWJsZVxuICB8IEFycmF5PERlaHlkcmF0ZWQ+XG4gIHwgQXJyYXk8VW5zZXJpYWxpemFibGU+XG4gIHwge1tzdHJpbmddOiBEYXRhfTtcblxuZXhwb3J0IHR5cGUgRGVoeWRyYXRlZERhdGEgPSB7XG4gIGNsZWFuZWQ6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICBkYXRhOiBEYXRhLFxuICB1bnNlcmlhbGl6YWJsZTogQXJyYXk8QXJyYXk8c3RyaW5nIHwgbnVtYmVyPj4sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/frontend/types.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/hooks/SourceMapConsumer.js":
/*!***************************************************************!*\
  !*** ../react-devtools-shared/src/hooks/SourceMapConsumer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SourceMapConsumer)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_PerformanceLoggingUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/PerformanceLoggingUtils */ \"../react-devtools-shared/src/PerformanceLoggingUtils.js\");\n/* harmony import */ var sourcemap_codec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sourcemap-codec */ \"../../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction SourceMapConsumer(sourceMapJSON) {\n  if (sourceMapJSON.sections != null) {\n    return IndexedSourceMapConsumer(sourceMapJSON);\n  } else {\n    return BasicSourceMapConsumer(sourceMapJSON);\n  }\n}\n\nfunction BasicSourceMapConsumer(sourceMapJSON) {\n  const decodedMappings = (0,react_devtools_shared_src_PerformanceLoggingUtils__WEBPACK_IMPORTED_MODULE_0__.withSyncPerfMeasurements)('Decoding source map mappings with sourcemap-codec', () => (0,sourcemap_codec__WEBPACK_IMPORTED_MODULE_1__.decode)(sourceMapJSON.mappings));\n\n  function originalPositionFor({\n    columnNumber,\n    lineNumber\n  }) {\n    // Error.prototype.stack columns are 1-based (like most IDEs) but ASTs are 0-based.\n    const targetColumnNumber = columnNumber - 1;\n    const lineMappings = decodedMappings[lineNumber - 1];\n    let nearestEntry = null;\n    let startIndex = 0;\n    let stopIndex = lineMappings.length - 1;\n    let index = -1;\n\n    while (startIndex <= stopIndex) {\n      index = Math.floor((stopIndex + startIndex) / 2);\n      nearestEntry = lineMappings[index];\n      const currentColumn = nearestEntry[0];\n\n      if (currentColumn === targetColumnNumber) {\n        break;\n      } else {\n        if (currentColumn > targetColumnNumber) {\n          if (stopIndex - index > 0) {\n            stopIndex = index;\n          } else {\n            index = stopIndex;\n            break;\n          }\n        } else {\n          if (index - startIndex > 0) {\n            startIndex = index;\n          } else {\n            index = startIndex;\n            break;\n          }\n        }\n      }\n    } // We have found either the exact element, or the next-closest element.\n    // However there may be more than one such element.\n    // Make sure we always return the smallest of these.\n\n\n    while (index > 0) {\n      const previousEntry = lineMappings[index - 1];\n      const currentColumn = previousEntry[0];\n\n      if (currentColumn !== targetColumnNumber) {\n        break;\n      }\n\n      index--;\n    }\n\n    if (nearestEntry == null) {\n      // TODO maybe fall back to the runtime source instead of throwing?\n      throw Error(`Could not find runtime location for line:${lineNumber} and column:${columnNumber}`);\n    }\n\n    const sourceIndex = nearestEntry[1];\n    const sourceContent = sourceMapJSON.sourcesContent != null ? sourceMapJSON.sourcesContent[sourceIndex] : null;\n    const sourceURL = sourceMapJSON.sources[sourceIndex] ?? null;\n    const line = nearestEntry[2] + 1;\n    const column = nearestEntry[3];\n    return {\n      column,\n      line,\n      sourceContent: sourceContent,\n      sourceURL: sourceURL\n    };\n  }\n\n  return {\n    originalPositionFor\n  };\n}\n\nfunction IndexedSourceMapConsumer(sourceMapJSON) {\n  let lastOffset = {\n    line: -1,\n    column: 0\n  };\n  const sections = sourceMapJSON.sections.map(section => {\n    const offset = section.offset;\n    const offsetLine = offset.line;\n    const offsetColumn = offset.column;\n\n    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n\n    lastOffset = offset;\n    return {\n      // The offset fields are 0-based, but we use 1-based indices when encoding/decoding from VLQ.\n      generatedLine: offsetLine + 1,\n      generatedColumn: offsetColumn + 1,\n      map: section.map,\n      sourceMapConsumer: null\n    };\n  });\n\n  function originalPositionFor({\n    columnNumber,\n    lineNumber\n  }) {\n    // Error.prototype.stack columns are 1-based (like most IDEs) but ASTs are 0-based.\n    const targetColumnNumber = columnNumber - 1;\n    let section = null;\n    let startIndex = 0;\n    let stopIndex = sections.length - 1;\n    let index = -1;\n\n    while (startIndex <= stopIndex) {\n      index = Math.floor((stopIndex + startIndex) / 2);\n      section = sections[index];\n      const currentLine = section.generatedLine;\n\n      if (currentLine === lineNumber) {\n        const currentColumn = section.generatedColumn;\n\n        if (currentColumn === lineNumber) {\n          break;\n        } else {\n          if (currentColumn > targetColumnNumber) {\n            if (stopIndex - index > 0) {\n              stopIndex = index;\n            } else {\n              index = stopIndex;\n              break;\n            }\n          } else {\n            if (index - startIndex > 0) {\n              startIndex = index;\n            } else {\n              index = startIndex;\n              break;\n            }\n          }\n        }\n      } else {\n        if (currentLine > lineNumber) {\n          if (stopIndex - index > 0) {\n            stopIndex = index;\n          } else {\n            index = stopIndex;\n            break;\n          }\n        } else {\n          if (index - startIndex > 0) {\n            startIndex = index;\n          } else {\n            index = startIndex;\n            break;\n          }\n        }\n      }\n    }\n\n    if (section == null) {\n      // TODO maybe fall back to the runtime source instead of throwing?\n      throw Error(`Could not find matching section for line:${lineNumber} and column:${columnNumber}`);\n    }\n\n    if (section.sourceMapConsumer === null) {\n      // Lazily parse the section only when it's needed.\n      // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n      section.sourceMapConsumer = new SourceMapConsumer(section.map);\n    }\n\n    return section.sourceMapConsumer.originalPositionFor({\n      columnNumber,\n      lineNumber\n    });\n  }\n\n  return {\n    originalPositionFor\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9ob29rcy9Tb3VyY2VNYXBDb25zdW1lci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBMkJBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBREE7QUFHQTs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBREE7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9ob29rcy9Tb3VyY2VNYXBDb25zdW1lci5qcz9mZGU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5pbXBvcnQge3dpdGhTeW5jUGVyZk1lYXN1cmVtZW50c30gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9QZXJmb3JtYW5jZUxvZ2dpbmdVdGlscyc7XG5pbXBvcnQge2RlY29kZX0gZnJvbSAnc291cmNlbWFwLWNvZGVjJztcblxuaW1wb3J0IHR5cGUge1xuICBJbmRleFNvdXJjZU1hcCxcbiAgSW5kZXhTb3VyY2VNYXBTZWN0aW9uLFxuICBCYXNpY1NvdXJjZU1hcCxcbiAgTWl4ZWRTb3VyY2VNYXAsXG59IGZyb20gJy4vU291cmNlTWFwVHlwZXMnO1xuXG50eXBlIFNlYXJjaFBvc2l0aW9uID0ge1xuICBjb2x1bW5OdW1iZXI6IG51bWJlcixcbiAgbGluZU51bWJlcjogbnVtYmVyLFxufTtcblxudHlwZSBSZXN1bHRQb3NpdGlvbiA9IHtcbiAgY29sdW1uOiBudW1iZXIsXG4gIGxpbmU6IG51bWJlcixcbiAgc291cmNlQ29udGVudDogc3RyaW5nIHwgbnVsbCxcbiAgc291cmNlVVJMOiBzdHJpbmcgfCBudWxsLFxufTtcblxuZXhwb3J0IHR5cGUgU291cmNlTWFwQ29uc3VtZXJUeXBlID0ge1xuICBvcmlnaW5hbFBvc2l0aW9uRm9yOiBTZWFyY2hQb3NpdGlvbiA9PiBSZXN1bHRQb3NpdGlvbixcbn07XG5cbnR5cGUgTWFwcGluZ3MgPSBBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj47XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKFxuICBzb3VyY2VNYXBKU09OOiBNaXhlZFNvdXJjZU1hcCB8IEluZGV4U291cmNlTWFwU2VjdGlvbixcbik6IFNvdXJjZU1hcENvbnN1bWVyVHlwZSB7XG4gIGlmIChzb3VyY2VNYXBKU09OLnNlY3Rpb25zICE9IG51bGwpIHtcbiAgICByZXR1cm4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKCgoc291cmNlTWFwSlNPTjogYW55KTogSW5kZXhTb3VyY2VNYXApKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lcigoKHNvdXJjZU1hcEpTT046IGFueSk6IEJhc2ljU291cmNlTWFwKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXBKU09OOiBCYXNpY1NvdXJjZU1hcCkge1xuICBjb25zdCBkZWNvZGVkTWFwcGluZ3M6IE1hcHBpbmdzID0gd2l0aFN5bmNQZXJmTWVhc3VyZW1lbnRzKFxuICAgICdEZWNvZGluZyBzb3VyY2UgbWFwIG1hcHBpbmdzIHdpdGggc291cmNlbWFwLWNvZGVjJyxcbiAgICAoKSA9PiBkZWNvZGUoc291cmNlTWFwSlNPTi5tYXBwaW5ncyksXG4gICk7XG5cbiAgZnVuY3Rpb24gb3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgY29sdW1uTnVtYmVyLFxuICAgIGxpbmVOdW1iZXIsXG4gIH06IFNlYXJjaFBvc2l0aW9uKTogUmVzdWx0UG9zaXRpb24ge1xuICAgIC8vIEVycm9yLnByb3RvdHlwZS5zdGFjayBjb2x1bW5zIGFyZSAxLWJhc2VkIChsaWtlIG1vc3QgSURFcykgYnV0IEFTVHMgYXJlIDAtYmFzZWQuXG4gICAgY29uc3QgdGFyZ2V0Q29sdW1uTnVtYmVyID0gY29sdW1uTnVtYmVyIC0gMTtcblxuICAgIGNvbnN0IGxpbmVNYXBwaW5ncyA9IGRlY29kZWRNYXBwaW5nc1tsaW5lTnVtYmVyIC0gMV07XG5cbiAgICBsZXQgbmVhcmVzdEVudHJ5ID0gbnVsbDtcblxuICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICBsZXQgc3RvcEluZGV4ID0gbGluZU1hcHBpbmdzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgd2hpbGUgKHN0YXJ0SW5kZXggPD0gc3RvcEluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGguZmxvb3IoKHN0b3BJbmRleCArIHN0YXJ0SW5kZXgpIC8gMik7XG4gICAgICBuZWFyZXN0RW50cnkgPSBsaW5lTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBjb25zdCBjdXJyZW50Q29sdW1uID0gbmVhcmVzdEVudHJ5WzBdO1xuICAgICAgaWYgKGN1cnJlbnRDb2x1bW4gPT09IHRhcmdldENvbHVtbk51bWJlcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29sdW1uID4gdGFyZ2V0Q29sdW1uTnVtYmVyKSB7XG4gICAgICAgICAgaWYgKHN0b3BJbmRleCAtIGluZGV4ID4gMCkge1xuICAgICAgICAgICAgc3RvcEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gc3RvcEluZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbmRleCAtIHN0YXJ0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gICAgLy8gSG93ZXZlciB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoIGVsZW1lbnQuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzRW50cnkgPSBsaW5lTWFwcGluZ3NbaW5kZXggLSAxXTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb2x1bW4gPSBwcmV2aW91c0VudHJ5WzBdO1xuICAgICAgaWYgKGN1cnJlbnRDb2x1bW4gIT09IHRhcmdldENvbHVtbk51bWJlcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4LS07XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RFbnRyeSA9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPIG1heWJlIGZhbGwgYmFjayB0byB0aGUgcnVudGltZSBzb3VyY2UgaW5zdGVhZCBvZiB0aHJvd2luZz9cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGZpbmQgcnVudGltZSBsb2NhdGlvbiBmb3IgbGluZToke2xpbmVOdW1iZXJ9IGFuZCBjb2x1bW46JHtjb2x1bW5OdW1iZXJ9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlSW5kZXggPSBuZWFyZXN0RW50cnlbMV07XG4gICAgY29uc3Qgc291cmNlQ29udGVudCA9XG4gICAgICBzb3VyY2VNYXBKU09OLnNvdXJjZXNDb250ZW50ICE9IG51bGxcbiAgICAgICAgPyBzb3VyY2VNYXBKU09OLnNvdXJjZXNDb250ZW50W3NvdXJjZUluZGV4XVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3Qgc291cmNlVVJMID0gc291cmNlTWFwSlNPTi5zb3VyY2VzW3NvdXJjZUluZGV4XSA/PyBudWxsO1xuICAgIGNvbnN0IGxpbmUgPSBuZWFyZXN0RW50cnlbMl0gKyAxO1xuICAgIGNvbnN0IGNvbHVtbiA9IG5lYXJlc3RFbnRyeVszXTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW4sXG4gICAgICBsaW5lLFxuICAgICAgc291cmNlQ29udGVudDogKChzb3VyY2VDb250ZW50OiBhbnkpOiBzdHJpbmcgfCBudWxsKSxcbiAgICAgIHNvdXJjZVVSTDogKChzb3VyY2VVUkw6IGFueSk6IHN0cmluZyB8IG51bGwpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gKCh7XG4gICAgb3JpZ2luYWxQb3NpdGlvbkZvcixcbiAgfTogYW55KTogU291cmNlTWFwQ29uc3VtZXJUeXBlKTtcbn1cblxudHlwZSBTZWN0aW9uID0ge1xuICArZ2VuZXJhdGVkQ29sdW1uOiBudW1iZXIsXG4gICtnZW5lcmF0ZWRMaW5lOiBudW1iZXIsXG4gICttYXA6IE1peGVkU291cmNlTWFwLFxuXG4gIC8vIExhemlseSBwYXJzZWQgb25seSB3aGVuL2FzIHRoZSBzZWN0aW9uIGlzIG5lZWRlZC5cbiAgc291cmNlTWFwQ29uc3VtZXI6IFNvdXJjZU1hcENvbnN1bWVyVHlwZSB8IG51bGwsXG59O1xuXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwSlNPTjogSW5kZXhTb3VyY2VNYXApIHtcbiAgbGV0IGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwLFxuICB9O1xuXG4gIGNvbnN0IHNlY3Rpb25zOiBBcnJheTxTZWN0aW9uPiA9IHNvdXJjZU1hcEpTT04uc2VjdGlvbnMubWFwKHNlY3Rpb24gPT4ge1xuICAgIGNvbnN0IG9mZnNldCA9IHNlY3Rpb24ub2Zmc2V0O1xuICAgIGNvbnN0IG9mZnNldExpbmUgPSBvZmZzZXQubGluZTtcbiAgICBjb25zdCBvZmZzZXRDb2x1bW4gPSBvZmZzZXQuY29sdW1uO1xuXG4gICAgaWYgKFxuICAgICAgb2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW4gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMSxcbiAgICAgIG1hcDogc2VjdGlvbi5tYXAsXG4gICAgICBzb3VyY2VNYXBDb25zdW1lcjogbnVsbCxcbiAgICB9O1xuICB9KTtcblxuICBmdW5jdGlvbiBvcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICBjb2x1bW5OdW1iZXIsXG4gICAgbGluZU51bWJlcixcbiAgfTogU2VhcmNoUG9zaXRpb24pOiBSZXN1bHRQb3NpdGlvbiB7XG4gICAgLy8gRXJyb3IucHJvdG90eXBlLnN0YWNrIGNvbHVtbnMgYXJlIDEtYmFzZWQgKGxpa2UgbW9zdCBJREVzKSBidXQgQVNUcyBhcmUgMC1iYXNlZC5cbiAgICBjb25zdCB0YXJnZXRDb2x1bW5OdW1iZXIgPSBjb2x1bW5OdW1iZXIgLSAxO1xuXG4gICAgbGV0IHNlY3Rpb24gPSBudWxsO1xuXG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgIGxldCBzdG9wSW5kZXggPSBzZWN0aW9ucy5sZW5ndGggLSAxO1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIHdoaWxlIChzdGFydEluZGV4IDw9IHN0b3BJbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzdG9wSW5kZXggKyBzdGFydEluZGV4KSAvIDIpO1xuICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zW2luZGV4XTtcblxuICAgICAgY29uc3QgY3VycmVudExpbmUgPSBzZWN0aW9uLmdlbmVyYXRlZExpbmU7XG4gICAgICBpZiAoY3VycmVudExpbmUgPT09IGxpbmVOdW1iZXIpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbHVtbiA9IHNlY3Rpb24uZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICBpZiAoY3VycmVudENvbHVtbiA9PT0gbGluZU51bWJlcikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjdXJyZW50Q29sdW1uID4gdGFyZ2V0Q29sdW1uTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoc3RvcEluZGV4IC0gaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgIHN0b3BJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBzdG9wSW5kZXg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggLSBzdGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lID4gbGluZU51bWJlcikge1xuICAgICAgICAgIGlmIChzdG9wSW5kZXggLSBpbmRleCA+IDApIHtcbiAgICAgICAgICAgIHN0b3BJbmRleCA9IGluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IHN0b3BJbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaW5kZXggLSBzdGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VjdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPIG1heWJlIGZhbGwgYmFjayB0byB0aGUgcnVudGltZSBzb3VyY2UgaW5zdGVhZCBvZiB0aHJvd2luZz9cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGZpbmQgbWF0Y2hpbmcgc2VjdGlvbiBmb3IgbGluZToke2xpbmVOdW1iZXJ9IGFuZCBjb2x1bW46JHtjb2x1bW5OdW1iZXJ9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHNlY3Rpb24uc291cmNlTWFwQ29uc3VtZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIExhemlseSBwYXJzZSB0aGUgc2VjdGlvbiBvbmx5IHdoZW4gaXQncyBuZWVkZWQuXG4gICAgICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuICAgICAgc2VjdGlvbi5zb3VyY2VNYXBDb25zdW1lciA9IG5ldyBTb3VyY2VNYXBDb25zdW1lcihzZWN0aW9uLm1hcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uc291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBjb2x1bW5OdW1iZXIsXG4gICAgICBsaW5lTnVtYmVyLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuICgoe1xuICAgIG9yaWdpbmFsUG9zaXRpb25Gb3IsXG4gIH06IGFueSk6IFNvdXJjZU1hcENvbnN1bWVyVHlwZSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/hooks/SourceMapConsumer.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/hydration.js":
/*!*************************************************!*\
  !*** ../react-devtools-shared/src/hydration.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dehydrate\": () => (/* binding */ dehydrate),\n/* harmony export */   \"fillInPath\": () => (/* binding */ fillInPath),\n/* harmony export */   \"hydrate\": () => (/* binding */ hydrate),\n/* harmony export */   \"meta\": () => (/* binding */ meta)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nconst meta = {\n  inspectable: Symbol('inspectable'),\n  inspected: Symbol('inspected'),\n  name: Symbol('name'),\n  preview_long: Symbol('preview_long'),\n  preview_short: Symbol('preview_short'),\n  readonly: Symbol('readonly'),\n  size: Symbol('size'),\n  type: Symbol('type'),\n  unserializable: Symbol('unserializable')\n};\n// This threshold determines the depth at which the bridge \"dehydrates\" nested data.\n// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,\n// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).\n//\n// Reducing this threshold will improve the speed of initial component inspection,\n// but may decrease the responsiveness of expanding objects/arrays to inspect further.\nconst LEVEL_THRESHOLD = 2;\n/**\n * Generate the dehydrated metadata for complex object instances\n */\n\nfunction createDehydrated(type, inspectable, data, cleaned, path) {\n  cleaned.push(path);\n  const dehydrated = {\n    inspectable,\n    type,\n    preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n    preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n    name: typeof data.constructor !== 'function' || typeof data.constructor.name !== 'string' || data.constructor.name === 'Object' ? '' : data.constructor.name\n  };\n\n  if (type === 'array' || type === 'typed_array') {\n    dehydrated.size = data.length;\n  } else if (type === 'object') {\n    dehydrated.size = Object.keys(data).length;\n  }\n\n  if (type === 'iterator' || type === 'typed_array') {\n    dehydrated.readonly = true;\n  }\n\n  return dehydrated;\n}\n/**\n * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).\n * The paths of the stripped out objects are appended to the `cleaned` list.\n * On the other side of the barrier, the cleaned list is used to \"re-hydrate\" the cleaned representation into\n * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.\n *\n * Input: {\"some\": {\"attr\": fn()}, \"other\": AnInstance}\n * Output: {\n *   \"some\": {\n *     \"attr\": {\"name\": the fn.name, type: \"function\"}\n *   },\n *   \"other\": {\n *     \"name\": \"AnInstance\",\n *     \"type\": \"object\",\n *   },\n * }\n * and cleaned = [[\"some\", \"attr\"], [\"other\"]]\n */\n\n\nfunction dehydrate(data, cleaned, unserializable, path, isPathAllowed, level = 0) {\n  const type = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getDataType)(data);\n  let isPathAllowedCheck;\n\n  switch (type) {\n    case 'html_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.tagName,\n        type\n      };\n\n    case 'function':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,\n        type\n      };\n\n    case 'string':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (isPathAllowedCheck) {\n        return data;\n      } else {\n        return data.length <= 500 ? data : data.slice(0, 500) + '...';\n      }\n\n    case 'bigint':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'symbol':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.toString(),\n        type\n      };\n    // React Elements aren't very inspector-friendly,\n    // and often contain private fields or circular references.\n\n    case 'react_element':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getDisplayNameForReactElement)(data) || 'Unknown',\n        type\n      };\n    // ArrayBuffers error if you try to inspect them.\n\n    case 'array_buffer':\n    case 'data_view':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',\n        size: data.byteLength,\n        type\n      };\n\n    case 'array':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      }\n\n      const arr = [];\n\n      for (let i = 0; i < data.length; i++) {\n        arr[i] = dehydrateKey(data, i, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n      }\n\n      return arr;\n\n    case 'html_all_collection':\n    case 'typed_array':\n    case 'iterator':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        const unserializableValue = {\n          unserializable: true,\n          type: type,\n          readonly: true,\n          size: type === 'typed_array' ? data.length : undefined,\n          preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n          preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n          name: typeof data.constructor !== 'function' || typeof data.constructor.name !== 'string' || data.constructor.name === 'Object' ? '' : data.constructor.name\n        }; // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n\n        Array.from(data).forEach((item, i) => unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1));\n        unserializable.push(path);\n        return unserializableValue;\n      }\n\n    case 'opaque_iterator':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data[Symbol.toStringTag],\n        type\n      };\n\n    case 'date':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'regexp':\n      cleaned.push(path);\n      return {\n        inspectable: false,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: data.toString(),\n        type\n      };\n\n    case 'object':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      } else {\n        const object = {};\n        (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getAllEnumerableKeys)(data).forEach(key => {\n          const name = key.toString();\n          object[name] = dehydrateKey(data, key, cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n        });\n        return object;\n      }\n\n    case 'class_instance':\n      isPathAllowedCheck = isPathAllowed(path);\n\n      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {\n        return createDehydrated(type, true, data, cleaned, path);\n      }\n\n      const value = {\n        unserializable: true,\n        type,\n        readonly: true,\n        preview_short: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, false),\n        preview_long: (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.formatDataForPreview)(data, true),\n        name: typeof data.constructor !== 'function' || typeof data.constructor.name !== 'string' ? '' : data.constructor.name\n      };\n      (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getAllEnumerableKeys)(data).forEach(key => {\n        const keyAsString = key.toString();\n        value[keyAsString] = dehydrate(data[key], cleaned, unserializable, path.concat([keyAsString]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);\n      });\n      unserializable.push(path);\n      return value;\n\n    case 'infinity':\n    case 'nan':\n    case 'undefined':\n      // Some values are lossy when sent through a WebSocket.\n      // We dehydrate+rehydrate them to preserve their type.\n      cleaned.push(path);\n      return {\n        type\n      };\n\n    default:\n      return data;\n  }\n}\n\nfunction dehydrateKey(parent, key, cleaned, unserializable, path, isPathAllowed, level = 0) {\n  try {\n    return dehydrate(parent[key], cleaned, unserializable, path, isPathAllowed, level);\n  } catch (error) {\n    let preview = '';\n\n    if (typeof error === 'object' && error !== null && typeof error.stack === 'string') {\n      preview = error.stack;\n    } else if (typeof error === 'string') {\n      preview = error;\n    }\n\n    cleaned.push(path);\n    return {\n      inspectable: false,\n      preview_short: '[Exception]',\n      preview_long: preview ? '[Exception: ' + preview + ']' : '[Exception]',\n      name: preview,\n      type: 'unknown'\n    };\n  }\n}\n\nfunction fillInPath(object, data, path, value) {\n  const target = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getInObject)(object, path);\n\n  if (target != null) {\n    if (!target[meta.unserializable]) {\n      delete target[meta.inspectable];\n      delete target[meta.inspected];\n      delete target[meta.name];\n      delete target[meta.preview_long];\n      delete target[meta.preview_short];\n      delete target[meta.readonly];\n      delete target[meta.size];\n      delete target[meta.type];\n    }\n  }\n\n  if (value !== null && data.unserializable.length > 0) {\n    const unserializablePath = data.unserializable[0];\n    let isMatch = unserializablePath.length === path.length;\n\n    for (let i = 0; i < path.length; i++) {\n      if (path[i] !== unserializablePath[i]) {\n        isMatch = false;\n        break;\n      }\n    }\n\n    if (isMatch) {\n      upgradeUnserializable(value, value);\n    }\n  }\n\n  (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.setInObject)(object, path, value);\n}\nfunction hydrate(object, cleaned, unserializable) {\n  cleaned.forEach(path => {\n    const length = path.length;\n    const last = path[length - 1];\n    const parent = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getInObject)(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    const value = parent[last];\n\n    if (!value) {\n      return;\n    } else if (value.type === 'infinity') {\n      parent[last] = Infinity;\n    } else if (value.type === 'nan') {\n      parent[last] = NaN;\n    } else if (value.type === 'undefined') {\n      parent[last] = undefined;\n    } else {\n      // Replace the string keys with Symbols so they're non-enumerable.\n      const replaced = {};\n      replaced[meta.inspectable] = !!value.inspectable;\n      replaced[meta.inspected] = false;\n      replaced[meta.name] = value.name;\n      replaced[meta.preview_long] = value.preview_long;\n      replaced[meta.preview_short] = value.preview_short;\n      replaced[meta.size] = value.size;\n      replaced[meta.readonly] = !!value.readonly;\n      replaced[meta.type] = value.type;\n      parent[last] = replaced;\n    }\n  });\n  unserializable.forEach(path => {\n    const length = path.length;\n    const last = path[length - 1];\n    const parent = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.getInObject)(object, path.slice(0, length - 1));\n\n    if (!parent || !parent.hasOwnProperty(last)) {\n      return;\n    }\n\n    const node = parent[last];\n    const replacement = { ...node\n    };\n    upgradeUnserializable(replacement, node);\n    parent[last] = replacement;\n  });\n  return object;\n}\n\nfunction upgradeUnserializable(destination, source) {\n  Object.defineProperties(destination, {\n    // $FlowFixMe[invalid-computed-prop]\n    [meta.inspected]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.inspected\n    },\n    // $FlowFixMe[invalid-computed-prop]\n    [meta.name]: {\n      configurable: true,\n      enumerable: false,\n      value: source.name\n    },\n    // $FlowFixMe[invalid-computed-prop]\n    [meta.preview_long]: {\n      configurable: true,\n      enumerable: false,\n      value: source.preview_long\n    },\n    // $FlowFixMe[invalid-computed-prop]\n    [meta.preview_short]: {\n      configurable: true,\n      enumerable: false,\n      value: source.preview_short\n    },\n    // $FlowFixMe[invalid-computed-prop]\n    [meta.size]: {\n      configurable: true,\n      enumerable: false,\n      value: source.size\n    },\n    // $FlowFixMe[invalid-computed-prop]\n    [meta.readonly]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.readonly\n    },\n    // $FlowFixMe[invalid-computed-prop]\n    [meta.type]: {\n      configurable: true,\n      enumerable: false,\n      value: source.type\n    },\n    // $FlowFixMe[invalid-computed-prop]\n    [meta.unserializable]: {\n      configurable: true,\n      enumerable: false,\n      value: !!source.unserializable\n    }\n  });\n  delete destination.inspected;\n  delete destination.name;\n  delete destination.preview_long;\n  delete destination.preview_short;\n  delete destination.size;\n  delete destination.readonly;\n  delete destination.type;\n  delete destination.unserializable;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9oeWRyYXRpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUdBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBUUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBUkE7O0FBV0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7O0FBU0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQVNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQWdCQTtBQUNBO0FBQ0E7O0FBQ0E7QUFZQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBUUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBYUE7QUFDQTtBQUVBO0FBUUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBL09BO0FBaVBBOztBQUVBO0FBU0E7QUFDQTtBQVFBO0FBQ0E7O0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTs7QUFFQTtBQU1BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUE1Q0E7QUFtREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2h5ZHJhdGlvbi5qcz8wYjdhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7XG4gIGdldERhdGFUeXBlLFxuICBnZXREaXNwbGF5TmFtZUZvclJlYWN0RWxlbWVudCxcbiAgZ2V0QWxsRW51bWVyYWJsZUtleXMsXG4gIGdldEluT2JqZWN0LFxuICBmb3JtYXREYXRhRm9yUHJldmlldyxcbiAgc2V0SW5PYmplY3QsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdXRpbHMnO1xuXG5pbXBvcnQgdHlwZSB7XG4gIERlaHlkcmF0ZWREYXRhLFxuICBJbnNwZWN0ZWRFbGVtZW50UGF0aCxcbn0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9mcm9udGVuZC90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBtZXRhID0ge1xuICBpbnNwZWN0YWJsZTogKFN5bWJvbCgnaW5zcGVjdGFibGUnKTogc3ltYm9sKSxcbiAgaW5zcGVjdGVkOiAoU3ltYm9sKCdpbnNwZWN0ZWQnKTogc3ltYm9sKSxcbiAgbmFtZTogKFN5bWJvbCgnbmFtZScpOiBzeW1ib2wpLFxuICBwcmV2aWV3X2xvbmc6IChTeW1ib2woJ3ByZXZpZXdfbG9uZycpOiBzeW1ib2wpLFxuICBwcmV2aWV3X3Nob3J0OiAoU3ltYm9sKCdwcmV2aWV3X3Nob3J0Jyk6IHN5bWJvbCksXG4gIHJlYWRvbmx5OiAoU3ltYm9sKCdyZWFkb25seScpOiBzeW1ib2wpLFxuICBzaXplOiAoU3ltYm9sKCdzaXplJyk6IHN5bWJvbCksXG4gIHR5cGU6IChTeW1ib2woJ3R5cGUnKTogc3ltYm9sKSxcbiAgdW5zZXJpYWxpemFibGU6IChTeW1ib2woJ3Vuc2VyaWFsaXphYmxlJyk6IHN5bWJvbCksXG59O1xuXG5leHBvcnQgdHlwZSBEZWh5ZHJhdGVkID0ge1xuICBpbnNwZWN0YWJsZTogYm9vbGVhbixcbiAgbmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgcHJldmlld19sb25nOiBzdHJpbmcgfCBudWxsLFxuICBwcmV2aWV3X3Nob3J0OiBzdHJpbmcgfCBudWxsLFxuICByZWFkb25seT86IGJvb2xlYW4sXG4gIHNpemU/OiBudW1iZXIsXG4gIHR5cGU6IHN0cmluZyxcbn07XG5cbi8vIFR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29tcGxleCBpdGVyYXRhYmxlIG9iamVjdHMgKGUuZy4gTWFwLCBTZXQsIEltbXV0YWJsZUpTKSBuZWVkIHNwZWNpYWwgaGFuZGxpbmcuXG4vLyBUaGVzZSBvYmplY3RzIGNhbid0IGJlIHNlcmlhbGl6ZWQgd2l0aG91dCBsb3NpbmcgdHlwZSBpbmZvcm1hdGlvbixcbi8vIHNvIGEgXCJVbnNlcmlhbGl6YWJsZVwiIHR5cGUgd3JhcHBlciBpcyB1c2VkICh3aXRoIG1ldGEtZGF0YSBrZXlzKSB0byBzZW5kIG5lc3RlZCB2YWx1ZXMtXG4vLyB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCB0eXBlIGFuZCBuYW1lLlxuZXhwb3J0IHR5cGUgVW5zZXJpYWxpemFibGUgPSB7XG4gIG5hbWU6IHN0cmluZyB8IG51bGwsXG4gIHByZXZpZXdfbG9uZzogc3RyaW5nIHwgbnVsbCxcbiAgcHJldmlld19zaG9ydDogc3RyaW5nIHwgbnVsbCxcbiAgcmVhZG9ubHk/OiBib29sZWFuLFxuICBzaXplPzogbnVtYmVyLFxuICB0eXBlOiBzdHJpbmcsXG4gIHVuc2VyaWFsaXphYmxlOiBib29sZWFuLFxuICBbc3RyaW5nIHwgbnVtYmVyXTogYW55LFxufTtcblxuLy8gVGhpcyB0aHJlc2hvbGQgZGV0ZXJtaW5lcyB0aGUgZGVwdGggYXQgd2hpY2ggdGhlIGJyaWRnZSBcImRlaHlkcmF0ZXNcIiBuZXN0ZWQgZGF0YS5cbi8vIERlaHlkcmF0aW9uIG1lYW5zIHRoYXQgd2UgZG9uJ3Qgc2VyaWFsaXplIHRoZSBkYXRhIGZvciBlLmcuIHBvc3RNZXNzYWdlIG9yIHN0cmluZ2lmeSxcbi8vIHVubGVzcyB0aGUgZnJvbnRlbmQgZXhwbGljaXRseSByZXF1ZXN0cyBpdCAoZS5nLiBhIHVzZXIgY2xpY2tzIHRvIGV4cGFuZCBhIHByb3BzIG9iamVjdCkuXG4vL1xuLy8gUmVkdWNpbmcgdGhpcyB0aHJlc2hvbGQgd2lsbCBpbXByb3ZlIHRoZSBzcGVlZCBvZiBpbml0aWFsIGNvbXBvbmVudCBpbnNwZWN0aW9uLFxuLy8gYnV0IG1heSBkZWNyZWFzZSB0aGUgcmVzcG9uc2l2ZW5lc3Mgb2YgZXhwYW5kaW5nIG9iamVjdHMvYXJyYXlzIHRvIGluc3BlY3QgZnVydGhlci5cbmNvbnN0IExFVkVMX1RIUkVTSE9MRCA9IDI7XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIGRlaHlkcmF0ZWQgbWV0YWRhdGEgZm9yIGNvbXBsZXggb2JqZWN0IGluc3RhbmNlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVEZWh5ZHJhdGVkKFxuICB0eXBlOiBzdHJpbmcsXG4gIGluc3BlY3RhYmxlOiBib29sZWFuLFxuICBkYXRhOiBPYmplY3QsXG4gIGNsZWFuZWQ6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuKTogRGVoeWRyYXRlZCB7XG4gIGNsZWFuZWQucHVzaChwYXRoKTtcblxuICBjb25zdCBkZWh5ZHJhdGVkOiBEZWh5ZHJhdGVkID0ge1xuICAgIGluc3BlY3RhYmxlLFxuICAgIHR5cGUsXG4gICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgbmFtZTpcbiAgICAgIHR5cGVvZiBkYXRhLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0J1xuICAgICAgICA/ICcnXG4gICAgICAgIDogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lLFxuICB9O1xuXG4gIGlmICh0eXBlID09PSAnYXJyYXknIHx8IHR5cGUgPT09ICd0eXBlZF9hcnJheScpIHtcbiAgICBkZWh5ZHJhdGVkLnNpemUgPSBkYXRhLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGRlaHlkcmF0ZWQuc2l6ZSA9IE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnaXRlcmF0b3InIHx8IHR5cGUgPT09ICd0eXBlZF9hcnJheScpIHtcbiAgICBkZWh5ZHJhdGVkLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWh5ZHJhdGVkO1xufVxuXG4vKipcbiAqIFN0cmlwIG91dCBjb21wbGV4IGRhdGEgKGluc3RhbmNlcywgZnVuY3Rpb25zLCBhbmQgZGF0YSBuZXN0ZWQgPiBMRVZFTF9USFJFU0hPTEQgbGV2ZWxzIGRlZXApLlxuICogVGhlIHBhdGhzIG9mIHRoZSBzdHJpcHBlZCBvdXQgb2JqZWN0cyBhcmUgYXBwZW5kZWQgdG8gdGhlIGBjbGVhbmVkYCBsaXN0LlxuICogT24gdGhlIG90aGVyIHNpZGUgb2YgdGhlIGJhcnJpZXIsIHRoZSBjbGVhbmVkIGxpc3QgaXMgdXNlZCB0byBcInJlLWh5ZHJhdGVcIiB0aGUgY2xlYW5lZCByZXByZXNlbnRhdGlvbiBpbnRvXG4gKiBhbiBvYmplY3Qgd2l0aCBzeW1ib2xzIGFzIGF0dHJpYnV0ZXMsIHNvIHRoYXQgYSBzYW5pdGl6ZWQgb2JqZWN0IGNhbiBiZSBkaXN0aW5ndWlzaGVkIGZyb20gYSBub3JtYWwgb2JqZWN0LlxuICpcbiAqIElucHV0OiB7XCJzb21lXCI6IHtcImF0dHJcIjogZm4oKX0sIFwib3RoZXJcIjogQW5JbnN0YW5jZX1cbiAqIE91dHB1dDoge1xuICogICBcInNvbWVcIjoge1xuICogICAgIFwiYXR0clwiOiB7XCJuYW1lXCI6IHRoZSBmbi5uYW1lLCB0eXBlOiBcImZ1bmN0aW9uXCJ9XG4gKiAgIH0sXG4gKiAgIFwib3RoZXJcIjoge1xuICogICAgIFwibmFtZVwiOiBcIkFuSW5zdGFuY2VcIixcbiAqICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAqICAgfSxcbiAqIH1cbiAqIGFuZCBjbGVhbmVkID0gW1tcInNvbWVcIiwgXCJhdHRyXCJdLCBbXCJvdGhlclwiXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlaHlkcmF0ZShcbiAgZGF0YTogT2JqZWN0LFxuICBjbGVhbmVkOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PixcbiAgdW5zZXJpYWxpemFibGU6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICBpc1BhdGhBbGxvd2VkOiAocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikgPT4gYm9vbGVhbixcbiAgbGV2ZWw6IG51bWJlciA9IDAsXG4pOiAkUHJvcGVydHlUeXBlPERlaHlkcmF0ZWREYXRhLCAnZGF0YSc+IHtcbiAgY29uc3QgdHlwZSA9IGdldERhdGFUeXBlKGRhdGEpO1xuXG4gIGxldCBpc1BhdGhBbGxvd2VkQ2hlY2s7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaHRtbF9lbGVtZW50JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhLnRhZ05hbWUsXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6XG4gICAgICAgICAgdHlwZW9mIGRhdGEubmFtZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhZGF0YS5uYW1lXG4gICAgICAgICAgICA/ICdmdW5jdGlvbidcbiAgICAgICAgICAgIDogZGF0YS5uYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuICAgICAgaWYgKGlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA8PSA1MDAgPyBkYXRhIDogZGF0YS5zbGljZSgwLCA1MDApICsgJy4uLic7XG4gICAgICB9XG5cbiAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZSxcbiAgICAgIH07XG5cbiAgICAvLyBSZWFjdCBFbGVtZW50cyBhcmVuJ3QgdmVyeSBpbnNwZWN0b3ItZnJpZW5kbHksXG4gICAgLy8gYW5kIG9mdGVuIGNvbnRhaW4gcHJpdmF0ZSBmaWVsZHMgb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgICBjYXNlICdyZWFjdF9lbGVtZW50JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBnZXREaXNwbGF5TmFtZUZvclJlYWN0RWxlbWVudChkYXRhKSB8fCAnVW5rbm93bicsXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgLy8gQXJyYXlCdWZmZXJzIGVycm9yIGlmIHlvdSB0cnkgdG8gaW5zcGVjdCB0aGVtLlxuICAgIGNhc2UgJ2FycmF5X2J1ZmZlcic6XG4gICAgY2FzZSAnZGF0YV92aWV3JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiB0eXBlID09PSAnZGF0YV92aWV3JyA/ICdEYXRhVmlldycgOiAnQXJyYXlCdWZmZXInLFxuICAgICAgICBzaXplOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcbiAgICAgIGlmIChsZXZlbCA+PSBMRVZFTF9USFJFU0hPTEQgJiYgIWlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVoeWRyYXRlZCh0eXBlLCB0cnVlLCBkYXRhLCBjbGVhbmVkLCBwYXRoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFycjogQXJyYXk8T2JqZWN0PiA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGRlaHlkcmF0ZUtleShcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGksXG4gICAgICAgICAgY2xlYW5lZCxcbiAgICAgICAgICB1bnNlcmlhbGl6YWJsZSxcbiAgICAgICAgICBwYXRoLmNvbmNhdChbaV0pLFxuICAgICAgICAgIGlzUGF0aEFsbG93ZWQsXG4gICAgICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID8gMSA6IGxldmVsICsgMSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG5cbiAgICBjYXNlICdodG1sX2FsbF9jb2xsZWN0aW9uJzpcbiAgICBjYXNlICd0eXBlZF9hcnJheSc6XG4gICAgY2FzZSAnaXRlcmF0b3InOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcbiAgICAgIGlmIChsZXZlbCA+PSBMRVZFTF9USFJFU0hPTEQgJiYgIWlzUGF0aEFsbG93ZWRDaGVjaykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRGVoeWRyYXRlZCh0eXBlLCB0cnVlLCBkYXRhLCBjbGVhbmVkLCBwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHVuc2VyaWFsaXphYmxlVmFsdWU6IFVuc2VyaWFsaXphYmxlID0ge1xuICAgICAgICAgIHVuc2VyaWFsaXphYmxlOiB0cnVlLFxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgcmVhZG9ubHk6IHRydWUsXG4gICAgICAgICAgc2l6ZTogdHlwZSA9PT0gJ3R5cGVkX2FycmF5JyA/IGRhdGEubGVuZ3RoIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICAgIG5hbWU6XG4gICAgICAgICAgICB0eXBlb2YgZGF0YS5jb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGRhdGEuY29uc3RydWN0b3IubmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCdcbiAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICA6IGRhdGEuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUUklDS1lcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFsuLi5zcHJlYWRdIHN5bnRheCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAvLyBUaGlzIHByb2plY3QgdXNlcyBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1zcHJlYWQgaW4gXCJsb29zZVwiIG1vZGUgd2hpY2ggb25seSB3b3JrcyB3aXRoIEFycmF5IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXIgdHlwZXMgKGUuZy4gdHlwZWQgYXJyYXlzLCBTZXRzKSB3aWxsIG5vdCBzcHJlYWQgY29ycmVjdGx5LlxuICAgICAgICBBcnJheS5mcm9tKGRhdGEpLmZvckVhY2goXG4gICAgICAgICAgKGl0ZW0sIGkpID0+XG4gICAgICAgICAgICAodW5zZXJpYWxpemFibGVWYWx1ZVtpXSA9IGRlaHlkcmF0ZShcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgY2xlYW5lZCxcbiAgICAgICAgICAgICAgdW5zZXJpYWxpemFibGUsXG4gICAgICAgICAgICAgIHBhdGguY29uY2F0KFtpXSksXG4gICAgICAgICAgICAgIGlzUGF0aEFsbG93ZWQsXG4gICAgICAgICAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA/IDEgOiBsZXZlbCArIDEsXG4gICAgICAgICAgICApKSxcbiAgICAgICAgKTtcblxuICAgICAgICB1bnNlcmlhbGl6YWJsZS5wdXNoKHBhdGgpO1xuXG4gICAgICAgIHJldHVybiB1bnNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb3BhcXVlX2l0ZXJhdG9yJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhW1N5bWJvbC50b1N0cmluZ1RhZ10sXG4gICAgICAgIHR5cGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgfTtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvYmplY3Q6IHtcbiAgICAgICAgICBbc3RyaW5nXTogJFByb3BlcnR5VHlwZTxEZWh5ZHJhdGVkRGF0YSwgJ2RhdGEnPixcbiAgICAgICAgfSA9IHt9O1xuICAgICAgICBnZXRBbGxFbnVtZXJhYmxlS2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgIG9iamVjdFtuYW1lXSA9IGRlaHlkcmF0ZUtleShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjbGVhbmVkLFxuICAgICAgICAgICAgdW5zZXJpYWxpemFibGUsXG4gICAgICAgICAgICBwYXRoLmNvbmNhdChbbmFtZV0pLFxuICAgICAgICAgICAgaXNQYXRoQWxsb3dlZCxcbiAgICAgICAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA/IDEgOiBsZXZlbCArIDEsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICBjYXNlICdjbGFzc19pbnN0YW5jZSc6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlOiBVbnNlcmlhbGl6YWJsZSA9IHtcbiAgICAgICAgdW5zZXJpYWxpemFibGU6IHRydWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6XG4gICAgICAgICAgdHlwZW9mIGRhdGEuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICB0eXBlb2YgZGF0YS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICB9O1xuXG4gICAgICBnZXRBbGxFbnVtZXJhYmxlS2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFsdWVba2V5QXNTdHJpbmddID0gZGVoeWRyYXRlKFxuICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICBjbGVhbmVkLFxuICAgICAgICAgIHVuc2VyaWFsaXphYmxlLFxuICAgICAgICAgIHBhdGguY29uY2F0KFtrZXlBc1N0cmluZ10pLFxuICAgICAgICAgIGlzUGF0aEFsbG93ZWQsXG4gICAgICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID8gMSA6IGxldmVsICsgMSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICB1bnNlcmlhbGl6YWJsZS5wdXNoKHBhdGgpO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBjYXNlICdpbmZpbml0eSc6XG4gICAgY2FzZSAnbmFuJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgLy8gU29tZSB2YWx1ZXMgYXJlIGxvc3N5IHdoZW4gc2VudCB0aHJvdWdoIGEgV2ViU29ja2V0LlxuICAgICAgLy8gV2UgZGVoeWRyYXRlK3JlaHlkcmF0ZSB0aGVtIHRvIHByZXNlcnZlIHRoZWlyIHR5cGUuXG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge3R5cGV9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlaHlkcmF0ZUtleShcbiAgcGFyZW50OiBPYmplY3QsXG4gIGtleTogbnVtYmVyIHwgc3RyaW5nIHwgc3ltYm9sLFxuICBjbGVhbmVkOiBBcnJheTxBcnJheTxzdHJpbmcgfCBudW1iZXI+PixcbiAgdW5zZXJpYWxpemFibGU6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICBpc1BhdGhBbGxvd2VkOiAocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikgPT4gYm9vbGVhbixcbiAgbGV2ZWw6IG51bWJlciA9IDAsXG4pOiAkUHJvcGVydHlUeXBlPERlaHlkcmF0ZWREYXRhLCAnZGF0YSc+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVoeWRyYXRlKFxuICAgICAgcGFyZW50W2tleV0sXG4gICAgICBjbGVhbmVkLFxuICAgICAgdW5zZXJpYWxpemFibGUsXG4gICAgICBwYXRoLFxuICAgICAgaXNQYXRoQWxsb3dlZCxcbiAgICAgIGxldmVsLFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbGV0IHByZXZpZXcgPSAnJztcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIGVycm9yLnN0YWNrID09PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgcHJldmlldyA9IGVycm9yLnN0YWNrO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgcHJldmlldyA9IGVycm9yO1xuICAgIH1cbiAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgIHByZXZpZXdfc2hvcnQ6ICdbRXhjZXB0aW9uXScsXG4gICAgICBwcmV2aWV3X2xvbmc6IHByZXZpZXcgPyAnW0V4Y2VwdGlvbjogJyArIHByZXZpZXcgKyAnXScgOiAnW0V4Y2VwdGlvbl0nLFxuICAgICAgbmFtZTogcHJldmlldyxcbiAgICAgIHR5cGU6ICd1bmtub3duJyxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsSW5QYXRoKFxuICBvYmplY3Q6IE9iamVjdCxcbiAgZGF0YTogRGVoeWRyYXRlZERhdGEsXG4gIHBhdGg6IEluc3BlY3RlZEVsZW1lbnRQYXRoLFxuICB2YWx1ZTogYW55LFxuKSB7XG4gIGNvbnN0IHRhcmdldCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aCk7XG4gIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgIGlmICghdGFyZ2V0W21ldGEudW5zZXJpYWxpemFibGVdKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEuaW5zcGVjdGFibGVdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLmluc3BlY3RlZF07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEubmFtZV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEucHJldmlld19sb25nXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5wcmV2aWV3X3Nob3J0XTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5yZWFkb25seV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEuc2l6ZV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEudHlwZV07XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIGRhdGEudW5zZXJpYWxpemFibGUubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHVuc2VyaWFsaXphYmxlUGF0aCA9IGRhdGEudW5zZXJpYWxpemFibGVbMF07XG4gICAgbGV0IGlzTWF0Y2ggPSB1bnNlcmlhbGl6YWJsZVBhdGgubGVuZ3RoID09PSBwYXRoLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYXRoW2ldICE9PSB1bnNlcmlhbGl6YWJsZVBhdGhbaV0pIHtcbiAgICAgICAgaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZSh2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHNldEluT2JqZWN0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZShcbiAgb2JqZWN0OiBhbnksXG4gIGNsZWFuZWQ6IEFycmF5PEFycmF5PHN0cmluZyB8IG51bWJlcj4+LFxuICB1bnNlcmlhbGl6YWJsZTogQXJyYXk8QXJyYXk8c3RyaW5nIHwgbnVtYmVyPj4sXG4pOiBPYmplY3Qge1xuICBjbGVhbmVkLmZvckVhY2goKHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4pID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0ID0gcGF0aFtsZW5ndGggLSAxXTtcbiAgICBjb25zdCBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIHBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQuaGFzT3duUHJvcGVydHkobGFzdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHBhcmVudFtsYXN0XTtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICdpbmZpbml0eScpIHtcbiAgICAgIHBhcmVudFtsYXN0XSA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gJ25hbicpIHtcbiAgICAgIHBhcmVudFtsYXN0XSA9IE5hTjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxhY2UgdGhlIHN0cmluZyBrZXlzIHdpdGggU3ltYm9scyBzbyB0aGV5J3JlIG5vbi1lbnVtZXJhYmxlLlxuICAgICAgY29uc3QgcmVwbGFjZWQ6IHtba2V5OiBzeW1ib2xdOiBib29sZWFuIHwgc3RyaW5nfSA9IHt9O1xuICAgICAgcmVwbGFjZWRbbWV0YS5pbnNwZWN0YWJsZV0gPSAhIXZhbHVlLmluc3BlY3RhYmxlO1xuICAgICAgcmVwbGFjZWRbbWV0YS5pbnNwZWN0ZWRdID0gZmFsc2U7XG4gICAgICByZXBsYWNlZFttZXRhLm5hbWVdID0gdmFsdWUubmFtZTtcbiAgICAgIHJlcGxhY2VkW21ldGEucHJldmlld19sb25nXSA9IHZhbHVlLnByZXZpZXdfbG9uZztcbiAgICAgIHJlcGxhY2VkW21ldGEucHJldmlld19zaG9ydF0gPSB2YWx1ZS5wcmV2aWV3X3Nob3J0O1xuICAgICAgcmVwbGFjZWRbbWV0YS5zaXplXSA9IHZhbHVlLnNpemU7XG4gICAgICByZXBsYWNlZFttZXRhLnJlYWRvbmx5XSA9ICEhdmFsdWUucmVhZG9ubHk7XG4gICAgICByZXBsYWNlZFttZXRhLnR5cGVdID0gdmFsdWUudHlwZTtcblxuICAgICAgcGFyZW50W2xhc3RdID0gcmVwbGFjZWQ7XG4gICAgfVxuICB9KTtcbiAgdW5zZXJpYWxpemFibGUuZm9yRWFjaCgocGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPikgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5oYXNPd25Qcm9wZXJ0eShsYXN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBwYXJlbnRbbGFzdF07XG5cbiAgICBjb25zdCByZXBsYWNlbWVudCA9IHtcbiAgICAgIC4uLm5vZGUsXG4gICAgfTtcblxuICAgIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZShyZXBsYWNlbWVudCwgbm9kZSk7XG5cbiAgICBwYXJlbnRbbGFzdF0gPSByZXBsYWNlbWVudDtcbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZShkZXN0aW5hdGlvbjogT2JqZWN0LCBzb3VyY2U6IE9iamVjdCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkZXN0aW5hdGlvbiwge1xuICAgIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb21wdXRlZC1wcm9wXVxuICAgIFttZXRhLmluc3BlY3RlZF06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICEhc291cmNlLmluc3BlY3RlZCxcbiAgICB9LFxuICAgIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb21wdXRlZC1wcm9wXVxuICAgIFttZXRhLm5hbWVdOiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2UubmFtZSxcbiAgICB9LFxuICAgIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb21wdXRlZC1wcm9wXVxuICAgIFttZXRhLnByZXZpZXdfbG9uZ106IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZS5wcmV2aWV3X2xvbmcsXG4gICAgfSxcbiAgICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29tcHV0ZWQtcHJvcF1cbiAgICBbbWV0YS5wcmV2aWV3X3Nob3J0XToge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlLnByZXZpZXdfc2hvcnQsXG4gICAgfSxcbiAgICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29tcHV0ZWQtcHJvcF1cbiAgICBbbWV0YS5zaXplXToge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlLnNpemUsXG4gICAgfSxcbiAgICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29tcHV0ZWQtcHJvcF1cbiAgICBbbWV0YS5yZWFkb25seV06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6ICEhc291cmNlLnJlYWRvbmx5LFxuICAgIH0sXG4gICAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbXB1dGVkLXByb3BdXG4gICAgW21ldGEudHlwZV06IHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZS50eXBlLFxuICAgIH0sXG4gICAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbXB1dGVkLXByb3BdXG4gICAgW21ldGEudW5zZXJpYWxpemFibGVdOiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiAhIXNvdXJjZS51bnNlcmlhbGl6YWJsZSxcbiAgICB9LFxuICB9KTtcblxuICBkZWxldGUgZGVzdGluYXRpb24uaW5zcGVjdGVkO1xuICBkZWxldGUgZGVzdGluYXRpb24ubmFtZTtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnByZXZpZXdfbG9uZztcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnByZXZpZXdfc2hvcnQ7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5zaXplO1xuICBkZWxldGUgZGVzdGluYXRpb24ucmVhZG9ubHk7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi50eXBlO1xuICBkZWxldGUgZGVzdGluYXRpb24udW5zZXJpYWxpemFibGU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/hydration.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/isArray.js":
/*!***********************************************!*\
  !*** ../react-devtools-shared/src/isArray.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst isArray = Array.isArray;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArray);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9pc0FycmF5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2lzQXJyYXkuanM/YTQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/isArray.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/registerDevToolsEventLogger.js":
/*!*******************************************************************!*\
  !*** ../react-devtools-shared/src/registerDevToolsEventLogger.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"registerDevToolsEventLogger\": () => (/* binding */ registerDevToolsEventLogger)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/Logger */ \"../react-devtools-shared/src/Logger.js\");\n/* harmony import */ var react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-feature-flags */ \"../react-devtools-shared/src/config/DevToolsFeatureFlags.core-oss.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nlet currentLoggingIFrame = null;\nlet currentSessionId = null;\nlet missedEvents = [];\nfunction registerDevToolsEventLogger(surface, fetchAdditionalContext) {\n  async function logEvent(event) {\n    if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_1__.enableLogger) {\n      if (currentLoggingIFrame != null && currentSessionId != null) {\n        const {\n          metadata,\n          ...eventWithoutMetadata\n        } = event;\n        const additionalContext = fetchAdditionalContext != null ? await fetchAdditionalContext() : {};\n        currentLoggingIFrame?.contentWindow?.postMessage({\n          source: 'react-devtools-logging',\n          event: eventWithoutMetadata,\n          context: { ...additionalContext,\n            metadata: metadata != null ? JSON.stringify(metadata) : '',\n            session_id: currentSessionId,\n            surface,\n            version: \"6.0.1-2f3e83bb34\"\n          }\n        }, '*');\n      } else {\n        missedEvents.push(event);\n      }\n    }\n  }\n\n  function handleLoggingIFrameLoaded(iframe) {\n    currentLoggingIFrame = iframe;\n\n    if (missedEvents.length > 0) {\n      missedEvents.forEach(event => logEvent(event));\n      missedEvents = [];\n    }\n  } // If logger is enabled, register a logger that captures logged events\n  // and render iframe where the logged events will be reported to\n\n\n  if (react_devtools_feature_flags__WEBPACK_IMPORTED_MODULE_1__.enableLogger) {\n    const loggingUrl = \"null\";\n    const body = document.body;\n\n    if (typeof loggingUrl === 'string' && loggingUrl.length > 0 && body != null && currentLoggingIFrame == null) {\n      (0,react_devtools_shared_src_Logger__WEBPACK_IMPORTED_MODULE_0__.registerEventLogger)(logEvent);\n      currentSessionId = window.crypto.randomUUID();\n      const iframe = document.createElement('iframe');\n\n      iframe.onload = () => handleLoggingIFrameLoaded(iframe);\n\n      iframe.src = loggingUrl;\n      body.appendChild(iframe);\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9yZWdpc3RlckRldlRvb2xzRXZlbnRMb2dnZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7O0FBV0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTUE7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvcmVnaXN0ZXJEZXZUb29sc0V2ZW50TG9nZ2VyLmpzPzkxMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93IHN0cmljdC1sb2NhbFxuICovXG5cbmltcG9ydCB0eXBlIHtMb2dnZXJFdmVudH0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9Mb2dnZXInO1xuXG5pbXBvcnQge3JlZ2lzdGVyRXZlbnRMb2dnZXJ9IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvTG9nZ2VyJztcbmltcG9ydCB7ZW5hYmxlTG9nZ2VyfSBmcm9tICdyZWFjdC1kZXZ0b29scy1mZWF0dXJlLWZsYWdzJztcblxubGV0IGN1cnJlbnRMb2dnaW5nSUZyYW1lID0gbnVsbDtcbmxldCBjdXJyZW50U2Vzc2lvbklkID0gbnVsbDtcbmxldCBtaXNzZWRFdmVudHM6IEFycmF5PExvZ2dlckV2ZW50PiA9IFtdO1xuXG50eXBlIExvZ2dlckNvbnRleHQgPSB7XG4gIHBhZ2VfdXJsOiA/c3RyaW5nLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGV2VG9vbHNFdmVudExvZ2dlcihcbiAgc3VyZmFjZTogc3RyaW5nLFxuICBmZXRjaEFkZGl0aW9uYWxDb250ZXh0PzpcbiAgICB8ICgoKSA9PiBMb2dnZXJDb250ZXh0KVxuICAgIHwgKCgpID0+IFByb21pc2U8TG9nZ2VyQ29udGV4dD4pLFxuKTogdm9pZCB7XG4gIGFzeW5jIGZ1bmN0aW9uIGxvZ0V2ZW50KGV2ZW50OiBMb2dnZXJFdmVudCkge1xuICAgIGlmIChlbmFibGVMb2dnZXIpIHtcbiAgICAgIGlmIChjdXJyZW50TG9nZ2luZ0lGcmFtZSAhPSBudWxsICYmIGN1cnJlbnRTZXNzaW9uSWQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7bWV0YWRhdGEsIC4uLmV2ZW50V2l0aG91dE1ldGFkYXRhfSA9IGV2ZW50O1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ29udGV4dDogTG9nZ2VyQ29udGV4dCB8IHt9ID1cbiAgICAgICAgICBmZXRjaEFkZGl0aW9uYWxDb250ZXh0ICE9IG51bGwgPyBhd2FpdCBmZXRjaEFkZGl0aW9uYWxDb250ZXh0KCkgOiB7fTtcblxuICAgICAgICBjdXJyZW50TG9nZ2luZ0lGcmFtZT8uY29udGVudFdpbmRvdz8ucG9zdE1lc3NhZ2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgc291cmNlOiAncmVhY3QtZGV2dG9vbHMtbG9nZ2luZycsXG4gICAgICAgICAgICBldmVudDogZXZlbnRXaXRob3V0TWV0YWRhdGEsXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgIC4uLmFkZGl0aW9uYWxDb250ZXh0LFxuICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSA6ICcnLFxuICAgICAgICAgICAgICBzZXNzaW9uX2lkOiBjdXJyZW50U2Vzc2lvbklkLFxuICAgICAgICAgICAgICBzdXJmYWNlLFxuICAgICAgICAgICAgICB2ZXJzaW9uOiBwcm9jZXNzLmVudi5ERVZUT09MU19WRVJTSU9OLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgICcqJyxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pc3NlZEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVMb2dnaW5nSUZyYW1lTG9hZGVkKGlmcmFtZTogSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICBjdXJyZW50TG9nZ2luZ0lGcmFtZSA9IGlmcmFtZTtcblxuICAgIGlmIChtaXNzZWRFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgbWlzc2VkRXZlbnRzLmZvckVhY2goZXZlbnQgPT4gbG9nRXZlbnQoZXZlbnQpKTtcbiAgICAgIG1pc3NlZEV2ZW50cyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGxvZ2dlciBpcyBlbmFibGVkLCByZWdpc3RlciBhIGxvZ2dlciB0aGF0IGNhcHR1cmVzIGxvZ2dlZCBldmVudHNcbiAgLy8gYW5kIHJlbmRlciBpZnJhbWUgd2hlcmUgdGhlIGxvZ2dlZCBldmVudHMgd2lsbCBiZSByZXBvcnRlZCB0b1xuICBpZiAoZW5hYmxlTG9nZ2VyKSB7XG4gICAgY29uc3QgbG9nZ2luZ1VybCA9IHByb2Nlc3MuZW52LkxPR0dJTkdfVVJMO1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGxvZ2dpbmdVcmwgPT09ICdzdHJpbmcnICYmXG4gICAgICBsb2dnaW5nVXJsLmxlbmd0aCA+IDAgJiZcbiAgICAgIGJvZHkgIT0gbnVsbCAmJlxuICAgICAgY3VycmVudExvZ2dpbmdJRnJhbWUgPT0gbnVsbFxuICAgICkge1xuICAgICAgcmVnaXN0ZXJFdmVudExvZ2dlcihsb2dFdmVudCk7XG4gICAgICBjdXJyZW50U2Vzc2lvbklkID0gd2luZG93LmNyeXB0by5yYW5kb21VVUlEKCk7XG5cbiAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXG4gICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4gaGFuZGxlTG9nZ2luZ0lGcmFtZUxvYWRlZChpZnJhbWUpO1xuICAgICAgaWZyYW1lLnNyYyA9IGxvZ2dpbmdVcmw7XG5cbiAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/registerDevToolsEventLogger.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/storage.js":
/*!***********************************************!*\
  !*** ../react-devtools-shared/src/storage.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"localStorageGetItem\": () => (/* binding */ localStorageGetItem),\n/* harmony export */   \"localStorageRemoveItem\": () => (/* binding */ localStorageRemoveItem),\n/* harmony export */   \"localStorageSetItem\": () => (/* binding */ localStorageSetItem),\n/* harmony export */   \"sessionStorageGetItem\": () => (/* binding */ sessionStorageGetItem),\n/* harmony export */   \"sessionStorageRemoveItem\": () => (/* binding */ sessionStorageRemoveItem),\n/* harmony export */   \"sessionStorageSetItem\": () => (/* binding */ sessionStorageSetItem)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction localStorageGetItem(key) {\n  try {\n    return localStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction localStorageRemoveItem(key) {\n  try {\n    localStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction localStorageSetItem(key, value) {\n  try {\n    return localStorage.setItem(key, value);\n  } catch (error) {}\n}\nfunction sessionStorageGetItem(key) {\n  try {\n    return sessionStorage.getItem(key);\n  } catch (error) {\n    return null;\n  }\n}\nfunction sessionStorageRemoveItem(key) {\n  try {\n    sessionStorage.removeItem(key);\n  } catch (error) {}\n}\nfunction sessionStorageSetItem(key, value) {\n  try {\n    return sessionStorage.setItem(key, value);\n  } catch (error) {}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zdG9yYWdlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3MtcmVhY3QtZGV2dG9vbHMtY29yZS8uLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3N0b3JhZ2UuanM/OTRlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxTdG9yYWdlR2V0SXRlbShrZXk6IHN0cmluZyk6IGFueSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsU3RvcmFnZVJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2FsU3RvcmFnZVNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vzc2lvblN0b3JhZ2VHZXRJdGVtKGtleTogc3RyaW5nKTogYW55IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2Vzc2lvblN0b3JhZ2VTZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/storage.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/symbolicateSource.js":
/*!*********************************************************!*\
  !*** ../react-devtools-shared/src/symbolicateSource.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"symbolicateSource\": () => (/* binding */ symbolicateSource),\n/* harmony export */   \"symbolicateSourceWithCache\": () => (/* binding */ symbolicateSourceWithCache)\n/* harmony export */ });\n/* harmony import */ var react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-devtools-shared/src/utils */ \"../react-devtools-shared/src/utils.js\");\n/* harmony import */ var react_devtools_shared_src_hooks_SourceMapConsumer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-devtools-shared/src/hooks/SourceMapConsumer */ \"../react-devtools-shared/src/hooks/SourceMapConsumer.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nconst symbolicationCache = new Map();\nasync function symbolicateSourceWithCache(fetchFileWithCaching, sourceURL, line, // 1-based\ncolumn) {\n  const key = `${sourceURL}:${line}:${column}`;\n  const cachedPromise = symbolicationCache.get(key);\n\n  if (cachedPromise != null) {\n    return cachedPromise;\n  }\n\n  const promise = symbolicateSource(fetchFileWithCaching, sourceURL, line, column);\n  symbolicationCache.set(key, promise);\n  return promise;\n}\nconst SOURCE_MAP_ANNOTATION_PREFIX = 'sourceMappingURL=';\nasync function symbolicateSource(fetchFileWithCaching, sourceURL, lineNumber, // 1-based\ncolumnNumber) {\n  const resource = await fetchFileWithCaching(sourceURL).catch(() => null);\n\n  if (resource == null) {\n    return null;\n  }\n\n  const resourceLines = resource.split(/[\\r\\n]+/);\n\n  for (let i = resourceLines.length - 1; i >= 0; --i) {\n    const resourceLine = resourceLines[i]; // In case there is empty last line\n\n    if (!resourceLine) continue; // Not an annotation? Stop looking for a source mapping url.\n\n    if (!resourceLine.startsWith('//#')) break;\n\n    if (resourceLine.includes(SOURCE_MAP_ANNOTATION_PREFIX)) {\n      const sourceMapAnnotationStartIndex = resourceLine.indexOf(SOURCE_MAP_ANNOTATION_PREFIX);\n      const sourceMapAt = resourceLine.slice(sourceMapAnnotationStartIndex + SOURCE_MAP_ANNOTATION_PREFIX.length, resourceLine.length);\n      const sourceMapURL = new URL(sourceMapAt, sourceURL).toString();\n      const sourceMap = await fetchFileWithCaching(sourceMapURL).catch(() => null);\n\n      if (sourceMap != null) {\n        try {\n          const parsedSourceMap = JSON.parse(sourceMap);\n          const consumer = (0,react_devtools_shared_src_hooks_SourceMapConsumer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(parsedSourceMap);\n          const {\n            sourceURL: possiblyURL,\n            line,\n            column\n          } = consumer.originalPositionFor({\n            lineNumber,\n            // 1-based\n            columnNumber // 1-based\n\n          });\n\n          if (possiblyURL === null) {\n            return null;\n          }\n\n          try {\n            // sourceMapURL = https://react.dev/script.js.map\n            void new URL(possiblyURL); // test if it is a valid URL\n\n            const normalizedURL = (0,react_devtools_shared_src_utils__WEBPACK_IMPORTED_MODULE_0__.normalizeUrl)(possiblyURL);\n            return {\n              sourceURL: normalizedURL,\n              line,\n              column\n            };\n          } catch (e) {\n            // This is not valid URL\n            if ( // sourceMapURL = /file\n            possiblyURL.startsWith('/') || // sourceMapURL = C:\\\\...\n            possiblyURL.slice(1).startsWith(':\\\\\\\\')) {\n              // This is an absolute path\n              return {\n                sourceURL: possiblyURL,\n                line,\n                column\n              };\n            } // This is a relative path\n            // possiblyURL = x.js.map, sourceMapURL = https://react.dev/script.js.map\n\n\n            const absoluteSourcePath = new URL(possiblyURL, sourceMapURL).toString();\n            return {\n              sourceURL: absoluteSourcePath,\n              line,\n              column\n            };\n          }\n        } catch (e) {\n          return null;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  return null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zeW1ib2xpY2F0ZVNvdXJjZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUtBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBTUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUdBO0FBS0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUFBO0FBQ0E7O0FBRkE7O0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zeW1ib2xpY2F0ZVNvdXJjZS5qcz8wM2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCB7bm9ybWFsaXplVXJsfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3V0aWxzJztcbmltcG9ydCBTb3VyY2VNYXBDb25zdW1lciBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2hvb2tzL1NvdXJjZU1hcENvbnN1bWVyJztcblxuaW1wb3J0IHR5cGUge1NvdXJjZX0gZnJvbSAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge0ZldGNoRmlsZVdpdGhDYWNoaW5nfSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2RldnRvb2xzL3ZpZXdzL0NvbXBvbmVudHMvRmV0Y2hGaWxlV2l0aENhY2hpbmdDb250ZXh0JztcblxuY29uc3Qgc3ltYm9saWNhdGlvbkNhY2hlOiBNYXA8c3RyaW5nLCBQcm9taXNlPFNvdXJjZSB8IG51bGw+PiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN5bWJvbGljYXRlU291cmNlV2l0aENhY2hlKFxuICBmZXRjaEZpbGVXaXRoQ2FjaGluZzogRmV0Y2hGaWxlV2l0aENhY2hpbmcsXG4gIHNvdXJjZVVSTDogc3RyaW5nLFxuICBsaW5lOiBudW1iZXIsIC8vIDEtYmFzZWRcbiAgY29sdW1uOiBudW1iZXIsIC8vIDEtYmFzZWRcbik6IFByb21pc2U8U291cmNlIHwgbnVsbD4ge1xuICBjb25zdCBrZXkgPSBgJHtzb3VyY2VVUkx9OiR7bGluZX06JHtjb2x1bW59YDtcbiAgY29uc3QgY2FjaGVkUHJvbWlzZSA9IHN5bWJvbGljYXRpb25DYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGNhY2hlZFByb21pc2UgIT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IHN5bWJvbGljYXRlU291cmNlKFxuICAgIGZldGNoRmlsZVdpdGhDYWNoaW5nLFxuICAgIHNvdXJjZVVSTCxcbiAgICBsaW5lLFxuICAgIGNvbHVtbixcbiAgKTtcbiAgc3ltYm9saWNhdGlvbkNhY2hlLnNldChrZXksIHByb21pc2UpO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5jb25zdCBTT1VSQ0VfTUFQX0FOTk9UQVRJT05fUFJFRklYID0gJ3NvdXJjZU1hcHBpbmdVUkw9JztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW1ib2xpY2F0ZVNvdXJjZShcbiAgZmV0Y2hGaWxlV2l0aENhY2hpbmc6IEZldGNoRmlsZVdpdGhDYWNoaW5nLFxuICBzb3VyY2VVUkw6IHN0cmluZyxcbiAgbGluZU51bWJlcjogbnVtYmVyLCAvLyAxLWJhc2VkXG4gIGNvbHVtbk51bWJlcjogbnVtYmVyLCAvLyAxLWJhc2VkXG4pOiBQcm9taXNlPFNvdXJjZSB8IG51bGw+IHtcbiAgY29uc3QgcmVzb3VyY2UgPSBhd2FpdCBmZXRjaEZpbGVXaXRoQ2FjaGluZyhzb3VyY2VVUkwpLmNhdGNoKCgpID0+IG51bGwpO1xuICBpZiAocmVzb3VyY2UgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcmVzb3VyY2VMaW5lcyA9IHJlc291cmNlLnNwbGl0KC9bXFxyXFxuXSsvKTtcbiAgZm9yIChsZXQgaSA9IHJlc291cmNlTGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBjb25zdCByZXNvdXJjZUxpbmUgPSByZXNvdXJjZUxpbmVzW2ldO1xuXG4gICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBlbXB0eSBsYXN0IGxpbmVcbiAgICBpZiAoIXJlc291cmNlTGluZSkgY29udGludWU7XG4gICAgLy8gTm90IGFuIGFubm90YXRpb24/IFN0b3AgbG9va2luZyBmb3IgYSBzb3VyY2UgbWFwcGluZyB1cmwuXG4gICAgaWYgKCFyZXNvdXJjZUxpbmUuc3RhcnRzV2l0aCgnLy8jJykpIGJyZWFrO1xuXG4gICAgaWYgKHJlc291cmNlTGluZS5pbmNsdWRlcyhTT1VSQ0VfTUFQX0FOTk9UQVRJT05fUFJFRklYKSkge1xuICAgICAgY29uc3Qgc291cmNlTWFwQW5ub3RhdGlvblN0YXJ0SW5kZXggPSByZXNvdXJjZUxpbmUuaW5kZXhPZihcbiAgICAgICAgU09VUkNFX01BUF9BTk5PVEFUSU9OX1BSRUZJWCxcbiAgICAgICk7XG4gICAgICBjb25zdCBzb3VyY2VNYXBBdCA9IHJlc291cmNlTGluZS5zbGljZShcbiAgICAgICAgc291cmNlTWFwQW5ub3RhdGlvblN0YXJ0SW5kZXggKyBTT1VSQ0VfTUFQX0FOTk9UQVRJT05fUFJFRklYLmxlbmd0aCxcbiAgICAgICAgcmVzb3VyY2VMaW5lLmxlbmd0aCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZU1hcFVSTCA9IG5ldyBVUkwoc291cmNlTWFwQXQsIHNvdXJjZVVSTCkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IGF3YWl0IGZldGNoRmlsZVdpdGhDYWNoaW5nKHNvdXJjZU1hcFVSTCkuY2F0Y2goXG4gICAgICAgICgpID0+IG51bGwsXG4gICAgICApO1xuICAgICAgaWYgKHNvdXJjZU1hcCAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlTWFwID0gSlNPTi5wYXJzZShzb3VyY2VNYXApO1xuICAgICAgICAgIGNvbnN0IGNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXIocGFyc2VkU291cmNlTWFwKTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBzb3VyY2VVUkw6IHBvc3NpYmx5VVJMLFxuICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICB9ID0gY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lTnVtYmVyLCAvLyAxLWJhc2VkXG4gICAgICAgICAgICBjb2x1bW5OdW1iZXIsIC8vIDEtYmFzZWRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChwb3NzaWJseVVSTCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBzb3VyY2VNYXBVUkwgPSBodHRwczovL3JlYWN0LmRldi9zY3JpcHQuanMubWFwXG4gICAgICAgICAgICB2b2lkIG5ldyBVUkwocG9zc2libHlVUkwpOyAvLyB0ZXN0IGlmIGl0IGlzIGEgdmFsaWQgVVJMXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVVJMID0gbm9ybWFsaXplVXJsKHBvc3NpYmx5VVJMKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtzb3VyY2VVUkw6IG5vcm1hbGl6ZWRVUkwsIGxpbmUsIGNvbHVtbn07XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgdmFsaWQgVVJMXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIC8vIHNvdXJjZU1hcFVSTCA9IC9maWxlXG4gICAgICAgICAgICAgIHBvc3NpYmx5VVJMLnN0YXJ0c1dpdGgoJy8nKSB8fFxuICAgICAgICAgICAgICAvLyBzb3VyY2VNYXBVUkwgPSBDOlxcXFwuLi5cbiAgICAgICAgICAgICAgcG9zc2libHlVUkwuc2xpY2UoMSkuc3RhcnRzV2l0aCgnOlxcXFxcXFxcJylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgICAgICAgICAgcmV0dXJuIHtzb3VyY2VVUkw6IHBvc3NpYmx5VVJMLCBsaW5lLCBjb2x1bW59O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVsYXRpdmUgcGF0aFxuICAgICAgICAgICAgLy8gcG9zc2libHlVUkwgPSB4LmpzLm1hcCwgc291cmNlTWFwVVJMID0gaHR0cHM6Ly9yZWFjdC5kZXYvc2NyaXB0LmpzLm1hcFxuICAgICAgICAgICAgY29uc3QgYWJzb2x1dGVTb3VyY2VQYXRoID0gbmV3IFVSTChcbiAgICAgICAgICAgICAgcG9zc2libHlVUkwsXG4gICAgICAgICAgICAgIHNvdXJjZU1hcFVSTCxcbiAgICAgICAgICAgICkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiB7c291cmNlVVJMOiBhYnNvbHV0ZVNvdXJjZVBhdGgsIGxpbmUsIGNvbHVtbn07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/symbolicateSource.js\n");

/***/ }),

/***/ "../react-devtools-shared/src/utils.js":
/*!*********************************************!*\
  !*** ../react-devtools-shared/src/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"alphaSortKeys\": () => (/* binding */ alphaSortKeys),\n/* harmony export */   \"backendToFrontendSerializedElementMapper\": () => (/* binding */ backendToFrontendSerializedElementMapper),\n/* harmony export */   \"deletePathInObject\": () => (/* binding */ deletePathInObject),\n/* harmony export */   \"filterOutLocationComponentFilters\": () => (/* binding */ filterOutLocationComponentFilters),\n/* harmony export */   \"formatDataForPreview\": () => (/* binding */ formatDataForPreview),\n/* harmony export */   \"getAllEnumerableKeys\": () => (/* binding */ getAllEnumerableKeys),\n/* harmony export */   \"getDataType\": () => (/* binding */ getDataType),\n/* harmony export */   \"getDefaultComponentFilters\": () => (/* binding */ getDefaultComponentFilters),\n/* harmony export */   \"getDefaultOpenInEditorURL\": () => (/* binding */ getDefaultOpenInEditorURL),\n/* harmony export */   \"getDisplayName\": () => (/* binding */ getDisplayName),\n/* harmony export */   \"getDisplayNameForReactElement\": () => (/* binding */ getDisplayNameForReactElement),\n/* harmony export */   \"getIfReloadedAndProfiling\": () => (/* binding */ getIfReloadedAndProfiling),\n/* harmony export */   \"getInObject\": () => (/* binding */ getInObject),\n/* harmony export */   \"getIsReloadAndProfileSupported\": () => (/* binding */ getIsReloadAndProfileSupported),\n/* harmony export */   \"getOpenInEditorURL\": () => (/* binding */ getOpenInEditorURL),\n/* harmony export */   \"getProfilingSettings\": () => (/* binding */ getProfilingSettings),\n/* harmony export */   \"getSavedComponentFilters\": () => (/* binding */ getSavedComponentFilters),\n/* harmony export */   \"getUID\": () => (/* binding */ getUID),\n/* harmony export */   \"getWrappedDisplayName\": () => (/* binding */ getWrappedDisplayName),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"normalizeUrl\": () => (/* binding */ normalizeUrl),\n/* harmony export */   \"onReloadAndProfile\": () => (/* binding */ onReloadAndProfile),\n/* harmony export */   \"onReloadAndProfileFlagsReset\": () => (/* binding */ onReloadAndProfileFlagsReset),\n/* harmony export */   \"parseElementDisplayNameFromBackend\": () => (/* binding */ parseElementDisplayNameFromBackend),\n/* harmony export */   \"printOperationsArray\": () => (/* binding */ printOperationsArray),\n/* harmony export */   \"renamePathInObject\": () => (/* binding */ renamePathInObject),\n/* harmony export */   \"setInObject\": () => (/* binding */ setInObject),\n/* harmony export */   \"setSavedComponentFilters\": () => (/* binding */ setSavedComponentFilters),\n/* harmony export */   \"shallowDiffers\": () => (/* binding */ shallowDiffers),\n/* harmony export */   \"utfDecodeStringWithRanges\": () => (/* binding */ utfDecodeStringWithRanges),\n/* harmony export */   \"utfEncodeString\": () => (/* binding */ utfEncodeString)\n/* harmony export */ });\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ \"../../node_modules/lru-cache/index.js\");\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/ReactSymbols */ \"../shared/ReactSymbols.js\");\n/* harmony import */ var shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shared/ReactFeatureFlags */ \"../shared/ReactFeatureFlags.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"../react-devtools-shared/src/constants.js\");\n/* harmony import */ var _frontend_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-devtools-shared/src/frontend/types */ \"../react-devtools-shared/src/frontend/types.js\");\n/* harmony import */ var react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-devtools-shared/src/storage */ \"../react-devtools-shared/src/storage.js\");\n/* harmony import */ var _hydration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hydration */ \"../react-devtools-shared/src/hydration.js\");\n/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./isArray */ \"../react-devtools-shared/src/isArray.js\");\n/* harmony import */ var _backend_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./backend/utils */ \"../react-devtools-shared/src/backend/utils/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\n\n\n\n\n\n\n\n // $FlowFixMe[method-unbinding]\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.\n// Try to reuse the already encoded strings.\n\nconst encodedStringCache = new (lru_cache__WEBPACK_IMPORTED_MODULE_0___default())({\n  max: 1000\n});\nfunction alphaSortKeys(a, b) {\n  if (a.toString() > b.toString()) {\n    return 1;\n  } else if (b.toString() > a.toString()) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\nfunction getAllEnumerableKeys(obj) {\n  const keys = new Set();\n  let current = obj;\n\n  while (current != null) {\n    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];\n    const descriptors = Object.getOwnPropertyDescriptors(current);\n    currentKeys.forEach(key => {\n      // $FlowFixMe[incompatible-type]: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\n      if (descriptors[key].enumerable) {\n        keys.add(key);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  }\n\n  return keys;\n} // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37\n\nfunction getWrappedDisplayName(outerType, innerType, wrapperName, fallbackName) {\n  const displayName = outerType?.displayName;\n  return displayName || `${wrapperName}(${getDisplayName(innerType, fallbackName)})`;\n}\nfunction getDisplayName(type, fallbackName = 'Anonymous') {\n  const nameFromCache = cachedDisplayNames.get(type);\n\n  if (nameFromCache != null) {\n    return nameFromCache;\n  }\n\n  let displayName = fallbackName; // The displayName property is not guaranteed to be a string.\n  // It's only safe to use for our purposes if it's a string.\n  // github.com/facebook/react-devtools/issues/803\n\n  if (typeof type.displayName === 'string') {\n    displayName = type.displayName;\n  } else if (typeof type.name === 'string' && type.name !== '') {\n    displayName = type.name;\n  }\n\n  cachedDisplayNames.set(type, displayName);\n  return displayName;\n}\nlet uidCounter = 0;\nfunction getUID() {\n  return ++uidCounter;\n}\nfunction utfDecodeStringWithRanges(array, left, right) {\n  let string = '';\n\n  for (let i = left; i <= right; i++) {\n    string += String.fromCodePoint(array[i]);\n  }\n\n  return string;\n}\n\nfunction surrogatePairToCodePoint(charCode1, charCode2) {\n  return ((charCode1 & 0x3ff) << 10) + (charCode2 & 0x3ff) + 0x10000;\n} // Credit for this encoding approach goes to Tim Down:\n// https://stackoverflow.com/questions/4877326/how-can-i-tell-if-a-string-contains-multibyte-characters-in-javascript\n\n\nfunction utfEncodeString(string) {\n  const cached = encodedStringCache.get(string);\n\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  const encoded = [];\n  let i = 0;\n  let charCode;\n\n  while (i < string.length) {\n    charCode = string.charCodeAt(i); // Handle multibyte unicode characters (like emoji).\n\n    if ((charCode & 0xf800) === 0xd800) {\n      encoded.push(surrogatePairToCodePoint(charCode, string.charCodeAt(++i)));\n    } else {\n      encoded.push(charCode);\n    }\n\n    ++i;\n  }\n\n  encodedStringCache.set(string, encoded);\n  return encoded;\n}\nfunction printOperationsArray(operations) {\n  // The first two values are always rendererID and rootID\n  const rendererID = operations[0];\n  const rootID = operations[1];\n  const logs = [`operations for renderer:${rendererID} and root:${rootID}`];\n  let i = 2; // Reassemble the string table.\n\n  const stringTable = [null // ID = 0 corresponds to the null string.\n  ];\n  const stringTableSize = operations[i++];\n  const stringTableEnd = i + stringTableSize;\n\n  while (i < stringTableEnd) {\n    const nextLength = operations[i++];\n    const nextString = utfDecodeStringWithRanges(operations, i, i + nextLength - 1);\n    stringTable.push(nextString);\n    i += nextLength;\n  }\n\n  while (i < operations.length) {\n    const operation = operations[i];\n\n    switch (operation) {\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_ADD:\n        {\n          const id = operations[i + 1];\n          const type = operations[i + 2];\n          i += 3;\n\n          if (type === _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeRoot) {\n            logs.push(`Add new root node ${id}`);\n            i++; // isStrictModeCompliant\n\n            i++; // supportsProfiling\n\n            i++; // supportsStrictMode\n\n            i++; // hasOwnerMetadata\n          } else {\n            const parentID = operations[i];\n            i++;\n            i++; // ownerID\n\n            const displayNameStringID = operations[i];\n            const displayName = stringTable[displayNameStringID];\n            i++;\n            i++; // key\n\n            logs.push(`Add node ${id} (${displayName || 'null'}) as child of ${parentID}`);\n          }\n\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REMOVE:\n        {\n          const removeLength = operations[i + 1];\n          i += 2;\n\n          for (let removeIndex = 0; removeIndex < removeLength; removeIndex++) {\n            const id = operations[i];\n            i += 1;\n            logs.push(`Remove node ${id}`);\n          }\n\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REMOVE_ROOT:\n        {\n          i += 1;\n          logs.push(`Remove root ${rootID}`);\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_SET_SUBTREE_MODE:\n        {\n          const id = operations[i + 1];\n          const mode = operations[i + 1];\n          i += 3;\n          logs.push(`Mode ${mode} set for subtree with root ${id}`);\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_REORDER_CHILDREN:\n        {\n          const id = operations[i + 1];\n          const numChildren = operations[i + 2];\n          i += 3;\n          const children = operations.slice(i, i + numChildren);\n          i += numChildren;\n          logs.push(`Re-order node ${id} children ${children.join(',')}`);\n          break;\n        }\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_TREE_BASE_DURATION:\n        // Base duration updates are only sent while profiling is in progress.\n        // We can ignore them at this point.\n        // The profiler UI uses them lazily in order to generate the tree.\n        i += 3;\n        break;\n\n      case _constants__WEBPACK_IMPORTED_MODULE_3__.TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:\n        const id = operations[i + 1];\n        const numErrors = operations[i + 2];\n        const numWarnings = operations[i + 3];\n        i += 4;\n        logs.push(`Node ${id} has ${numErrors} errors and ${numWarnings} warnings`);\n        break;\n\n      default:\n        throw Error(`Unsupported Bridge operation \"${operation}\"`);\n    }\n  }\n\n  console.log(logs.join('\\n  '));\n}\nfunction getDefaultComponentFilters() {\n  return [{\n    type: _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ComponentFilterElementType,\n    value: _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeHostComponent,\n    isEnabled: true\n  }];\n}\nfunction getSavedComponentFilters() {\n  try {\n    const raw = (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY);\n\n    if (raw != null) {\n      const parsedFilters = JSON.parse(raw);\n      return filterOutLocationComponentFilters(parsedFilters);\n    }\n  } catch (error) {}\n\n  return getDefaultComponentFilters();\n}\nfunction setSavedComponentFilters(componentFilters) {\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.LOCAL_STORAGE_COMPONENT_FILTER_PREFERENCES_KEY, JSON.stringify(filterOutLocationComponentFilters(componentFilters)));\n} // Following __debugSource removal from Fiber, the new approach for finding the source location\n// of a component, represented by the Fiber, is based on lazily generating and parsing component stack frames\n// To find the original location, React DevTools will perform symbolication, source maps are required for that.\n// In order to start filtering Fibers, we need to find location for all of them, which can't be done lazily.\n// Eager symbolication can become quite expensive for large applications.\n\nfunction filterOutLocationComponentFilters(componentFilters) {\n  // This is just an additional check to preserve the previous state\n  // Filters can be stored on the backend side or in user land (in a window object)\n  if (!Array.isArray(componentFilters)) {\n    return componentFilters;\n  }\n\n  return componentFilters.filter(f => f.type !== _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ComponentFilterLocation);\n}\nfunction getDefaultOpenInEditorURL() {\n  return  false ? 0 : '';\n}\nfunction getOpenInEditorURL() {\n  try {\n    const raw = (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.LOCAL_STORAGE_OPEN_IN_EDITOR_URL);\n\n    if (raw != null) {\n      return JSON.parse(raw);\n    }\n  } catch (error) {}\n\n  return getDefaultOpenInEditorURL();\n}\nfunction parseElementDisplayNameFromBackend(displayName, type) {\n  if (displayName === null) {\n    return {\n      formattedDisplayName: null,\n      hocDisplayNames: null,\n      compiledWithForget: false\n    };\n  }\n\n  if (displayName.startsWith('Forget(')) {\n    const displayNameWithoutForgetWrapper = displayName.slice(7, displayName.length - 1);\n    const {\n      formattedDisplayName,\n      hocDisplayNames\n    } = parseElementDisplayNameFromBackend(displayNameWithoutForgetWrapper, type);\n    return {\n      formattedDisplayName,\n      hocDisplayNames,\n      compiledWithForget: true\n    };\n  }\n\n  let hocDisplayNames = null;\n\n  switch (type) {\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeClass:\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeForwardRef:\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeFunction:\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeMemo:\n    case _frontend_types__WEBPACK_IMPORTED_MODULE_4__.ElementTypeVirtual:\n      if (displayName.indexOf('(') >= 0) {\n        const matches = displayName.match(/[^()]+/g);\n\n        if (matches != null) {\n          // $FlowFixMe[incompatible-type]\n          displayName = matches.pop();\n          hocDisplayNames = matches;\n        }\n      }\n\n      break;\n\n    default:\n      break;\n  }\n\n  return {\n    // $FlowFixMe[incompatible-return]\n    formattedDisplayName: displayName,\n    hocDisplayNames,\n    compiledWithForget: false\n  };\n} // Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\nfunction shallowDiffers(prev, next) {\n  for (const attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (const attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction getInObject(object, path) {\n  return path.reduce((reduced, attr) => {\n    if (reduced) {\n      if (hasOwnProperty.call(reduced, attr)) {\n        return reduced[attr];\n      }\n\n      if (typeof reduced[Symbol.iterator] === 'function') {\n        // Convert iterable to array and return array[index]\n        //\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        return Array.from(reduced)[attr];\n      }\n    }\n\n    return null;\n  }, object);\n}\nfunction deletePathInObject(object, path) {\n  const length = path.length;\n  const last = path[length - 1];\n\n  if (object != null) {\n    const parent = getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      if ((0,_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(parent)) {\n        parent.splice(last, 1);\n      } else {\n        delete parent[last];\n      }\n    }\n  }\n}\nfunction renamePathInObject(object, oldPath, newPath) {\n  const length = oldPath.length;\n\n  if (object != null) {\n    const parent = getInObject(object, oldPath.slice(0, length - 1));\n\n    if (parent) {\n      const lastOld = oldPath[length - 1];\n      const lastNew = newPath[length - 1];\n      parent[lastNew] = parent[lastOld];\n\n      if ((0,_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(parent)) {\n        parent.splice(lastOld, 1);\n      } else {\n        delete parent[lastOld];\n      }\n    }\n  }\n}\nfunction setInObject(object, path, value) {\n  const length = path.length;\n  const last = path[length - 1];\n\n  if (object != null) {\n    const parent = getInObject(object, path.slice(0, length - 1));\n\n    if (parent) {\n      parent[last] = value;\n    }\n  }\n}\n\n/**\n * Get a enhanced/artificial type string based on the object instance\n */\nfunction getDataType(data) {\n  if (data === null) {\n    return 'null';\n  } else if (data === undefined) {\n    return 'undefined';\n  }\n\n  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {\n    return 'html_element';\n  }\n\n  const type = typeof data;\n\n  switch (type) {\n    case 'bigint':\n      return 'bigint';\n\n    case 'boolean':\n      return 'boolean';\n\n    case 'function':\n      return 'function';\n\n    case 'number':\n      if (Number.isNaN(data)) {\n        return 'nan';\n      } else if (!Number.isFinite(data)) {\n        return 'infinity';\n      } else {\n        return 'number';\n      }\n\n    case 'object':\n      if (data.$$typeof === shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_ELEMENT_TYPE || data.$$typeof === shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_LEGACY_ELEMENT_TYPE) {\n        return 'react_element';\n      }\n\n      if ((0,_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(data)) {\n        return 'array';\n      } else if (ArrayBuffer.isView(data)) {\n        return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';\n      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {\n        // HACK This ArrayBuffer check is gross; is there a better way?\n        // We could try to create a new DataView with the value.\n        // If it doesn't error, we know it's an ArrayBuffer,\n        // but this seems kind of awkward and expensive.\n        return 'array_buffer';\n      } else if (typeof data[Symbol.iterator] === 'function') {\n        const iterator = data[Symbol.iterator]();\n\n        if (!iterator) {// Proxies might break assumptoins about iterators.\n          // See github.com/facebook/react/issues/21654\n        } else {\n          return iterator === data ? 'opaque_iterator' : 'iterator';\n        }\n      } else if (data.constructor && data.constructor.name === 'RegExp') {\n        return 'regexp';\n      } else {\n        // $FlowFixMe[method-unbinding]\n        const toStringValue = Object.prototype.toString.call(data);\n\n        if (toStringValue === '[object Date]') {\n          return 'date';\n        } else if (toStringValue === '[object HTMLAllCollection]') {\n          return 'html_all_collection';\n        }\n      }\n\n      if (!isPlainObject(data)) {\n        return 'class_instance';\n      }\n\n      return 'object';\n\n    case 'string':\n      return 'string';\n\n    case 'symbol':\n      return 'symbol';\n\n    case 'undefined':\n      if ( // $FlowFixMe[method-unbinding]\n      Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {\n        return 'html_all_collection';\n      }\n\n      return 'undefined';\n\n    default:\n      return 'unknown';\n  }\n} // Fork of packages/react-is/src/ReactIs.js:30, but with legacy element type\n// Which has been changed in https://github.com/facebook/react/pull/28813\n\nfunction typeOfWithLegacyElementSymbol(object) {\n  if (typeof object === 'object' && object !== null) {\n    const $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_ELEMENT_TYPE:\n      case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_LEGACY_ELEMENT_TYPE:\n        const type = object.type;\n\n        switch (type) {\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_FRAGMENT_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PROFILER_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_STRICT_MODE_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_SUSPENSE_TYPE:\n          case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_SUSPENSE_LIST_TYPE:\n            return type;\n\n          default:\n            const $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_CONTEXT_TYPE:\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_FORWARD_REF_TYPE:\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_LAZY_TYPE:\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_MEMO_TYPE:\n                return $$typeofType;\n\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_CONSUMER_TYPE:\n                if (shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_2__.enableRenderableContext) {\n                  return $$typeofType;\n                }\n\n              // Fall through\n\n              case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PROVIDER_TYPE:\n                if (!shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_2__.enableRenderableContext) {\n                  return $$typeofType;\n                }\n\n              // Fall through\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\n\nfunction getDisplayNameForReactElement(element) {\n  const elementType = typeOfWithLegacyElementSymbol(element);\n\n  switch (elementType) {\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_CONSUMER_TYPE:\n      return 'ContextConsumer';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PROVIDER_TYPE:\n      return 'ContextProvider';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_CONTEXT_TYPE:\n      return 'Context';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_FORWARD_REF_TYPE:\n      return 'ForwardRef';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_LAZY_TYPE:\n      return 'Lazy';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_MEMO_TYPE:\n      return 'Memo';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case shared_ReactSymbols__WEBPACK_IMPORTED_MODULE_1__.REACT_TRACING_MARKER_TYPE:\n      return 'TracingMarker';\n\n    default:\n      const {\n        type\n      } = element;\n\n      if (typeof type === 'string') {\n        return type;\n      } else if (typeof type === 'function') {\n        return getDisplayName(type, 'Anonymous');\n      } else if (type != null) {\n        return 'NotImplementedInDevtools';\n      } else {\n        return 'Element';\n      }\n\n  }\n}\nconst MAX_PREVIEW_STRING_LENGTH = 50;\n\nfunction truncateForDisplay(string, length = MAX_PREVIEW_STRING_LENGTH) {\n  if (string.length > length) {\n    return string.slice(0, length) + '';\n  } else {\n    return string;\n  }\n} // Attempts to mimic Chrome's inline preview for values.\n// For example, the following value...\n//   {\n//      foo: 123,\n//      bar: \"abc\",\n//      baz: [true, false],\n//      qux: { ab: 1, cd: 2 }\n//   };\n//\n// Would show a preview of...\n//   {foo: 123, bar: \"abc\", baz: Array(2), qux: {}}\n//\n// And the following value...\n//   [\n//     123,\n//     \"abc\",\n//     [true, false],\n//     { foo: 123, bar: \"abc\" }\n//   ];\n//\n// Would show a preview of...\n//   [123, \"abc\", Array(2), {}]\n\n\nfunction formatDataForPreview(data, showFormattedValue) {\n  if (data != null && hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__.meta.type)) {\n    return showFormattedValue ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__.meta.preview_long] : data[_hydration__WEBPACK_IMPORTED_MODULE_6__.meta.preview_short];\n  }\n\n  const type = getDataType(data);\n\n  switch (type) {\n    case 'html_element':\n      return `<${truncateForDisplay(data.tagName.toLowerCase())} />`;\n\n    case 'function':\n      if (typeof data.name === 'function' || data.name === '') {\n        return '() => {}';\n      }\n\n      return `${truncateForDisplay(data.name)}() {}`;\n\n    case 'string':\n      return `\"${data}\"`;\n\n    case 'bigint':\n      return truncateForDisplay(data.toString() + 'n');\n\n    case 'regexp':\n      return truncateForDisplay(data.toString());\n\n    case 'symbol':\n      return truncateForDisplay(data.toString());\n\n    case 'react_element':\n      return `<${truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown')} />`;\n\n    case 'array_buffer':\n      return `ArrayBuffer(${data.byteLength})`;\n\n    case 'data_view':\n      return `DataView(${data.buffer.byteLength})`;\n\n    case 'array':\n      if (showFormattedValue) {\n        let formatted = '';\n\n        for (let i = 0; i < data.length; i++) {\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += formatDataForPreview(data[i], false);\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `[${truncateForDisplay(formatted)}]`;\n      } else {\n        const length = hasOwnProperty.call(data, _hydration__WEBPACK_IMPORTED_MODULE_6__.meta.size) ? data[_hydration__WEBPACK_IMPORTED_MODULE_6__.meta.size] : data.length;\n        return `Array(${length})`;\n      }\n\n    case 'typed_array':\n      const shortName = `${data.constructor.name}(${data.length})`;\n\n      if (showFormattedValue) {\n        let formatted = '';\n\n        for (let i = 0; i < data.length; i++) {\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += data[i];\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `${shortName} [${truncateForDisplay(formatted)}]`;\n      } else {\n        return shortName;\n      }\n\n    case 'iterator':\n      const name = data.constructor.name;\n\n      if (showFormattedValue) {\n        // TRICKY\n        // Don't use [...spread] syntax for this purpose.\n        // This project uses @babel/plugin-transform-spread in \"loose\" mode which only works with Array values.\n        // Other types (e.g. typed arrays, Sets) will not spread correctly.\n        const array = Array.from(data);\n        let formatted = '';\n\n        for (let i = 0; i < array.length; i++) {\n          const entryOrEntries = array[i];\n\n          if (i > 0) {\n            formatted += ', ';\n          } // TRICKY\n          // Browsers display Maps and Sets differently.\n          // To mimic their behavior, detect if we've been given an entries tuple.\n          //   Map(2) {\"abc\" => 123, \"def\" => 123}\n          //   Set(2) {\"abc\", 123}\n\n\n          if ((0,_isArray__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(entryOrEntries)) {\n            const key = formatDataForPreview(entryOrEntries[0], true);\n            const value = formatDataForPreview(entryOrEntries[1], false);\n            formatted += `${key} => ${value}`;\n          } else {\n            formatted += formatDataForPreview(entryOrEntries, false);\n          }\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `${name}(${data.size}) {${truncateForDisplay(formatted)}}`;\n      } else {\n        return `${name}(${data.size})`;\n      }\n\n    case 'opaque_iterator':\n      {\n        return data[Symbol.toStringTag];\n      }\n\n    case 'date':\n      return data.toString();\n\n    case 'class_instance':\n      return data.constructor.name;\n\n    case 'object':\n      if (showFormattedValue) {\n        const keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);\n        let formatted = '';\n\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n\n          if (i > 0) {\n            formatted += ', ';\n          }\n\n          formatted += `${key.toString()}: ${formatDataForPreview(data[key], false)}`;\n\n          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {\n            // Prevent doing a lot of unnecessary iteration...\n            break;\n          }\n        }\n\n        return `{${truncateForDisplay(formatted)}}`;\n      } else {\n        return '{}';\n      }\n\n    case 'boolean':\n    case 'number':\n    case 'infinity':\n    case 'nan':\n    case 'null':\n    case 'undefined':\n      return data;\n\n    default:\n      try {\n        return truncateForDisplay(String(data));\n      } catch (error) {\n        return 'unserializable';\n      }\n\n  }\n} // Basically checking that the object only has Object in its prototype chain\n\nconst isPlainObject = object => {\n  const objectPrototype = Object.getPrototypeOf(object);\n  if (!objectPrototype) return true;\n  const objectParentPrototype = Object.getPrototypeOf(objectPrototype);\n  return !objectParentPrototype;\n};\nfunction backendToFrontendSerializedElementMapper(element) {\n  const {\n    formattedDisplayName,\n    hocDisplayNames,\n    compiledWithForget\n  } = parseElementDisplayNameFromBackend(element.displayName, element.type);\n  return { ...element,\n    displayName: formattedDisplayName,\n    hocDisplayNames,\n    compiledWithForget\n  };\n} // Chrome normalizes urls like webpack-internals:// but new URL don't, so cannot use new URL here.\n\nfunction normalizeUrl(url) {\n  return url.replace('/./', '/');\n}\nfunction getIsReloadAndProfileSupported() {\n  // Notify the frontend if the backend supports the Storage API (e.g. localStorage).\n  // If not, features like reload-and-profile will not work correctly and must be disabled.\n  let isBackendStorageAPISupported = false;\n\n  try {\n    localStorage.getItem('test');\n    isBackendStorageAPISupported = true;\n  } catch (error) {}\n\n  return isBackendStorageAPISupported && (0,_backend_utils__WEBPACK_IMPORTED_MODULE_8__.isSynchronousXHRSupported)();\n} // Expected to be used only by browser extension and react-devtools-inline\n\nfunction getIfReloadedAndProfiling() {\n  return (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === 'true';\n}\nfunction getProfilingSettings() {\n  return {\n    recordChangeDescriptions: (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === 'true',\n    recordTimeline: (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageGetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_TIMELINE_KEY) === 'true'\n  };\n}\nfunction onReloadAndProfile(recordChangeDescriptions, recordTimeline) {\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, 'true');\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, recordChangeDescriptions ? 'true' : 'false');\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageSetItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_TIMELINE_KEY, recordTimeline ? 'true' : 'false');\n}\nfunction onReloadAndProfileFlagsReset() {\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageRemoveItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RELOAD_AND_PROFILE_KEY);\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageRemoveItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY);\n  (0,react_devtools_shared_src_storage__WEBPACK_IMPORTED_MODULE_5__.sessionStorageRemoveItem)(_constants__WEBPACK_IMPORTED_MODULE_3__.SESSION_STORAGE_RECORD_TIMELINE_KEY);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFpQkE7QUFDQTtBQWNBO0FBS0E7QUFRQTtBQU9BO0FBQ0E7QUFZQTs7QUFHQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFHQTtBQU1BO0FBQ0E7QUFHQTtBQUVBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFHQTtBQUFBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7O0FBQ0E7QUFDQTtBQXZGQTtBQXlGQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQU9BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFoQkE7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBNEJBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBeEVBO0FBMEVBO0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFqQkE7O0FBVkE7O0FBOEJBO0FBQ0E7QUFwQ0E7QUFzQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBckNBO0FBdUNBO0FBRUE7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBSUE7QUFDQTtBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqSkE7QUFtSkE7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFKQTtBQU9BO0FBRUE7QUFJQTtBQUNBO0FBSUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdXRpbHMuanM/NjZhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQgTFJVIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQge1xuICBSRUFDVF9DT05TVU1FUl9UWVBFLFxuICBSRUFDVF9DT05URVhUX1RZUEUsXG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG4gIFJFQUNUX0xBWllfVFlQRSxcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFLFxuICBSRUFDVF9NRU1PX1RZUEUsXG4gIFJFQUNUX1BPUlRBTF9UWVBFLFxuICBSRUFDVF9QUk9GSUxFUl9UWVBFLFxuICBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFLFxuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUsXG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUsXG4gIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEUsXG59IGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnO1xuaW1wb3J0IHtlbmFibGVSZW5kZXJhYmxlQ29udGV4dH0gZnJvbSAnc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzJztcbmltcG9ydCB7XG4gIFRSRUVfT1BFUkFUSU9OX0FERCxcbiAgVFJFRV9PUEVSQVRJT05fUkVNT1ZFLFxuICBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCxcbiAgVFJFRV9PUEVSQVRJT05fUkVPUkRFUl9DSElMRFJFTixcbiAgVFJFRV9PUEVSQVRJT05fU0VUX1NVQlRSRUVfTU9ERSxcbiAgVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyxcbiAgVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTixcbiAgTE9DQUxfU1RPUkFHRV9DT01QT05FTlRfRklMVEVSX1BSRUZFUkVOQ0VTX0tFWSxcbiAgTE9DQUxfU1RPUkFHRV9PUEVOX0lOX0VESVRPUl9VUkwsXG4gIFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZLFxuICBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZLFxuICBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX1RJTUVMSU5FX0tFWSxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50RmlsdGVyRWxlbWVudFR5cGUsXG4gIENvbXBvbmVudEZpbHRlckxvY2F0aW9uLFxuICBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQsXG59IGZyb20gJy4vZnJvbnRlbmQvdHlwZXMnO1xuaW1wb3J0IHtcbiAgRWxlbWVudFR5cGVSb290LFxuICBFbGVtZW50VHlwZUNsYXNzLFxuICBFbGVtZW50VHlwZUZvcndhcmRSZWYsXG4gIEVsZW1lbnRUeXBlRnVuY3Rpb24sXG4gIEVsZW1lbnRUeXBlTWVtbyxcbiAgRWxlbWVudFR5cGVWaXJ0dWFsLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2Zyb250ZW5kL3R5cGVzJztcbmltcG9ydCB7XG4gIGxvY2FsU3RvcmFnZUdldEl0ZW0sXG4gIGxvY2FsU3RvcmFnZVNldEl0ZW0sXG4gIHNlc3Npb25TdG9yYWdlR2V0SXRlbSxcbiAgc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtLFxuICBzZXNzaW9uU3RvcmFnZVNldEl0ZW0sXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvc3RvcmFnZSc7XG5pbXBvcnQge21ldGF9IGZyb20gJy4vaHlkcmF0aW9uJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheSc7XG5cbmltcG9ydCB0eXBlIHtcbiAgQ29tcG9uZW50RmlsdGVyLFxuICBFbGVtZW50VHlwZSxcbiAgU2VyaWFsaXplZEVsZW1lbnQgYXMgU2VyaWFsaXplZEVsZW1lbnRGcm9udGVuZCxcbiAgTFJVQ2FjaGUsXG59IGZyb20gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZnJvbnRlbmQvdHlwZXMnO1xuaW1wb3J0IHR5cGUge1xuICBQcm9maWxpbmdTZXR0aW5ncyxcbiAgU2VyaWFsaXplZEVsZW1lbnQgYXMgU2VyaWFsaXplZEVsZW1lbnRCYWNrZW5kLFxufSBmcm9tICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdHlwZXMnO1xuaW1wb3J0IHtpc1N5bmNocm9ub3VzWEhSU3VwcG9ydGVkfSBmcm9tICcuL2JhY2tlbmQvdXRpbHMnO1xuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmNvbnN0IGNhY2hlZERpc3BsYXlOYW1lczogV2Vha01hcDxGdW5jdGlvbiwgc3RyaW5nPiA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIE9uIGxhcmdlIHRyZWVzLCBlbmNvZGluZyB0YWtlcyBzaWduaWZpY2FudCB0aW1lLlxuLy8gVHJ5IHRvIHJldXNlIHRoZSBhbHJlYWR5IGVuY29kZWQgc3RyaW5ncy5cbmNvbnN0IGVuY29kZWRTdHJpbmdDYWNoZTogTFJVQ2FjaGU8c3RyaW5nLCBBcnJheTxudW1iZXI+PiA9IG5ldyBMUlUoe1xuICBtYXg6IDEwMDAsXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFscGhhU29ydEtleXMoXG4gIGE6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCxcbiAgYjogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLFxuKTogbnVtYmVyIHtcbiAgaWYgKGEudG9TdHJpbmcoKSA+IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGIudG9TdHJpbmcoKSA+IGEudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsRW51bWVyYWJsZUtleXMoXG4gIG9iajogT2JqZWN0LFxuKTogU2V0PHN0cmluZyB8IG51bWJlciB8IHN5bWJvbD4ge1xuICBjb25zdCBrZXlzID0gbmV3IFNldDxzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2w+KCk7XG4gIGxldCBjdXJyZW50ID0gb2JqO1xuICB3aGlsZSAoY3VycmVudCAhPSBudWxsKSB7XG4gICAgY29uc3QgY3VycmVudEtleXMgPSBbXG4gICAgICAuLi5PYmplY3Qua2V5cyhjdXJyZW50KSxcbiAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoY3VycmVudCksXG4gICAgXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGN1cnJlbnQpO1xuICAgIGN1cnJlbnRLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBrZXkgY2FuIGJlIGEgU3ltYm9sIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICAgIGlmIChkZXNjcmlwdG9yc1trZXldLmVudW1lcmFibGUpIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdXJyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnQpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG4vLyBNaXJyb3IgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvN2MyMWJmNzJhY2U3NzA5NGZkMTkxMGNjMzUwYTU0ODI4N2VmODM1MC9wYWNrYWdlcy9zaGFyZWQvZ2V0Q29tcG9uZW50TmFtZS5qcyNMMjctTDM3XG5leHBvcnQgZnVuY3Rpb24gZ2V0V3JhcHBlZERpc3BsYXlOYW1lKFxuICBvdXRlclR5cGU6IG1peGVkLFxuICBpbm5lclR5cGU6IGFueSxcbiAgd3JhcHBlck5hbWU6IHN0cmluZyxcbiAgZmFsbGJhY2tOYW1lPzogc3RyaW5nLFxuKTogc3RyaW5nIHtcbiAgY29uc3QgZGlzcGxheU5hbWUgPSAob3V0ZXJUeXBlOiBhbnkpPy5kaXNwbGF5TmFtZTtcbiAgcmV0dXJuIChcbiAgICBkaXNwbGF5TmFtZSB8fCBgJHt3cmFwcGVyTmFtZX0oJHtnZXREaXNwbGF5TmFtZShpbm5lclR5cGUsIGZhbGxiYWNrTmFtZSl9KWBcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFxuICB0eXBlOiBGdW5jdGlvbixcbiAgZmFsbGJhY2tOYW1lOiBzdHJpbmcgPSAnQW5vbnltb3VzJyxcbik6IHN0cmluZyB7XG4gIGNvbnN0IG5hbWVGcm9tQ2FjaGUgPSBjYWNoZWREaXNwbGF5TmFtZXMuZ2V0KHR5cGUpO1xuICBpZiAobmFtZUZyb21DYWNoZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG5hbWVGcm9tQ2FjaGU7XG4gIH1cblxuICBsZXQgZGlzcGxheU5hbWUgPSBmYWxsYmFja05hbWU7XG5cbiAgLy8gVGhlIGRpc3BsYXlOYW1lIHByb3BlcnR5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGEgc3RyaW5nLlxuICAvLyBJdCdzIG9ubHkgc2FmZSB0byB1c2UgZm9yIG91ciBwdXJwb3NlcyBpZiBpdCdzIGEgc3RyaW5nLlxuICAvLyBnaXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LWRldnRvb2xzL2lzc3Vlcy84MDNcbiAgaWYgKHR5cGVvZiB0eXBlLmRpc3BsYXlOYW1lID09PSAnc3RyaW5nJykge1xuICAgIGRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZS5uYW1lID09PSAnc3RyaW5nJyAmJiB0eXBlLm5hbWUgIT09ICcnKSB7XG4gICAgZGlzcGxheU5hbWUgPSB0eXBlLm5hbWU7XG4gIH1cblxuICBjYWNoZWREaXNwbGF5TmFtZXMuc2V0KHR5cGUsIGRpc3BsYXlOYW1lKTtcbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxuXG5sZXQgdWlkQ291bnRlcjogbnVtYmVyID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVJRCgpOiBudW1iZXIge1xuICByZXR1cm4gKyt1aWRDb3VudGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXRmRGVjb2RlU3RyaW5nV2l0aFJhbmdlcyhcbiAgYXJyYXk6IEFycmF5PG51bWJlcj4sXG4gIGxlZnQ6IG51bWJlcixcbiAgcmlnaHQ6IG51bWJlcixcbik6IHN0cmluZyB7XG4gIGxldCBzdHJpbmcgPSAnJztcbiAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn1cblxuZnVuY3Rpb24gc3Vycm9nYXRlUGFpclRvQ29kZVBvaW50KFxuICBjaGFyQ29kZTE6IG51bWJlcixcbiAgY2hhckNvZGUyOiBudW1iZXIsXG4pOiBudW1iZXIge1xuICByZXR1cm4gKChjaGFyQ29kZTEgJiAweDNmZikgPDwgMTApICsgKGNoYXJDb2RlMiAmIDB4M2ZmKSArIDB4MTAwMDA7XG59XG5cbi8vIENyZWRpdCBmb3IgdGhpcyBlbmNvZGluZyBhcHByb2FjaCBnb2VzIHRvIFRpbSBEb3duOlxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDg3NzMyNi9ob3ctY2FuLWktdGVsbC1pZi1hLXN0cmluZy1jb250YWlucy1tdWx0aWJ5dGUtY2hhcmFjdGVycy1pbi1qYXZhc2NyaXB0XG5leHBvcnQgZnVuY3Rpb24gdXRmRW5jb2RlU3RyaW5nKHN0cmluZzogc3RyaW5nKTogQXJyYXk8bnVtYmVyPiB7XG4gIGNvbnN0IGNhY2hlZCA9IGVuY29kZWRTdHJpbmdDYWNoZS5nZXQoc3RyaW5nKTtcbiAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZWQgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hhckNvZGU7XG4gIHdoaWxlIChpIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgIGNoYXJDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgLy8gSGFuZGxlIG11bHRpYnl0ZSB1bmljb2RlIGNoYXJhY3RlcnMgKGxpa2UgZW1vamkpLlxuICAgIGlmICgoY2hhckNvZGUgJiAweGY4MDApID09PSAweGQ4MDApIHtcbiAgICAgIGVuY29kZWQucHVzaChzdXJyb2dhdGVQYWlyVG9Db2RlUG9pbnQoY2hhckNvZGUsIHN0cmluZy5jaGFyQ29kZUF0KCsraSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RlZC5wdXNoKGNoYXJDb2RlKTtcbiAgICB9XG4gICAgKytpO1xuICB9XG5cbiAgZW5jb2RlZFN0cmluZ0NhY2hlLnNldChzdHJpbmcsIGVuY29kZWQpO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRPcGVyYXRpb25zQXJyYXkob3BlcmF0aW9uczogQXJyYXk8bnVtYmVyPikge1xuICAvLyBUaGUgZmlyc3QgdHdvIHZhbHVlcyBhcmUgYWx3YXlzIHJlbmRlcmVySUQgYW5kIHJvb3RJRFxuICBjb25zdCByZW5kZXJlcklEID0gb3BlcmF0aW9uc1swXTtcbiAgY29uc3Qgcm9vdElEID0gb3BlcmF0aW9uc1sxXTtcblxuICBjb25zdCBsb2dzID0gW2BvcGVyYXRpb25zIGZvciByZW5kZXJlcjoke3JlbmRlcmVySUR9IGFuZCByb290OiR7cm9vdElEfWBdO1xuXG4gIGxldCBpID0gMjtcblxuICAvLyBSZWFzc2VtYmxlIHRoZSBzdHJpbmcgdGFibGUuXG4gIGNvbnN0IHN0cmluZ1RhYmxlOiBBcnJheTxudWxsIHwgc3RyaW5nPiA9IFtcbiAgICBudWxsLCAvLyBJRCA9IDAgY29ycmVzcG9uZHMgdG8gdGhlIG51bGwgc3RyaW5nLlxuICBdO1xuICBjb25zdCBzdHJpbmdUYWJsZVNpemUgPSBvcGVyYXRpb25zW2krK107XG4gIGNvbnN0IHN0cmluZ1RhYmxlRW5kID0gaSArIHN0cmluZ1RhYmxlU2l6ZTtcbiAgd2hpbGUgKGkgPCBzdHJpbmdUYWJsZUVuZCkge1xuICAgIGNvbnN0IG5leHRMZW5ndGggPSBvcGVyYXRpb25zW2krK107XG4gICAgY29uc3QgbmV4dFN0cmluZyA9IHV0ZkRlY29kZVN0cmluZ1dpdGhSYW5nZXMoXG4gICAgICBvcGVyYXRpb25zLFxuICAgICAgaSxcbiAgICAgIGkgKyBuZXh0TGVuZ3RoIC0gMSxcbiAgICApO1xuICAgIHN0cmluZ1RhYmxlLnB1c2gobmV4dFN0cmluZyk7XG4gICAgaSArPSBuZXh0TGVuZ3RoO1xuICB9XG5cbiAgd2hpbGUgKGkgPCBvcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbaV07XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9BREQ6IHtcbiAgICAgICAgY29uc3QgaWQgPSAoKG9wZXJhdGlvbnNbaSArIDFdOiBhbnkpOiBudW1iZXIpO1xuICAgICAgICBjb25zdCB0eXBlID0gKChvcGVyYXRpb25zW2kgKyAyXTogYW55KTogRWxlbWVudFR5cGUpO1xuXG4gICAgICAgIGkgKz0gMztcblxuICAgICAgICBpZiAodHlwZSA9PT0gRWxlbWVudFR5cGVSb290KSB7XG4gICAgICAgICAgbG9ncy5wdXNoKGBBZGQgbmV3IHJvb3Qgbm9kZSAke2lkfWApO1xuXG4gICAgICAgICAgaSsrOyAvLyBpc1N0cmljdE1vZGVDb21wbGlhbnRcbiAgICAgICAgICBpKys7IC8vIHN1cHBvcnRzUHJvZmlsaW5nXG4gICAgICAgICAgaSsrOyAvLyBzdXBwb3J0c1N0cmljdE1vZGVcbiAgICAgICAgICBpKys7IC8vIGhhc093bmVyTWV0YWRhdGFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJRCA9ICgob3BlcmF0aW9uc1tpXTogYW55KTogbnVtYmVyKTtcbiAgICAgICAgICBpKys7XG5cbiAgICAgICAgICBpKys7IC8vIG93bmVySURcblxuICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lU3RyaW5nSUQgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gc3RyaW5nVGFibGVbZGlzcGxheU5hbWVTdHJpbmdJRF07XG4gICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgaSsrOyAvLyBrZXlcblxuICAgICAgICAgIGxvZ3MucHVzaChcbiAgICAgICAgICAgIGBBZGQgbm9kZSAke2lkfSAoJHtkaXNwbGF5TmFtZSB8fCAnbnVsbCd9KSBhcyBjaGlsZCBvZiAke3BhcmVudElEfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fUkVNT1ZFOiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZUxlbmd0aCA9ICgob3BlcmF0aW9uc1tpICsgMV06IGFueSk6IG51bWJlcik7XG4gICAgICAgIGkgKz0gMjtcblxuICAgICAgICBmb3IgKGxldCByZW1vdmVJbmRleCA9IDA7IHJlbW92ZUluZGV4IDwgcmVtb3ZlTGVuZ3RoOyByZW1vdmVJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgaWQgPSAoKG9wZXJhdGlvbnNbaV06IGFueSk6IG51bWJlcik7XG4gICAgICAgICAgaSArPSAxO1xuXG4gICAgICAgICAgbG9ncy5wdXNoKGBSZW1vdmUgbm9kZSAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVDoge1xuICAgICAgICBpICs9IDE7XG5cbiAgICAgICAgbG9ncy5wdXNoKGBSZW1vdmUgcm9vdCAke3Jvb3RJRH1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1NFVF9TVUJUUkVFX01PREU6IHtcbiAgICAgICAgY29uc3QgaWQgPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgY29uc3QgbW9kZSA9IG9wZXJhdGlvbnNbaSArIDFdO1xuXG4gICAgICAgIGkgKz0gMztcblxuICAgICAgICBsb2dzLnB1c2goYE1vZGUgJHttb2RlfSBzZXQgZm9yIHN1YnRyZWUgd2l0aCByb290ICR7aWR9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOOiB7XG4gICAgICAgIGNvbnN0IGlkID0gKChvcGVyYXRpb25zW2kgKyAxXTogYW55KTogbnVtYmVyKTtcbiAgICAgICAgY29uc3QgbnVtQ2hpbGRyZW4gPSAoKG9wZXJhdGlvbnNbaSArIDJdOiBhbnkpOiBudW1iZXIpO1xuICAgICAgICBpICs9IDM7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gb3BlcmF0aW9ucy5zbGljZShpLCBpICsgbnVtQ2hpbGRyZW4pO1xuICAgICAgICBpICs9IG51bUNoaWxkcmVuO1xuXG4gICAgICAgIGxvZ3MucHVzaChgUmUtb3JkZXIgbm9kZSAke2lkfSBjaGlsZHJlbiAke2NoaWxkcmVuLmpvaW4oJywnKX1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT046XG4gICAgICAgIC8vIEJhc2UgZHVyYXRpb24gdXBkYXRlcyBhcmUgb25seSBzZW50IHdoaWxlIHByb2ZpbGluZyBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgLy8gV2UgY2FuIGlnbm9yZSB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIC8vIFRoZSBwcm9maWxlciBVSSB1c2VzIHRoZW0gbGF6aWx5IGluIG9yZGVyIHRvIGdlbmVyYXRlIHRoZSB0cmVlLlxuICAgICAgICBpICs9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9VUERBVEVfRVJST1JTX09SX1dBUk5JTkdTOlxuICAgICAgICBjb25zdCBpZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICBjb25zdCBudW1FcnJvcnMgPSBvcGVyYXRpb25zW2kgKyAyXTtcbiAgICAgICAgY29uc3QgbnVtV2FybmluZ3MgPSBvcGVyYXRpb25zW2kgKyAzXTtcblxuICAgICAgICBpICs9IDQ7XG5cbiAgICAgICAgbG9ncy5wdXNoKFxuICAgICAgICAgIGBOb2RlICR7aWR9IGhhcyAke251bUVycm9yc30gZXJyb3JzIGFuZCAke251bVdhcm5pbmdzfSB3YXJuaW5nc2AsXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIEJyaWRnZSBvcGVyYXRpb24gXCIke29wZXJhdGlvbn1cImApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGxvZ3Muam9pbignXFxuICAnKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycygpOiBBcnJheTxDb21wb25lbnRGaWx0ZXI+IHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB0eXBlOiBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZSxcbiAgICAgIHZhbHVlOiBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQsXG4gICAgICBpc0VuYWJsZWQ6IHRydWUsXG4gICAgfSxcbiAgXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNhdmVkQ29tcG9uZW50RmlsdGVycygpOiBBcnJheTxDb21wb25lbnRGaWx0ZXI+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2VHZXRJdGVtKFxuICAgICAgTE9DQUxfU1RPUkFHRV9DT01QT05FTlRfRklMVEVSX1BSRUZFUkVOQ0VTX0tFWSxcbiAgICApO1xuICAgIGlmIChyYXcgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyc2VkRmlsdGVyczogQXJyYXk8Q29tcG9uZW50RmlsdGVyPiA9IEpTT04ucGFyc2UocmF3KTtcbiAgICAgIHJldHVybiBmaWx0ZXJPdXRMb2NhdGlvbkNvbXBvbmVudEZpbHRlcnMocGFyc2VkRmlsdGVycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge31cbiAgcmV0dXJuIGdldERlZmF1bHRDb21wb25lbnRGaWx0ZXJzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTYXZlZENvbXBvbmVudEZpbHRlcnMoXG4gIGNvbXBvbmVudEZpbHRlcnM6IEFycmF5PENvbXBvbmVudEZpbHRlcj4sXG4pOiB2b2lkIHtcbiAgbG9jYWxTdG9yYWdlU2V0SXRlbShcbiAgICBMT0NBTF9TVE9SQUdFX0NPTVBPTkVOVF9GSUxURVJfUFJFRkVSRU5DRVNfS0VZLFxuICAgIEpTT04uc3RyaW5naWZ5KGZpbHRlck91dExvY2F0aW9uQ29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKSksXG4gICk7XG59XG5cbi8vIEZvbGxvd2luZyBfX2RlYnVnU291cmNlIHJlbW92YWwgZnJvbSBGaWJlciwgdGhlIG5ldyBhcHByb2FjaCBmb3IgZmluZGluZyB0aGUgc291cmNlIGxvY2F0aW9uXG4vLyBvZiBhIGNvbXBvbmVudCwgcmVwcmVzZW50ZWQgYnkgdGhlIEZpYmVyLCBpcyBiYXNlZCBvbiBsYXppbHkgZ2VuZXJhdGluZyBhbmQgcGFyc2luZyBjb21wb25lbnQgc3RhY2sgZnJhbWVzXG4vLyBUbyBmaW5kIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiwgUmVhY3QgRGV2VG9vbHMgd2lsbCBwZXJmb3JtIHN5bWJvbGljYXRpb24sIHNvdXJjZSBtYXBzIGFyZSByZXF1aXJlZCBmb3IgdGhhdC5cbi8vIEluIG9yZGVyIHRvIHN0YXJ0IGZpbHRlcmluZyBGaWJlcnMsIHdlIG5lZWQgdG8gZmluZCBsb2NhdGlvbiBmb3IgYWxsIG9mIHRoZW0sIHdoaWNoIGNhbid0IGJlIGRvbmUgbGF6aWx5LlxuLy8gRWFnZXIgc3ltYm9saWNhdGlvbiBjYW4gYmVjb21lIHF1aXRlIGV4cGVuc2l2ZSBmb3IgbGFyZ2UgYXBwbGljYXRpb25zLlxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlck91dExvY2F0aW9uQ29tcG9uZW50RmlsdGVycyhcbiAgY29tcG9uZW50RmlsdGVyczogQXJyYXk8Q29tcG9uZW50RmlsdGVyPixcbik6IEFycmF5PENvbXBvbmVudEZpbHRlcj4ge1xuICAvLyBUaGlzIGlzIGp1c3QgYW4gYWRkaXRpb25hbCBjaGVjayB0byBwcmVzZXJ2ZSB0aGUgcHJldmlvdXMgc3RhdGVcbiAgLy8gRmlsdGVycyBjYW4gYmUgc3RvcmVkIG9uIHRoZSBiYWNrZW5kIHNpZGUgb3IgaW4gdXNlciBsYW5kIChpbiBhIHdpbmRvdyBvYmplY3QpXG4gIGlmICghQXJyYXkuaXNBcnJheShjb21wb25lbnRGaWx0ZXJzKSkge1xuICAgIHJldHVybiBjb21wb25lbnRGaWx0ZXJzO1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudEZpbHRlcnMuZmlsdGVyKGYgPT4gZi50eXBlICE9PSBDb21wb25lbnRGaWx0ZXJMb2NhdGlvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0T3BlbkluRWRpdG9yVVJMKCk6IHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2Vzcy5lbnYuRURJVE9SX1VSTCA9PT0gJ3N0cmluZydcbiAgICA/IHByb2Nlc3MuZW52LkVESVRPUl9VUkxcbiAgICA6ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3BlbkluRWRpdG9yVVJMKCk6IHN0cmluZyB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmF3ID0gbG9jYWxTdG9yYWdlR2V0SXRlbShMT0NBTF9TVE9SQUdFX09QRU5fSU5fRURJVE9SX1VSTCk7XG4gICAgaWYgKHJhdyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gIHJldHVybiBnZXREZWZhdWx0T3BlbkluRWRpdG9yVVJMKCk7XG59XG5cbnR5cGUgUGFyc2VFbGVtZW50RGlzcGxheU5hbWVGcm9tQmFja2VuZFJldHVybiA9IHtcbiAgZm9ybWF0dGVkRGlzcGxheU5hbWU6IHN0cmluZyB8IG51bGwsXG4gIGhvY0Rpc3BsYXlOYW1lczogQXJyYXk8c3RyaW5nPiB8IG51bGwsXG4gIGNvbXBpbGVkV2l0aEZvcmdldDogYm9vbGVhbixcbn07XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFbGVtZW50RGlzcGxheU5hbWVGcm9tQmFja2VuZChcbiAgZGlzcGxheU5hbWU6IHN0cmluZyB8IG51bGwsXG4gIHR5cGU6IEVsZW1lbnRUeXBlLFxuKTogUGFyc2VFbGVtZW50RGlzcGxheU5hbWVGcm9tQmFja2VuZFJldHVybiB7XG4gIGlmIChkaXNwbGF5TmFtZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXR0ZWREaXNwbGF5TmFtZTogbnVsbCxcbiAgICAgIGhvY0Rpc3BsYXlOYW1lczogbnVsbCxcbiAgICAgIGNvbXBpbGVkV2l0aEZvcmdldDogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGlmIChkaXNwbGF5TmFtZS5zdGFydHNXaXRoKCdGb3JnZXQoJykpIHtcbiAgICBjb25zdCBkaXNwbGF5TmFtZVdpdGhvdXRGb3JnZXRXcmFwcGVyID0gZGlzcGxheU5hbWUuc2xpY2UoXG4gICAgICA3LFxuICAgICAgZGlzcGxheU5hbWUubGVuZ3RoIC0gMSxcbiAgICApO1xuXG4gICAgY29uc3Qge2Zvcm1hdHRlZERpc3BsYXlOYW1lLCBob2NEaXNwbGF5TmFtZXN9ID1cbiAgICAgIHBhcnNlRWxlbWVudERpc3BsYXlOYW1lRnJvbUJhY2tlbmQoZGlzcGxheU5hbWVXaXRob3V0Rm9yZ2V0V3JhcHBlciwgdHlwZSk7XG4gICAgcmV0dXJuIHtmb3JtYXR0ZWREaXNwbGF5TmFtZSwgaG9jRGlzcGxheU5hbWVzLCBjb21waWxlZFdpdGhGb3JnZXQ6IHRydWV9O1xuICB9XG5cbiAgbGV0IGhvY0Rpc3BsYXlOYW1lcyA9IG51bGw7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgRWxlbWVudFR5cGVDbGFzczpcbiAgICBjYXNlIEVsZW1lbnRUeXBlRm9yd2FyZFJlZjpcbiAgICBjYXNlIEVsZW1lbnRUeXBlRnVuY3Rpb246XG4gICAgY2FzZSBFbGVtZW50VHlwZU1lbW86XG4gICAgY2FzZSBFbGVtZW50VHlwZVZpcnR1YWw6XG4gICAgICBpZiAoZGlzcGxheU5hbWUuaW5kZXhPZignKCcpID49IDApIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGRpc3BsYXlOYW1lLm1hdGNoKC9bXigpXSsvZyk7XG4gICAgICAgIGlmIChtYXRjaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuICAgICAgICAgIGRpc3BsYXlOYW1lID0gbWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgICBob2NEaXNwbGF5TmFtZXMgPSBtYXRjaGVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICBmb3JtYXR0ZWREaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgaG9jRGlzcGxheU5hbWVzLFxuICAgIGNvbXBpbGVkV2l0aEZvcmdldDogZmFsc2UsXG4gIH07XG59XG5cbi8vIFB1bGxlZCBmcm9tIHJlYWN0LWNvbXBhdFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QtY29tcGF0L2Jsb2IvN2M1ZGUwMGU3Yzg1ZTJmZmQwMTFiZjNhZjAyODk5YjYzZjY5OWQzYS9zcmMvaW5kZXguanMjTDM0OVxuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKHByZXY6IE9iamVjdCwgbmV4dDogT2JqZWN0KTogYm9vbGVhbiB7XG4gIGZvciAoY29uc3QgYXR0cmlidXRlIGluIHByZXYpIHtcbiAgICBpZiAoIShhdHRyaWJ1dGUgaW4gbmV4dCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBpbiBuZXh0KSB7XG4gICAgaWYgKHByZXZbYXR0cmlidXRlXSAhPT0gbmV4dFthdHRyaWJ1dGVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5PYmplY3Qob2JqZWN0OiBPYmplY3QsIHBhdGg6IEFycmF5PHN0cmluZyB8IG51bWJlcj4pOiBhbnkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKHJlZHVjZWQ6IE9iamVjdCwgYXR0cjogYW55KTogYW55ID0+IHtcbiAgICBpZiAocmVkdWNlZCkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVkdWNlZCwgYXR0cikpIHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRbYXR0cl07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZWRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDb252ZXJ0IGl0ZXJhYmxlIHRvIGFycmF5IGFuZCByZXR1cm4gYXJyYXlbaW5kZXhdXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRSSUNLWVxuICAgICAgICAvLyBEb24ndCB1c2UgWy4uLnNwcmVhZF0gc3ludGF4IGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIC8vIFRoaXMgcHJvamVjdCB1c2VzIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXNwcmVhZCBpbiBcImxvb3NlXCIgbW9kZSB3aGljaCBvbmx5IHdvcmtzIHdpdGggQXJyYXkgdmFsdWVzLlxuICAgICAgICAvLyBPdGhlciB0eXBlcyAoZS5nLiB0eXBlZCBhcnJheXMsIFNldHMpIHdpbGwgbm90IHNwcmVhZCBjb3JyZWN0bHkuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJlZHVjZWQpW2F0dHJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlUGF0aEluT2JqZWN0KFxuICBvYmplY3Q6IE9iamVjdCxcbiAgcGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbikge1xuICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgY29uc3QgbGFzdCA9IHBhdGhbbGVuZ3RoIC0gMV07XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKGlzQXJyYXkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuc3BsaWNlKCgobGFzdDogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcGFyZW50W2xhc3RdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuYW1lUGF0aEluT2JqZWN0KFxuICBvYmplY3Q6IE9iamVjdCxcbiAgb2xkUGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbiAgbmV3UGF0aDogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPixcbikge1xuICBjb25zdCBsZW5ndGggPSBvbGRQYXRoLmxlbmd0aDtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0SW5PYmplY3Qob2JqZWN0LCBvbGRQYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBjb25zdCBsYXN0T2xkID0gb2xkUGF0aFtsZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGxhc3ROZXcgPSBuZXdQYXRoW2xlbmd0aCAtIDFdO1xuICAgICAgcGFyZW50W2xhc3ROZXddID0gcGFyZW50W2xhc3RPbGRdO1xuICAgICAgaWYgKGlzQXJyYXkocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuc3BsaWNlKCgobGFzdE9sZDogYW55KTogbnVtYmVyKSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcGFyZW50W2xhc3RPbGRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SW5PYmplY3QoXG4gIG9iamVjdDogT2JqZWN0LFxuICBwYXRoOiBBcnJheTxzdHJpbmcgfCBudW1iZXI+LFxuICB2YWx1ZTogYW55LFxuKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICBjb25zdCBsYXN0ID0gcGF0aFtsZW5ndGggLSAxXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZ2V0SW5PYmplY3Qob2JqZWN0LCBwYXRoLnNsaWNlKDAsIGxlbmd0aCAtIDEpKTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgRGF0YVR5cGUgPVxuICB8ICdhcnJheSdcbiAgfCAnYXJyYXlfYnVmZmVyJ1xuICB8ICdiaWdpbnQnXG4gIHwgJ2Jvb2xlYW4nXG4gIHwgJ2NsYXNzX2luc3RhbmNlJ1xuICB8ICdkYXRhX3ZpZXcnXG4gIHwgJ2RhdGUnXG4gIHwgJ2Z1bmN0aW9uJ1xuICB8ICdodG1sX2FsbF9jb2xsZWN0aW9uJ1xuICB8ICdodG1sX2VsZW1lbnQnXG4gIHwgJ2luZmluaXR5J1xuICB8ICdpdGVyYXRvcidcbiAgfCAnb3BhcXVlX2l0ZXJhdG9yJ1xuICB8ICduYW4nXG4gIHwgJ251bGwnXG4gIHwgJ251bWJlcidcbiAgfCAnb2JqZWN0J1xuICB8ICdyZWFjdF9lbGVtZW50J1xuICB8ICdyZWdleHAnXG4gIHwgJ3N0cmluZydcbiAgfCAnc3ltYm9sJ1xuICB8ICd0eXBlZF9hcnJheSdcbiAgfCAndW5kZWZpbmVkJ1xuICB8ICd1bmtub3duJztcblxuLyoqXG4gKiBHZXQgYSBlbmhhbmNlZC9hcnRpZmljaWFsIHR5cGUgc3RyaW5nIGJhc2VkIG9uIHRoZSBvYmplY3QgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFUeXBlKGRhdGE6IE9iamVjdCk6IERhdGFUeXBlIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiAnaHRtbF9lbGVtZW50JztcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgZGF0YTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIHJldHVybiAnYmlnaW50JztcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuICdmdW5jdGlvbic7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICduYW4nO1xuICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzRmluaXRlKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnaW5maW5pdHknO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgfVxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoXG4gICAgICAgIGRhdGEuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fFxuICAgICAgICBkYXRhLiQkdHlwZW9mID09PSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuICdyZWFjdF9lbGVtZW50JztcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YS5jb25zdHJ1Y3RvciwgJ0JZVEVTX1BFUl9FTEVNRU5UJylcbiAgICAgICAgICA/ICd0eXBlZF9hcnJheSdcbiAgICAgICAgICA6ICdkYXRhX3ZpZXcnO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmNvbnN0cnVjdG9yICYmIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJykge1xuICAgICAgICAvLyBIQUNLIFRoaXMgQXJyYXlCdWZmZXIgY2hlY2sgaXMgZ3Jvc3M7IGlzIHRoZXJlIGEgYmV0dGVyIHdheT9cbiAgICAgICAgLy8gV2UgY291bGQgdHJ5IHRvIGNyZWF0ZSBhIG5ldyBEYXRhVmlldyB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBlcnJvciwgd2Uga25vdyBpdCdzIGFuIEFycmF5QnVmZmVyLFxuICAgICAgICAvLyBidXQgdGhpcyBzZWVtcyBraW5kIG9mIGF3a3dhcmQgYW5kIGV4cGVuc2l2ZS5cbiAgICAgICAgcmV0dXJuICdhcnJheV9idWZmZXInO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIGlmICghaXRlcmF0b3IpIHtcbiAgICAgICAgICAvLyBQcm94aWVzIG1pZ2h0IGJyZWFrIGFzc3VtcHRvaW5zIGFib3V0IGl0ZXJhdG9ycy5cbiAgICAgICAgICAvLyBTZWUgZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjE2NTRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3IgPT09IGRhdGEgPyAnb3BhcXVlX2l0ZXJhdG9yJyA6ICdpdGVyYXRvcic7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5jb25zdHJ1Y3RvciAmJiBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdSZWdFeHAnKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgY29uc3QgdG9TdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKTtcbiAgICAgICAgaWYgKHRvU3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICAgIH0gZWxzZSBpZiAodG9TdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgSFRNTEFsbENvbGxlY3Rpb25dJykge1xuICAgICAgICAgIHJldHVybiAnaHRtbF9hbGxfY29sbGVjdGlvbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnY2xhc3NfaW5zdGFuY2UnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICBpZiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuICdodG1sX2FsbF9jb2xsZWN0aW9uJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgfVxufVxuXG4vLyBGb3JrIG9mIHBhY2thZ2VzL3JlYWN0LWlzL3NyYy9SZWFjdElzLmpzOjMwLCBidXQgd2l0aCBsZWdhY3kgZWxlbWVudCB0eXBlXG4vLyBXaGljaCBoYXMgYmVlbiBjaGFuZ2VkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI4ODEzXG5mdW5jdGlvbiB0eXBlT2ZXaXRoTGVnYWN5RWxlbWVudFN5bWJvbChvYmplY3Q6IGFueSk6IG1peGVkIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIGNvbnN0ICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjb25zdCB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWVGb3JSZWFjdEVsZW1lbnQoXG4gIGVsZW1lbnQ6IFJlYWN0JEVsZW1lbnQ8YW55Pixcbik6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBlbGVtZW50VHlwZSA9IHR5cGVPZldpdGhMZWdhY3lFbGVtZW50U3ltYm9sKGVsZW1lbnQpO1xuICBzd2l0Y2ggKGVsZW1lbnRUeXBlKSB7XG4gICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgcmV0dXJuICdDb250ZXh0Q29uc3VtZXInO1xuICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dFByb3ZpZGVyJztcbiAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dCc7XG4gICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgcmV0dXJuICdGb3J3YXJkUmVmJztcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgIHJldHVybiAnTGF6eSc7XG4gICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICByZXR1cm4gJ01lbW8nO1xuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgICBjYXNlIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEU6XG4gICAgICByZXR1cm4gJ1RyYWNpbmdNYXJrZXInO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb25zdCB7dHlwZX0gPSBlbGVtZW50O1xuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKHR5cGUsICdBbm9ueW1vdXMnKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnTm90SW1wbGVtZW50ZWRJbkRldnRvb2xzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnRWxlbWVudCc7XG4gICAgICB9XG4gIH1cbn1cblxuY29uc3QgTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCA9IDUwO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZUZvckRpc3BsYXkoXG4gIHN0cmluZzogc3RyaW5nLFxuICBsZW5ndGg6IG51bWJlciA9IE1BWF9QUkVWSUVXX1NUUklOR19MRU5HVEgsXG4pIHtcbiAgaWYgKHN0cmluZy5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxlbmd0aCkgKyAn4oCmJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIG1pbWljIENocm9tZSdzIGlubGluZSBwcmV2aWV3IGZvciB2YWx1ZXMuXG4vLyBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyB2YWx1ZS4uLlxuLy8gICB7XG4vLyAgICAgIGZvbzogMTIzLFxuLy8gICAgICBiYXI6IFwiYWJjXCIsXG4vLyAgICAgIGJhejogW3RydWUsIGZhbHNlXSxcbi8vICAgICAgcXV4OiB7IGFiOiAxLCBjZDogMiB9XG4vLyAgIH07XG4vL1xuLy8gV291bGQgc2hvdyBhIHByZXZpZXcgb2YuLi5cbi8vICAge2ZvbzogMTIzLCBiYXI6IFwiYWJjXCIsIGJhejogQXJyYXkoMiksIHF1eDoge+KApn19XG4vL1xuLy8gQW5kIHRoZSBmb2xsb3dpbmcgdmFsdWUuLi5cbi8vICAgW1xuLy8gICAgIDEyMyxcbi8vICAgICBcImFiY1wiLFxuLy8gICAgIFt0cnVlLCBmYWxzZV0sXG4vLyAgICAgeyBmb286IDEyMywgYmFyOiBcImFiY1wiIH1cbi8vICAgXTtcbi8vXG4vLyBXb3VsZCBzaG93IGEgcHJldmlldyBvZi4uLlxuLy8gICBbMTIzLCBcImFiY1wiLCBBcnJheSgyKSwge+KApn1dXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0YUZvclByZXZpZXcoXG4gIGRhdGE6IGFueSxcbiAgc2hvd0Zvcm1hdHRlZFZhbHVlOiBib29sZWFuLFxuKTogc3RyaW5nIHtcbiAgaWYgKGRhdGEgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIG1ldGEudHlwZSkpIHtcbiAgICByZXR1cm4gc2hvd0Zvcm1hdHRlZFZhbHVlXG4gICAgICA/IGRhdGFbbWV0YS5wcmV2aWV3X2xvbmddXG4gICAgICA6IGRhdGFbbWV0YS5wcmV2aWV3X3Nob3J0XTtcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSBnZXREYXRhVHlwZShkYXRhKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdodG1sX2VsZW1lbnQnOlxuICAgICAgcmV0dXJuIGA8JHt0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpfSAvPmA7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgaWYgKHR5cGVvZiBkYXRhLm5hbWUgPT09ICdmdW5jdGlvbicgfHwgZGF0YS5uYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gJygpID0+IHt9JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHt0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS5uYW1lKX0oKSB7fWA7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBgXCIke2RhdGF9XCJgO1xuICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICByZXR1cm4gdHJ1bmNhdGVGb3JEaXNwbGF5KGRhdGEudG9TdHJpbmcoKSArICduJyk7XG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50b1N0cmluZygpKTtcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShkYXRhLnRvU3RyaW5nKCkpO1xuICAgIGNhc2UgJ3JlYWN0X2VsZW1lbnQnOlxuICAgICAgcmV0dXJuIGA8JHt0cnVuY2F0ZUZvckRpc3BsYXkoXG4gICAgICAgIGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50KGRhdGEpIHx8ICdVbmtub3duJyxcbiAgICAgICl9IC8+YDtcbiAgICBjYXNlICdhcnJheV9idWZmZXInOlxuICAgICAgcmV0dXJuIGBBcnJheUJ1ZmZlcigke2RhdGEuYnl0ZUxlbmd0aH0pYDtcbiAgICBjYXNlICdkYXRhX3ZpZXcnOlxuICAgICAgcmV0dXJuIGBEYXRhVmlldygke2RhdGEuYnVmZmVyLmJ5dGVMZW5ndGh9KWA7XG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICBsZXQgZm9ybWF0dGVkID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcm1hdHRlZCArPSBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhW2ldLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKGZvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgWyR7dHJ1bmNhdGVGb3JEaXNwbGF5KGZvcm1hdHRlZCl9XWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIG1ldGEuc2l6ZSlcbiAgICAgICAgICA/IGRhdGFbbWV0YS5zaXplXVxuICAgICAgICAgIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBgQXJyYXkoJHtsZW5ndGh9KWA7XG4gICAgICB9XG4gICAgY2FzZSAndHlwZWRfYXJyYXknOlxuICAgICAgY29uc3Qgc2hvcnROYW1lID0gYCR7ZGF0YS5jb25zdHJ1Y3Rvci5uYW1lfSgke2RhdGEubGVuZ3RofSlgO1xuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICBsZXQgZm9ybWF0dGVkID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcm1hdHRlZCArPSBkYXRhW2ldO1xuICAgICAgICAgIGlmIChmb3JtYXR0ZWQubGVuZ3RoID4gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkb2luZyBhIGxvdCBvZiB1bm5lY2Vzc2FyeSBpdGVyYXRpb24uLi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7c2hvcnROYW1lfSBbJHt0cnVuY2F0ZUZvckRpc3BsYXkoZm9ybWF0dGVkKX1dYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaG9ydE5hbWU7XG4gICAgICB9XG4gICAgY2FzZSAnaXRlcmF0b3InOlxuICAgICAgY29uc3QgbmFtZSA9IGRhdGEuY29uc3RydWN0b3IubmFtZTtcblxuICAgICAgaWYgKHNob3dGb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICAvLyBUUklDS1lcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFsuLi5zcHJlYWRdIHN5bnRheCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAvLyBUaGlzIHByb2plY3QgdXNlcyBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1zcHJlYWQgaW4gXCJsb29zZVwiIG1vZGUgd2hpY2ggb25seSB3b3JrcyB3aXRoIEFycmF5IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXIgdHlwZXMgKGUuZy4gdHlwZWQgYXJyYXlzLCBTZXRzKSB3aWxsIG5vdCBzcHJlYWQgY29ycmVjdGx5LlxuICAgICAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oZGF0YSk7XG5cbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZW50cnlPckVudHJpZXMgPSBhcnJheVtpXTtcblxuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVFJJQ0tZXG4gICAgICAgICAgLy8gQnJvd3NlcnMgZGlzcGxheSBNYXBzIGFuZCBTZXRzIGRpZmZlcmVudGx5LlxuICAgICAgICAgIC8vIFRvIG1pbWljIHRoZWlyIGJlaGF2aW9yLCBkZXRlY3QgaWYgd2UndmUgYmVlbiBnaXZlbiBhbiBlbnRyaWVzIHR1cGxlLlxuICAgICAgICAgIC8vICAgTWFwKDIpIHtcImFiY1wiID0+IDEyMywgXCJkZWZcIiA9PiAxMjN9XG4gICAgICAgICAgLy8gICBTZXQoMikge1wiYWJjXCIsIDEyM31cbiAgICAgICAgICBpZiAoaXNBcnJheShlbnRyeU9yRW50cmllcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0RGF0YUZvclByZXZpZXcoZW50cnlPckVudHJpZXNbMV0sIGZhbHNlKTtcbiAgICAgICAgICAgIGZvcm1hdHRlZCArPSBgJHtrZXl9ID0+ICR7dmFsdWV9YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke25hbWV9KCR7ZGF0YS5zaXplfSkgeyR7dHJ1bmNhdGVGb3JEaXNwbGF5KGZvcm1hdHRlZCl9fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX0oJHtkYXRhLnNpemV9KWA7XG4gICAgICB9XG4gICAgY2FzZSAnb3BhcXVlX2l0ZXJhdG9yJzoge1xuICAgICAgcmV0dXJuIGRhdGFbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICB9XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIGNhc2UgJ2NsYXNzX2luc3RhbmNlJzpcbiAgICAgIHJldHVybiBkYXRhLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChzaG93Rm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20oZ2V0QWxsRW51bWVyYWJsZUtleXMoZGF0YSkpLnNvcnQoYWxwaGFTb3J0S2V5cyk7XG5cbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcm1hdHRlZCArPSBgJHtrZXkudG9TdHJpbmcoKX06ICR7Zm9ybWF0RGF0YUZvclByZXZpZXcoXG4gICAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICApfWA7XG4gICAgICAgICAgaWYgKGZvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgeyR7dHJ1bmNhdGVGb3JEaXNwbGF5KGZvcm1hdHRlZCl9fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ3vigKZ9JztcbiAgICAgIH1cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ2luZmluaXR5JzpcbiAgICBjYXNlICduYW4nOlxuICAgIGNhc2UgJ251bGwnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShTdHJpbmcoZGF0YSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICd1bnNlcmlhbGl6YWJsZSc7XG4gICAgICB9XG4gIH1cbn1cblxuLy8gQmFzaWNhbGx5IGNoZWNraW5nIHRoYXQgdGhlIG9iamVjdCBvbmx5IGhhcyBPYmplY3QgaW4gaXRzIHByb3RvdHlwZSBjaGFpblxuZXhwb3J0IGNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqZWN0OiBPYmplY3QpOiBib29sZWFuID0+IHtcbiAgY29uc3Qgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIGlmICghb2JqZWN0UHJvdG90eXBlKSByZXR1cm4gdHJ1ZTtcblxuICBjb25zdCBvYmplY3RQYXJlbnRQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0UHJvdG90eXBlKTtcbiAgcmV0dXJuICFvYmplY3RQYXJlbnRQcm90b3R5cGU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYmFja2VuZFRvRnJvbnRlbmRTZXJpYWxpemVkRWxlbWVudE1hcHBlcihcbiAgZWxlbWVudDogU2VyaWFsaXplZEVsZW1lbnRCYWNrZW5kLFxuKTogU2VyaWFsaXplZEVsZW1lbnRGcm9udGVuZCB7XG4gIGNvbnN0IHtmb3JtYXR0ZWREaXNwbGF5TmFtZSwgaG9jRGlzcGxheU5hbWVzLCBjb21waWxlZFdpdGhGb3JnZXR9ID1cbiAgICBwYXJzZUVsZW1lbnREaXNwbGF5TmFtZUZyb21CYWNrZW5kKGVsZW1lbnQuZGlzcGxheU5hbWUsIGVsZW1lbnQudHlwZSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5lbGVtZW50LFxuICAgIGRpc3BsYXlOYW1lOiBmb3JtYXR0ZWREaXNwbGF5TmFtZSxcbiAgICBob2NEaXNwbGF5TmFtZXMsXG4gICAgY29tcGlsZWRXaXRoRm9yZ2V0LFxuICB9O1xufVxuXG4vLyBDaHJvbWUgbm9ybWFsaXplcyB1cmxzIGxpa2Ugd2VicGFjay1pbnRlcm5hbHM6Ly8gYnV0IG5ldyBVUkwgZG9uJ3QsIHNvIGNhbm5vdCB1c2UgbmV3IFVSTCBoZXJlLlxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB1cmwucmVwbGFjZSgnLy4vJywgJy8nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldElzUmVsb2FkQW5kUHJvZmlsZVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgLy8gTm90aWZ5IHRoZSBmcm9udGVuZCBpZiB0aGUgYmFja2VuZCBzdXBwb3J0cyB0aGUgU3RvcmFnZSBBUEkgKGUuZy4gbG9jYWxTdG9yYWdlKS5cbiAgLy8gSWYgbm90LCBmZWF0dXJlcyBsaWtlIHJlbG9hZC1hbmQtcHJvZmlsZSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBhbmQgbXVzdCBiZSBkaXNhYmxlZC5cbiAgbGV0IGlzQmFja2VuZFN0b3JhZ2VBUElTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndGVzdCcpO1xuICAgIGlzQmFja2VuZFN0b3JhZ2VBUElTdXBwb3J0ZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge31cblxuICByZXR1cm4gaXNCYWNrZW5kU3RvcmFnZUFQSVN1cHBvcnRlZCAmJiBpc1N5bmNocm9ub3VzWEhSU3VwcG9ydGVkKCk7XG59XG5cbi8vIEV4cGVjdGVkIHRvIGJlIHVzZWQgb25seSBieSBicm93c2VyIGV4dGVuc2lvbiBhbmQgcmVhY3QtZGV2dG9vbHMtaW5saW5lXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWZSZWxvYWRlZEFuZFByb2ZpbGluZygpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBzZXNzaW9uU3RvcmFnZUdldEl0ZW0oU0VTU0lPTl9TVE9SQUdFX1JFTE9BRF9BTkRfUFJPRklMRV9LRVkpID09PSAndHJ1ZSdcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2ZpbGluZ1NldHRpbmdzKCk6IFByb2ZpbGluZ1NldHRpbmdzIHtcbiAgcmV0dXJuIHtcbiAgICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnM6XG4gICAgICBzZXNzaW9uU3RvcmFnZUdldEl0ZW0oU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSkgPT09XG4gICAgICAndHJ1ZScsXG4gICAgcmVjb3JkVGltZWxpbmU6XG4gICAgICBzZXNzaW9uU3RvcmFnZUdldEl0ZW0oU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9USU1FTElORV9LRVkpID09PSAndHJ1ZScsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblJlbG9hZEFuZFByb2ZpbGUoXG4gIHJlY29yZENoYW5nZURlc2NyaXB0aW9uczogYm9vbGVhbixcbiAgcmVjb3JkVGltZWxpbmU6IGJvb2xlYW4sXG4pOiB2b2lkIHtcbiAgc2Vzc2lvblN0b3JhZ2VTZXRJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZLCAndHJ1ZScpO1xuICBzZXNzaW9uU3RvcmFnZVNldEl0ZW0oXG4gICAgU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9DSEFOR0VfREVTQ1JJUFRJT05TX0tFWSxcbiAgICByZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICApO1xuICBzZXNzaW9uU3RvcmFnZVNldEl0ZW0oXG4gICAgU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9USU1FTElORV9LRVksXG4gICAgcmVjb3JkVGltZWxpbmUgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25SZWxvYWRBbmRQcm9maWxlRmxhZ3NSZXNldCgpOiB2b2lkIHtcbiAgc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZKTtcbiAgc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVkpO1xuICBzZXNzaW9uU3RvcmFnZVJlbW92ZUl0ZW0oU0VTU0lPTl9TVE9SQUdFX1JFQ09SRF9USU1FTElORV9LRVkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../react-devtools-shared/src/utils.js\n");

/***/ }),

/***/ "../shared/ReactFeatureFlags.js":
/*!**************************************!*\
  !*** ../shared/ReactFeatureFlags.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"alwaysThrottleRetries\": () => (/* binding */ alwaysThrottleRetries),\n/* harmony export */   \"consoleManagedByDevToolsDuringStrictMode\": () => (/* binding */ consoleManagedByDevToolsDuringStrictMode),\n/* harmony export */   \"debugRenderPhaseSideEffectsForStrictMode\": () => (/* binding */ debugRenderPhaseSideEffectsForStrictMode),\n/* harmony export */   \"disableClientCache\": () => (/* binding */ disableClientCache),\n/* harmony export */   \"disableCommentsAsDOMContainers\": () => (/* binding */ disableCommentsAsDOMContainers),\n/* harmony export */   \"disableDefaultPropsExceptForClasses\": () => (/* binding */ disableDefaultPropsExceptForClasses),\n/* harmony export */   \"disableIEWorkarounds\": () => (/* binding */ disableIEWorkarounds),\n/* harmony export */   \"disableInputAttributeSyncing\": () => (/* binding */ disableInputAttributeSyncing),\n/* harmony export */   \"disableLegacyContext\": () => (/* binding */ disableLegacyContext),\n/* harmony export */   \"disableLegacyContextForFunctionComponents\": () => (/* binding */ disableLegacyContextForFunctionComponents),\n/* harmony export */   \"disableLegacyMode\": () => (/* binding */ disableLegacyMode),\n/* harmony export */   \"disableSchedulerTimeoutInWorkLoop\": () => (/* binding */ disableSchedulerTimeoutInWorkLoop),\n/* harmony export */   \"disableTextareaChildren\": () => (/* binding */ disableTextareaChildren),\n/* harmony export */   \"enableAsyncActions\": () => (/* binding */ enableAsyncActions),\n/* harmony export */   \"enableAsyncDebugInfo\": () => (/* binding */ enableAsyncDebugInfo),\n/* harmony export */   \"enableAsyncIterableChildren\": () => (/* binding */ enableAsyncIterableChildren),\n/* harmony export */   \"enableBinaryFlight\": () => (/* binding */ enableBinaryFlight),\n/* harmony export */   \"enableCPUSuspense\": () => (/* binding */ enableCPUSuspense),\n/* harmony export */   \"enableCache\": () => (/* binding */ enableCache),\n/* harmony export */   \"enableComponentPerformanceTrack\": () => (/* binding */ enableComponentPerformanceTrack),\n/* harmony export */   \"enableComponentStackLocations\": () => (/* binding */ enableComponentStackLocations),\n/* harmony export */   \"enableContextProfiling\": () => (/* binding */ enableContextProfiling),\n/* harmony export */   \"enableCreateEventHandleAPI\": () => (/* binding */ enableCreateEventHandleAPI),\n/* harmony export */   \"enableDO_NOT_USE_disableStrictPassiveEffect\": () => (/* binding */ enableDO_NOT_USE_disableStrictPassiveEffect),\n/* harmony export */   \"enableDebugTracing\": () => (/* binding */ enableDebugTracing),\n/* harmony export */   \"enableDeferRootSchedulingToMicrotask\": () => (/* binding */ enableDeferRootSchedulingToMicrotask),\n/* harmony export */   \"enableFabricCompleteRootInCommitPhase\": () => (/* binding */ enableFabricCompleteRootInCommitPhase),\n/* harmony export */   \"enableFilterEmptyStringAttributesDOM\": () => (/* binding */ enableFilterEmptyStringAttributesDOM),\n/* harmony export */   \"enableFizzExternalRuntime\": () => (/* binding */ enableFizzExternalRuntime),\n/* harmony export */   \"enableFlightReadableStream\": () => (/* binding */ enableFlightReadableStream),\n/* harmony export */   \"enableGetInspectorDataForInstanceInProduction\": () => (/* binding */ enableGetInspectorDataForInstanceInProduction),\n/* harmony export */   \"enableHalt\": () => (/* binding */ enableHalt),\n/* harmony export */   \"enableHiddenSubtreeInsertionEffectCleanup\": () => (/* binding */ enableHiddenSubtreeInsertionEffectCleanup),\n/* harmony export */   \"enableInfiniteRenderLoopDetection\": () => (/* binding */ enableInfiniteRenderLoopDetection),\n/* harmony export */   \"enableLazyContextPropagation\": () => (/* binding */ enableLazyContextPropagation),\n/* harmony export */   \"enableLegacyCache\": () => (/* binding */ enableLegacyCache),\n/* harmony export */   \"enableLegacyFBSupport\": () => (/* binding */ enableLegacyFBSupport),\n/* harmony export */   \"enableLegacyHidden\": () => (/* binding */ enableLegacyHidden),\n/* harmony export */   \"enableMoveBefore\": () => (/* binding */ enableMoveBefore),\n/* harmony export */   \"enableNoCloningMemoCache\": () => (/* binding */ enableNoCloningMemoCache),\n/* harmony export */   \"enableObjectFiber\": () => (/* binding */ enableObjectFiber),\n/* harmony export */   \"enableOwnerStacks\": () => (/* binding */ enableOwnerStacks),\n/* harmony export */   \"enablePersistedModeClonedFlag\": () => (/* binding */ enablePersistedModeClonedFlag),\n/* harmony export */   \"enablePostpone\": () => (/* binding */ enablePostpone),\n/* harmony export */   \"enableProfilerCommitHooks\": () => (/* binding */ enableProfilerCommitHooks),\n/* harmony export */   \"enableProfilerNestedUpdatePhase\": () => (/* binding */ enableProfilerNestedUpdatePhase),\n/* harmony export */   \"enableProfilerTimer\": () => (/* binding */ enableProfilerTimer),\n/* harmony export */   \"enableReactTestRendererWarning\": () => (/* binding */ enableReactTestRendererWarning),\n/* harmony export */   \"enableRenderableContext\": () => (/* binding */ enableRenderableContext),\n/* harmony export */   \"enableRetryLaneExpiration\": () => (/* binding */ enableRetryLaneExpiration),\n/* harmony export */   \"enableSchedulingProfiler\": () => (/* binding */ enableSchedulingProfiler),\n/* harmony export */   \"enableScopeAPI\": () => (/* binding */ enableScopeAPI),\n/* harmony export */   \"enableServerComponentLogs\": () => (/* binding */ enableServerComponentLogs),\n/* harmony export */   \"enableShallowPropDiffing\": () => (/* binding */ enableShallowPropDiffing),\n/* harmony export */   \"enableSiblingPrerendering\": () => (/* binding */ enableSiblingPrerendering),\n/* harmony export */   \"enableSuspenseAvoidThisFallback\": () => (/* binding */ enableSuspenseAvoidThisFallback),\n/* harmony export */   \"enableSuspenseAvoidThisFallbackFizz\": () => (/* binding */ enableSuspenseAvoidThisFallbackFizz),\n/* harmony export */   \"enableSuspenseCallback\": () => (/* binding */ enableSuspenseCallback),\n/* harmony export */   \"enableTaint\": () => (/* binding */ enableTaint),\n/* harmony export */   \"enableTransitionTracing\": () => (/* binding */ enableTransitionTracing),\n/* harmony export */   \"enableTrustedTypesIntegration\": () => (/* binding */ enableTrustedTypesIntegration),\n/* harmony export */   \"enableUpdaterTracking\": () => (/* binding */ enableUpdaterTracking),\n/* harmony export */   \"enableUseEffectEventHook\": () => (/* binding */ enableUseEffectEventHook),\n/* harmony export */   \"enableUseMemoCacheHook\": () => (/* binding */ enableUseMemoCacheHook),\n/* harmony export */   \"enableUseResourceEffectHook\": () => (/* binding */ enableUseResourceEffectHook),\n/* harmony export */   \"favorSafetyOverHydrationPerf\": () => (/* binding */ favorSafetyOverHydrationPerf),\n/* harmony export */   \"passChildrenWhenCloningPersistedNodes\": () => (/* binding */ passChildrenWhenCloningPersistedNodes),\n/* harmony export */   \"renameElementSymbol\": () => (/* binding */ renameElementSymbol),\n/* harmony export */   \"retryLaneExpirationMs\": () => (/* binding */ retryLaneExpirationMs),\n/* harmony export */   \"syncLaneExpirationMs\": () => (/* binding */ syncLaneExpirationMs),\n/* harmony export */   \"transitionLaneExpirationMs\": () => (/* binding */ transitionLaneExpirationMs),\n/* harmony export */   \"useModernStrictMode\": () => (/* binding */ useModernStrictMode)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\nconst enableComponentStackLocations = true; // -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\n// -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n// TODO: Finish rolling out in www\n\nconst favorSafetyOverHydrationPerf = true;\nconst enableAsyncActions = true; // Need to remove didTimeout argument from Scheduler before landing\n\nconst disableSchedulerTimeoutInWorkLoop = false; // This will break some internal tests at Meta so we need to gate this until\n// those can be fixed.\n\nconst enableDeferRootSchedulingToMicrotask = true; // TODO: Land at Meta before removing.\n\nconst disableDefaultPropsExceptForClasses = true; // -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\n\nconst enableSuspenseCallback = false; // Experimental Scope support.\n\nconst enableScopeAPI = false; // Experimental Create Event Handle API.\n\nconst enableCreateEventHandleAPI = false; // Support legacy Primer support on internal FB www\n\nconst enableLegacyFBSupport = false; // -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n\nconst enableCache = true;\nconst enableLegacyCache = true;\nconst enableBinaryFlight = true;\nconst enableFlightReadableStream = true;\nconst enableAsyncIterableChildren = true;\nconst enableTaint = true;\nconst enablePostpone = true;\nconst enableHalt = true;\n/**\n * Switches the Fabric API from doing layout in commit work instead of complete work.\n */\n\nconst enableFabricCompleteRootInCommitPhase = false;\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\n\nconst enableObjectFiber = false;\nconst enableTransitionTracing = false;\nconst enableLazyContextPropagation = true; // Expose unstable useContext for performance testing\n\nconst enableContextProfiling = false; // FB-only usage. The new API has different semantics.\n\nconst enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n\nconst enableSuspenseAvoidThisFallback = false; // Enables unstable_avoidThisFallback feature in Fizz\n\nconst enableSuspenseAvoidThisFallbackFizz = false;\nconst enableCPUSuspense = true; // Enables useMemoCache hook, intended as a compilation target for\n// auto-memoization.\n\nconst enableUseMemoCacheHook = true; // Test this at Meta before enabling.\n\nconst enableNoCloningMemoCache = false;\nconst enableUseEffectEventHook = true; // Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\n\nconst enableFizzExternalRuntime = true;\nconst alwaysThrottleRetries = true;\nconst passChildrenWhenCloningPersistedNodes = false;\nconst enableServerComponentLogs = true;\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\n\nconst enablePersistedModeClonedFlag = false;\nconst enableOwnerStacks = true;\nconst enableShallowPropDiffing = false;\nconst enableSiblingPrerendering = true;\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\n\nconst enableRetryLaneExpiration = false;\nconst retryLaneExpirationMs = 5000;\nconst syncLaneExpirationMs = 250;\nconst transitionLaneExpirationMs = 5000;\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\n\nconst enableInfiniteRenderLoopDetection = false;\n/**\n * Experimental new hook for better managing resources in effects.\n */\n\nconst enableUseResourceEffectHook = false; // -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n// Renames the internal symbol for elements since they have changed signature/constructor\n\nconst renameElementSymbol = true;\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\n\nconst enableHiddenSubtreeInsertionEffectCleanup = false;\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\n\nconst disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\n\nconst disableLegacyContextForFunctionComponents = true; // Not ready to break experimental yet.\n// Modern <StrictMode /> behaviour aligns more with what components\n// components will encounter in production, especially when used With <Offscreen />.\n// TODO: clean up legacy <StrictMode /> once tests pass WWW.\n\nconst useModernStrictMode = true; // Not ready to break experimental yet.\n// Remove IE and MsApp specific workarounds for innerHTML\n\nconst disableIEWorkarounds = true; // Filter certain DOM attributes (e.g. src, href) if their values are empty\n// strings. This prevents e.g. <img src=\"\"> from making an unnecessary HTTP\n// request for certain browsers.\n\nconst enableFilterEmptyStringAttributesDOM = true; // Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\n\nconst enableMoveBefore = false; // Disabled caching behavior of `react/cache` in client runtimes.\n\nconst disableClientCache = true; // Warn on any usage of ReactTestRenderer\n\nconst enableReactTestRendererWarning = true; // Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\n\nconst disableLegacyMode = true; // Make <Context> equivalent to <Context.Provider> instead of <Context.Consumer>\n\nconst enableRenderableContext = true; // -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\n\nconst disableCommentsAsDOMContainers = true;\nconst enableTrustedTypesIntegration = false; // Prevent the value and checked attributes from syncing with their related\n// DOM properties\n\nconst disableInputAttributeSyncing = false; // Disables children for <textarea> elements\n\nconst disableTextareaChildren = false; // -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Helps identify side effects in render-phase lifecycle hooks and setState\n// reducers by double invoking them in StrictLegacyMode.\n\nconst debugRenderPhaseSideEffectsForStrictMode = true; // Gather advanced timing metrics for Profiler subtrees.\n\nconst enableProfilerTimer = false; // Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\n\nconst enableComponentPerformanceTrack = true; // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\n\nconst enableSchedulingProfiler = !enableComponentPerformanceTrack && false; // Record durations for commit and passive effects phases.\n\nconst enableProfilerCommitHooks = false; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n\nconst enableProfilerNestedUpdatePhase = false; // Adds verbose console logging for e.g. state updates, suspense, and work loop\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nconst enableDebugTracing = false;\nconst enableAsyncDebugInfo = true; // Track which Fiber(s) schedule render work.\n\nconst enableUpdaterTracking = false; // Internal only.\n\nconst enableGetInspectorDataForInstanceInProduction = false;\nconst consoleManagedByDevToolsDuringStrictMode = true;\nconst enableDO_NOT_USE_disableStrictPassiveEffect = false;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL1JlYWN0RmVhdHVyZUZsYWdzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUdBO0FBR0E7O0FBQ0E7O0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFHQTs7QUFHQTs7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBOzs7O0FBR0E7QUFFQTs7OztBQUdBO0FBRUE7QUFFQTs7QUFHQTs7QUFHQTs7QUFHQTs7QUFFQTtBQUVBO0FBR0E7O0FBQ0E7O0FBRUE7QUFFQTtBQUdBO0FBQ0E7O0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTs7Ozs7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7O0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUNBOzs7O0FBR0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTs7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7O0FBR0E7O0FBR0E7O0FBR0E7QUFHQTtBQUNBOztBQUNBOztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQUdBOztBQUNBOztBQUdBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBR0E7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTs7QUFDQTs7QUFJQTs7QUFHQTtBQUdBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFHQTs7QUFHQTtBQUVBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncy5qcz83N2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvdyBzdHJpY3RcbiAqL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTGFuZCBvciByZW1vdmUgKHplcm8gZWZmb3J0KVxuLy9cbi8vIEZsYWdzIHRoYXQgY2FuIGxpa2VseSBiZSBkZWxldGVkIG9yIGxhbmRlZCB3aXRob3V0IGNvbnNlcXVlbmNlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IGVuYWJsZUNvbXBvbmVudFN0YWNrTG9jYXRpb25zID0gdHJ1ZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEtpbGxzd2l0Y2hcbi8vXG4vLyBGbGFncyB0aGF0IGV4aXN0IHNvbGVseSB0byB0dXJuIG9mZiBhIGNoYW5nZSBpbiBjYXNlIGl0IGNhdXNlcyBhIHJlZ3Jlc3Npb25cbi8vIHdoZW4gaXQgcm9sbHMgb3V0IHRvIHByb2QuIFdlIHNob3VsZCByZW1vdmUgdGhlc2UgYXMgc29vbiBhcyBwb3NzaWJsZS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMYW5kIG9yIHJlbW92ZSAobW9kZXJhdGUgZWZmb3J0KVxuLy9cbi8vIEZsYWdzIHRoYXQgY2FuIGJlIHByb2JhYmx5IGRlbGV0ZWQgb3IgbGFuZGVkLCBidXQgbWlnaHQgcmVxdWlyZSBleHRyYSBlZmZvcnRcbi8vIGxpa2UgbWlncmF0aW5nIGludGVybmFsIGNhbGxlcnMgb3IgcGVyZm9ybWFuY2UgdGVzdGluZy5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFRPRE86IEZpbmlzaCByb2xsaW5nIG91dCBpbiB3d3dcbmV4cG9ydCBjb25zdCBmYXZvclNhZmV0eU92ZXJIeWRyYXRpb25QZXJmID0gdHJ1ZTtcbmV4cG9ydCBjb25zdCBlbmFibGVBc3luY0FjdGlvbnMgPSB0cnVlO1xuXG4vLyBOZWVkIHRvIHJlbW92ZSBkaWRUaW1lb3V0IGFyZ3VtZW50IGZyb20gU2NoZWR1bGVyIGJlZm9yZSBsYW5kaW5nXG5leHBvcnQgY29uc3QgZGlzYWJsZVNjaGVkdWxlclRpbWVvdXRJbldvcmtMb29wID0gZmFsc2U7XG5cbi8vIFRoaXMgd2lsbCBicmVhayBzb21lIGludGVybmFsIHRlc3RzIGF0IE1ldGEgc28gd2UgbmVlZCB0byBnYXRlIHRoaXMgdW50aWxcbi8vIHRob3NlIGNhbiBiZSBmaXhlZC5cbmV4cG9ydCBjb25zdCBlbmFibGVEZWZlclJvb3RTY2hlZHVsaW5nVG9NaWNyb3Rhc2sgPSB0cnVlO1xuXG4vLyBUT0RPOiBMYW5kIGF0IE1ldGEgYmVmb3JlIHJlbW92aW5nLlxuZXhwb3J0IGNvbnN0IGRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzID0gdHJ1ZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNsYXRlZCBmb3IgcmVtb3ZhbCBpbiB0aGUgZnV0dXJlIChzaWduaWZpY2FudCBlZmZvcnQpXG4vL1xuLy8gVGhlc2UgYXJlIGV4cGVyaW1lbnRzIHRoYXQgZGlkbid0IHdvcmsgb3V0LCBhbmQgbmV2ZXIgc2hpcHBlZCwgYnV0IHdlIGNhbid0XG4vLyBkZWxldGUgZnJvbSB0aGUgY29kZWJhc2UgdW50aWwgd2UgbWlncmF0ZSBpbnRlcm5hbCBjYWxsZXJzLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQWRkIGEgY2FsbGJhY2sgcHJvcGVydHkgdG8gc3VzcGVuc2UgdG8gbm90aWZ5IHdoaWNoIHByb21pc2VzIGFyZSBjdXJyZW50bHlcbi8vIGluIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgYWxsb3dzIHJlcG9ydGluZyBhbmQgdHJhY2luZyBvZiB3aGF0IGlzIGNhdXNpbmdcbi8vIHRoZSB1c2VyIHRvIHNlZSBhIGxvYWRpbmcgc3RhdGUuXG4vL1xuLy8gQWxzbyBhbGxvd3MgaHlkcmF0aW9uIGNhbGxiYWNrcyB0byBmaXJlIHdoZW4gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGdldHNcbi8vIGh5ZHJhdGVkIG9yIGRlbGV0ZWQuXG4vL1xuLy8gVGhpcyB3aWxsIGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgYnkgdGhlIFRyYW5zaXRpb24gVHJhY2luZyBwcm9wb3NhbC5cbmV4cG9ydCBjb25zdCBlbmFibGVTdXNwZW5zZUNhbGxiYWNrID0gZmFsc2U7XG5cbi8vIEV4cGVyaW1lbnRhbCBTY29wZSBzdXBwb3J0LlxuZXhwb3J0IGNvbnN0IGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7XG5cbi8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbmV4cG9ydCBjb25zdCBlbmFibGVDcmVhdGVFdmVudEhhbmRsZUFQSSA9IGZhbHNlO1xuXG4vLyBTdXBwb3J0IGxlZ2FjeSBQcmltZXIgc3VwcG9ydCBvbiBpbnRlcm5hbCBGQiB3d3dcbmV4cG9ydCBjb25zdCBlbmFibGVMZWdhY3lGQlN1cHBvcnQgPSBmYWxzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9uZ29pbmcgZXhwZXJpbWVudHNcbi8vXG4vLyBUaGVzZSBhcmUgZmVhdHVyZXMgdGhhdCB3ZSdyZSBlaXRoZXIgYWN0aXZlbHkgZXhwbG9yaW5nIG9yIGFyZSByZWFzb25hYmx5XG4vLyBsaWtlbHkgdG8gaW5jbHVkZSBpbiBhbiB1cGNvbWluZyByZWxlYXNlLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IGVuYWJsZUNhY2hlID0gdHJ1ZTtcbmV4cG9ydCBjb25zdCBlbmFibGVMZWdhY3lDYWNoZSA9IF9fRVhQRVJJTUVOVEFMX187XG5cbmV4cG9ydCBjb25zdCBlbmFibGVCaW5hcnlGbGlnaHQgPSB0cnVlO1xuZXhwb3J0IGNvbnN0IGVuYWJsZUZsaWdodFJlYWRhYmxlU3RyZWFtID0gdHJ1ZTtcbmV4cG9ydCBjb25zdCBlbmFibGVBc3luY0l0ZXJhYmxlQ2hpbGRyZW4gPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlVGFpbnQgPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlUG9zdHBvbmUgPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlSGFsdCA9IF9fRVhQRVJJTUVOVEFMX187XG5cbi8qKlxuICogU3dpdGNoZXMgdGhlIEZhYnJpYyBBUEkgZnJvbSBkb2luZyBsYXlvdXQgaW4gY29tbWl0IHdvcmsgaW5zdGVhZCBvZiBjb21wbGV0ZSB3b3JrLlxuICovXG5leHBvcnQgY29uc3QgZW5hYmxlRmFicmljQ29tcGxldGVSb290SW5Db21taXRQaGFzZSA9IGZhbHNlO1xuXG4vKipcbiAqIFN3aXRjaGVzIEZpYmVyIGNyZWF0aW9uIHRvIGEgc2ltcGxlIG9iamVjdCBpbnN0ZWFkIG9mIGEgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmFibGVPYmplY3RGaWJlciA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gPSB0cnVlO1xuXG4vLyBFeHBvc2UgdW5zdGFibGUgdXNlQ29udGV4dCBmb3IgcGVyZm9ybWFuY2UgdGVzdGluZ1xuZXhwb3J0IGNvbnN0IGVuYWJsZUNvbnRleHRQcm9maWxpbmcgPSBmYWxzZTtcblxuLy8gRkItb25seSB1c2FnZS4gVGhlIG5ldyBBUEkgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MuXG5leHBvcnQgY29uc3QgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7XG5cbi8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuZXhwb3J0IGNvbnN0IGVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2sgPSBmYWxzZTtcbi8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaXp6XG5leHBvcnQgY29uc3QgZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFja0ZpenogPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IGVuYWJsZUNQVVN1c3BlbnNlID0gX19FWFBFUklNRU5UQUxfXztcblxuLy8gRW5hYmxlcyB1c2VNZW1vQ2FjaGUgaG9vaywgaW50ZW5kZWQgYXMgYSBjb21waWxhdGlvbiB0YXJnZXQgZm9yXG4vLyBhdXRvLW1lbW9pemF0aW9uLlxuZXhwb3J0IGNvbnN0IGVuYWJsZVVzZU1lbW9DYWNoZUhvb2sgPSB0cnVlO1xuLy8gVGVzdCB0aGlzIGF0IE1ldGEgYmVmb3JlIGVuYWJsaW5nLlxuZXhwb3J0IGNvbnN0IGVuYWJsZU5vQ2xvbmluZ01lbW9DYWNoZSA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlVXNlRWZmZWN0RXZlbnRIb29rID0gX19FWFBFUklNRU5UQUxfXztcblxuLy8gVGVzdCBpbiB3d3cgYmVmb3JlIGVuYWJsaW5nIGluIG9wZW4gc291cmNlLlxuLy8gRW5hYmxlcyBET00tc2VydmVyIHRvIHN0cmVhbSBpdHMgaW5zdHJ1Y3Rpb24gc2V0IGFzIGRhdGEtYXR0cmlidXRlc1xuLy8gKGhhbmRsZWQgd2l0aCBhbiBNdXRhdGlvbk9ic2VydmVyKSBpbnN0ZWFkIG9mIGlubGluZS1zY3JpcHRzXG5leHBvcnQgY29uc3QgZW5hYmxlRml6ekV4dGVybmFsUnVudGltZSA9IF9fRVhQRVJJTUVOVEFMX187XG5cbmV4cG9ydCBjb25zdCBhbHdheXNUaHJvdHRsZVJldHJpZXMgPSB0cnVlO1xuXG5leHBvcnQgY29uc3QgcGFzc0NoaWxkcmVuV2hlbkNsb25pbmdQZXJzaXN0ZWROb2RlcyA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlU2VydmVyQ29tcG9uZW50TG9ncyA9IHRydWU7XG5cbi8qKlxuICogRW5hYmxlcyBhIG5ldyBGaWJlciBmbGFnIHVzZWQgaW4gcGVyc2lzdGVkIG1vZGUgdG8gcmVkdWNlIHRoZSBudW1iZXJcbiAqIG9mIGNsb25lZCBob3N0IGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmFibGVQZXJzaXN0ZWRNb2RlQ2xvbmVkRmxhZyA9IGZhbHNlO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlT3duZXJTdGFja3MgPSBfX0VYUEVSSU1FTlRBTF9fO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlU2hhbGxvd1Byb3BEaWZmaW5nID0gZmFsc2U7XG5cbmV4cG9ydCBjb25zdCBlbmFibGVTaWJsaW5nUHJlcmVuZGVyaW5nID0gdHJ1ZTtcblxuLyoqXG4gKiBFbmFibGVzIGFuIGV4cGlyYXRpb24gdGltZSBmb3IgcmV0cnkgbGFuZXMgdG8gYXZvaWQgc3RhcnZhdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGVuYWJsZVJldHJ5TGFuZUV4cGlyYXRpb24gPSBmYWxzZTtcbmV4cG9ydCBjb25zdCByZXRyeUxhbmVFeHBpcmF0aW9uTXMgPSA1MDAwO1xuZXhwb3J0IGNvbnN0IHN5bmNMYW5lRXhwaXJhdGlvbk1zID0gMjUwO1xuZXhwb3J0IGNvbnN0IHRyYW5zaXRpb25MYW5lRXhwaXJhdGlvbk1zID0gNTAwMDtcblxuLyoqXG4gKiBFbmFibGVzIGEgbmV3IGVycm9yIGRldGVjdGlvbiBmb3IgaW5maW5pdGUgcmVuZGVyIGxvb3BzIGZyb20gdXBkYXRlcyBjYXVzZWRcbiAqIGJ5IHNldFN0YXRlIG9yIHNpbWlsYXIgb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50IG93bmluZyB0aGUgc3RhdGUuXG4gKi9cbmV4cG9ydCBjb25zdCBlbmFibGVJbmZpbml0ZVJlbmRlckxvb3BEZXRlY3Rpb24gPSBmYWxzZTtcblxuLyoqXG4gKiBFeHBlcmltZW50YWwgbmV3IGhvb2sgZm9yIGJldHRlciBtYW5hZ2luZyByZXNvdXJjZXMgaW4gZWZmZWN0cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGVuYWJsZVVzZVJlc291cmNlRWZmZWN0SG9vayA9IGZhbHNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVhZHkgZm9yIG5leHQgbWFqb3IuXG4vL1xuLy8gQWxpYXMgX19ORVhUX01BSk9SX18gdG8gX19FWFBFUklNRU5UQUxfXyBmb3IgZWFzaWVyIHNraW1taW5nLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gVE9ETzogQW55dGhpbmcgdGhhdCdzIHNldCB0byBgdHJ1ZWAgaW4gdGhpcyBzZWN0aW9uIHNob3VsZCBlaXRoZXIgYmUgY2xlYW5lZFxuLy8gdXAgKGlmIGl0J3Mgb24gZXZlcnl3aGVyZSwgaW5jbHVkaW5nIE1ldGEgYW5kIFJOIGJ1aWxkcykgb3IgbW92ZWQgdG8gYVxuLy8gZGlmZmVyZW50IHNlY3Rpb24gb2YgdGhpcyBmaWxlLlxuXG4vLyBjb25zdCBfX05FWFRfTUFKT1JfXyA9IF9fRVhQRVJJTUVOVEFMX187XG5cbi8vIFJlbmFtZXMgdGhlIGludGVybmFsIHN5bWJvbCBmb3IgZWxlbWVudHMgc2luY2UgdGhleSBoYXZlIGNoYW5nZWQgc2lnbmF0dXJlL2NvbnN0cnVjdG9yXG5leHBvcnQgY29uc3QgcmVuYW1lRWxlbWVudFN5bWJvbCA9IHRydWU7XG5cbi8qKlxuICogRW5hYmxlcyBhIGZpeCB0byBydW4gaW5zZXJ0aW9uIGVmZmVjdCBjbGVhbnVwIG9uIGhpZGRlbiBzdWJ0cmVlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGVuYWJsZUhpZGRlblN1YnRyZWVJbnNlcnRpb25FZmZlY3RDbGVhbnVwID0gZmFsc2U7XG5cbi8qKlxuICogUmVtb3ZlcyBsZWdhY3kgc3R5bGUgY29udGV4dCBkZWZpbmVkIHVzaW5nIHN0YXRpYyBgY29udGV4dFR5cGVzYCBhbmQgY29uc3VtZWQgd2l0aCBzdGF0aWMgYGNoaWxkQ29udGV4dFR5cGVzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IGRpc2FibGVMZWdhY3lDb250ZXh0ID0gdHJ1ZTtcbi8qKlxuICogUmVtb3ZlcyBsZWdhY3kgc3R5bGUgY29udGV4dCBqdXN0IGZyb20gZnVuY3Rpb24gY29tcG9uZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGRpc2FibGVMZWdhY3lDb250ZXh0Rm9yRnVuY3Rpb25Db21wb25lbnRzID0gdHJ1ZTtcblxuLy8gTm90IHJlYWR5IHRvIGJyZWFrIGV4cGVyaW1lbnRhbCB5ZXQuXG4vLyBNb2Rlcm4gPFN0cmljdE1vZGUgLz4gYmVoYXZpb3VyIGFsaWducyBtb3JlIHdpdGggd2hhdCBjb21wb25lbnRzXG4vLyBjb21wb25lbnRzIHdpbGwgZW5jb3VudGVyIGluIHByb2R1Y3Rpb24sIGVzcGVjaWFsbHkgd2hlbiB1c2VkIFdpdGggPE9mZnNjcmVlbiAvPi5cbi8vIFRPRE86IGNsZWFuIHVwIGxlZ2FjeSA8U3RyaWN0TW9kZSAvPiBvbmNlIHRlc3RzIHBhc3MgV1dXLlxuZXhwb3J0IGNvbnN0IHVzZU1vZGVyblN0cmljdE1vZGUgPSB0cnVlO1xuXG4vLyBOb3QgcmVhZHkgdG8gYnJlYWsgZXhwZXJpbWVudGFsIHlldC5cbi8vIFJlbW92ZSBJRSBhbmQgTXNBcHAgc3BlY2lmaWMgd29ya2Fyb3VuZHMgZm9yIGlubmVySFRNTFxuZXhwb3J0IGNvbnN0IGRpc2FibGVJRVdvcmthcm91bmRzID0gdHJ1ZTtcblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5XG4vLyBzdHJpbmdzLiBUaGlzIHByZXZlbnRzIGUuZy4gPGltZyBzcmM9XCJcIj4gZnJvbSBtYWtpbmcgYW4gdW5uZWNlc3NhcnkgSFRUUFxuLy8gcmVxdWVzdCBmb3IgY2VydGFpbiBicm93c2Vycy5cbmV4cG9ydCBjb25zdCBlbmFibGVGaWx0ZXJFbXB0eVN0cmluZ0F0dHJpYnV0ZXNET00gPSB0cnVlO1xuXG4vLyBFbmFibGUgdGhlIG1vdmVCZWZvcmUoKSBhbHRlcm5hdGl2ZSB0byBpbnNlcnRCZWZvcmUoKS4gVGhpcyBwcmVzZXJ2ZXMgc3RhdGVzIG9mIG1vdmVzLlxuZXhwb3J0IGNvbnN0IGVuYWJsZU1vdmVCZWZvcmUgPSBmYWxzZTtcblxuLy8gRGlzYWJsZWQgY2FjaGluZyBiZWhhdmlvciBvZiBgcmVhY3QvY2FjaGVgIGluIGNsaWVudCBydW50aW1lcy5cbmV4cG9ydCBjb25zdCBkaXNhYmxlQ2xpZW50Q2FjaGUgPSB0cnVlO1xuXG4vLyBXYXJuIG9uIGFueSB1c2FnZSBvZiBSZWFjdFRlc3RSZW5kZXJlclxuZXhwb3J0IGNvbnN0IGVuYWJsZVJlYWN0VGVzdFJlbmRlcmVyV2FybmluZyA9IHRydWU7XG5cbi8vIERpc2FibGVzIGxlZ2FjeSBtb2RlXG4vLyBUaGlzIGFsbG93cyB1cyB0byBsYW5kIGJyZWFraW5nIGNoYW5nZXMgdG8gcmVtb3ZlIGxlZ2FjeSBtb2RlIEFQSXMgaW4gZXhwZXJpbWVudGFsIGJ1aWxkc1xuLy8gYmVmb3JlIHJlbW92aW5nIHRoZW0gaW4gc3RhYmxlIGluIHRoZSBuZXh0IE1ham9yXG5leHBvcnQgY29uc3QgZGlzYWJsZUxlZ2FjeU1vZGUgPSB0cnVlO1xuXG4vLyBNYWtlIDxDb250ZXh0PiBlcXVpdmFsZW50IHRvIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkIG9mIDxDb250ZXh0LkNvbnN1bWVyPlxuZXhwb3J0IGNvbnN0IGVuYWJsZVJlbmRlcmFibGVDb250ZXh0ID0gdHJ1ZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENob3BwaW5nIEJsb2NrXG4vL1xuLy8gUGxhbm5lZCBmZWF0dXJlIGRlcHJlY2F0aW9ucyBhbmQgYnJlYWtpbmcgY2hhbmdlcy4gU29ydGVkIHJvdWdobHkgaW4gb3JkZXIgb2Zcbi8vIHdoZW4gd2UgcGxhbiB0byBlbmFibGUgdGhlbS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZWFjdCBET00gQ2hvcHBpbmcgQmxvY2tcbi8vXG4vLyBTaW1pbGFyIHRvIG1haW4gQ2hvcHBpbmcgQmxvY2sgYnV0IG9ubHkgZmxhZ3MgcmVsYXRlZCB0byBSZWFjdCBET00uIFRoZXNlIGFyZVxuLy8gZ3JvdXBlZCBiZWNhdXNlIHdlIHdpbGwgbGlrZWx5IGJhdGNoIGFsbCBvZiB0aGVtIGludG8gYSBzaW5nbGUgbWFqb3IgcmVsZWFzZS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIERpc2FibGUgc3VwcG9ydCBmb3IgY29tbWVudCBub2RlcyBhcyBSZWFjdCBET00gY29udGFpbmVycy4gQWxyZWFkeSBkaXNhYmxlZFxuLy8gaW4gb3BlbiBzb3VyY2UsIGJ1dCB3d3cgY29kZWJhc2Ugc3RpbGwgcmVsaWVzIG9uIGl0LiBOZWVkIHRvIHJlbW92ZS5cbmV4cG9ydCBjb25zdCBkaXNhYmxlQ29tbWVudHNBc0RPTUNvbnRhaW5lcnMgPSB0cnVlO1xuXG5leHBvcnQgY29uc3QgZW5hYmxlVHJ1c3RlZFR5cGVzSW50ZWdyYXRpb24gPSBmYWxzZTtcblxuLy8gUHJldmVudCB0aGUgdmFsdWUgYW5kIGNoZWNrZWQgYXR0cmlidXRlcyBmcm9tIHN5bmNpbmcgd2l0aCB0aGVpciByZWxhdGVkXG4vLyBET00gcHJvcGVydGllc1xuZXhwb3J0IGNvbnN0IGRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcgPSBmYWxzZTtcblxuLy8gRGlzYWJsZXMgY2hpbGRyZW4gZm9yIDx0ZXh0YXJlYT4gZWxlbWVudHNcbmV4cG9ydCBjb25zdCBkaXNhYmxlVGV4dGFyZWFDaGlsZHJlbiA9IGZhbHNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVidWdnaW5nIGFuZCBEZXZUb29sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIHJlbmRlci1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlXG4vLyByZWR1Y2VycyBieSBkb3VibGUgaW52b2tpbmcgdGhlbSBpbiBTdHJpY3RMZWdhY3lNb2RlLlxuZXhwb3J0IGNvbnN0IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgPSBfX0RFVl9fO1xuXG4vLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxuZXhwb3J0IGNvbnN0IGVuYWJsZVByb2ZpbGVyVGltZXIgPSBfX1BST0ZJTEVfXztcblxuLy8gQWRkcyBwZXJmb3JtYW5jZS5tZWFzdXJlKCkgbWFya3MgdXNpbmcgQ2hyb21lIGV4dGVuc2lvbnMgdG8gYWxsb3cgZm9ybWF0dGVkXG4vLyBDb21wb25lbnQgcmVuZGVyaW5nIHRyYWNrcyB0byBzaG93IHVwIGluIHRoZSBQZXJmb3JtYW5jZSB0YWIuXG4vLyBUaGlzIGZsYWcgd2lsbCBiZSB1c2VkIGZvciBib3RoIFNlcnZlciBDb21wb25lbnQgYW5kIENsaWVudCBDb21wb25lbnQgdHJhY2tzLlxuLy8gQWxsIGNhbGxzIHNob3VsZCBhbHNvIGJlIGdhdGVkIG9uIGVuYWJsZVByb2ZpbGVyVGltZXIuXG5leHBvcnQgY29uc3QgZW5hYmxlQ29tcG9uZW50UGVyZm9ybWFuY2VUcmFjayA9IF9fRVhQRVJJTUVOVEFMX187XG5cbi8vIEFkZHMgdXNlciB0aW1pbmcgbWFya3MgZm9yIGUuZy4gc3RhdGUgdXBkYXRlcywgc3VzcGVuc2UsIGFuZCB3b3JrIGxvb3Agc3R1ZmYsXG4vLyBmb3IgYW4gZXhwZXJpbWVudGFsIHRpbWVsaW5lIHRvb2wuXG5leHBvcnQgY29uc3QgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyOiBib29sZWFuID1cbiAgIWVuYWJsZUNvbXBvbmVudFBlcmZvcm1hbmNlVHJhY2sgJiYgX19QUk9GSUxFX187XG5cbi8vIFJlY29yZCBkdXJhdGlvbnMgZm9yIGNvbW1pdCBhbmQgcGFzc2l2ZSBlZmZlY3RzIHBoYXNlcy5cbmV4cG9ydCBjb25zdCBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzID0gX19QUk9GSUxFX187XG5cbi8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG5leHBvcnQgY29uc3QgZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVQaGFzZSA9IF9fUFJPRklMRV9fO1xuXG4vLyBBZGRzIHZlcmJvc2UgY29uc29sZSBsb2dnaW5nIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cbmV4cG9ydCBjb25zdCBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IGVuYWJsZUFzeW5jRGVidWdJbmZvID0gX19FWFBFUklNRU5UQUxfXztcblxuLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5leHBvcnQgY29uc3QgZW5hYmxlVXBkYXRlclRyYWNraW5nID0gX19QUk9GSUxFX187XG5cbi8vIEludGVybmFsIG9ubHkuXG5leHBvcnQgY29uc3QgZW5hYmxlR2V0SW5zcGVjdG9yRGF0YUZvckluc3RhbmNlSW5Qcm9kdWN0aW9uID0gZmFsc2U7XG5cbmV4cG9ydCBjb25zdCBjb25zb2xlTWFuYWdlZEJ5RGV2VG9vbHNEdXJpbmdTdHJpY3RNb2RlID0gdHJ1ZTtcblxuZXhwb3J0IGNvbnN0IGVuYWJsZURPX05PVF9VU0VfZGlzYWJsZVN0cmljdFBhc3NpdmVFZmZlY3QgPSBmYWxzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../shared/ReactFeatureFlags.js\n");

/***/ }),

/***/ "../shared/ReactSymbols.js":
/*!*********************************!*\
  !*** ../shared/ReactSymbols.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ASYNC_ITERATOR\": () => (/* binding */ ASYNC_ITERATOR),\n/* harmony export */   \"REACT_CONSUMER_TYPE\": () => (/* binding */ REACT_CONSUMER_TYPE),\n/* harmony export */   \"REACT_CONTEXT_TYPE\": () => (/* binding */ REACT_CONTEXT_TYPE),\n/* harmony export */   \"REACT_DEBUG_TRACING_MODE_TYPE\": () => (/* binding */ REACT_DEBUG_TRACING_MODE_TYPE),\n/* harmony export */   \"REACT_ELEMENT_TYPE\": () => (/* binding */ REACT_ELEMENT_TYPE),\n/* harmony export */   \"REACT_FORWARD_REF_TYPE\": () => (/* binding */ REACT_FORWARD_REF_TYPE),\n/* harmony export */   \"REACT_FRAGMENT_TYPE\": () => (/* binding */ REACT_FRAGMENT_TYPE),\n/* harmony export */   \"REACT_LAZY_TYPE\": () => (/* binding */ REACT_LAZY_TYPE),\n/* harmony export */   \"REACT_LEGACY_ELEMENT_TYPE\": () => (/* binding */ REACT_LEGACY_ELEMENT_TYPE),\n/* harmony export */   \"REACT_LEGACY_HIDDEN_TYPE\": () => (/* binding */ REACT_LEGACY_HIDDEN_TYPE),\n/* harmony export */   \"REACT_MEMO_CACHE_SENTINEL\": () => (/* binding */ REACT_MEMO_CACHE_SENTINEL),\n/* harmony export */   \"REACT_MEMO_TYPE\": () => (/* binding */ REACT_MEMO_TYPE),\n/* harmony export */   \"REACT_OFFSCREEN_TYPE\": () => (/* binding */ REACT_OFFSCREEN_TYPE),\n/* harmony export */   \"REACT_PORTAL_TYPE\": () => (/* binding */ REACT_PORTAL_TYPE),\n/* harmony export */   \"REACT_POSTPONE_TYPE\": () => (/* binding */ REACT_POSTPONE_TYPE),\n/* harmony export */   \"REACT_PROFILER_TYPE\": () => (/* binding */ REACT_PROFILER_TYPE),\n/* harmony export */   \"REACT_PROVIDER_TYPE\": () => (/* binding */ REACT_PROVIDER_TYPE),\n/* harmony export */   \"REACT_SCOPE_TYPE\": () => (/* binding */ REACT_SCOPE_TYPE),\n/* harmony export */   \"REACT_STRICT_MODE_TYPE\": () => (/* binding */ REACT_STRICT_MODE_TYPE),\n/* harmony export */   \"REACT_SUSPENSE_LIST_TYPE\": () => (/* binding */ REACT_SUSPENSE_LIST_TYPE),\n/* harmony export */   \"REACT_SUSPENSE_TYPE\": () => (/* binding */ REACT_SUSPENSE_TYPE),\n/* harmony export */   \"REACT_TRACING_MARKER_TYPE\": () => (/* binding */ REACT_TRACING_MARKER_TYPE),\n/* harmony export */   \"getIteratorFn\": () => (/* binding */ getIteratorFn)\n/* harmony export */ });\n/* harmony import */ var shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shared/ReactFeatureFlags */ \"../shared/ReactFeatureFlags.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n // ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\n\nconst REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element');\nconst REACT_ELEMENT_TYPE = shared_ReactFeatureFlags__WEBPACK_IMPORTED_MODULE_0__.renameElementSymbol ? Symbol.for('react.transitional.element') : REACT_LEGACY_ELEMENT_TYPE;\nconst REACT_PORTAL_TYPE = Symbol.for('react.portal');\nconst REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nconst REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nconst REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nconst REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nconst REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nconst REACT_CONTEXT_TYPE = Symbol.for('react.context');\nconst REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nconst REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nconst REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nconst REACT_MEMO_TYPE = Symbol.for('react.memo');\nconst REACT_LAZY_TYPE = Symbol.for('react.lazy');\nconst REACT_SCOPE_TYPE = Symbol.for('react.scope');\nconst REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\nconst REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nconst REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\nconst REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\nconst REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');\nconst REACT_POSTPONE_TYPE = Symbol.for('react.postpone');\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\nconst ASYNC_ITERATOR = Symbol.asyncIterator;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL1JlYWN0U3ltYm9scy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFTQTtBQUdBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFJQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcy1yZWFjdC1kZXZ0b29scy1jb3JlLy4uL3NoYXJlZC9SZWFjdFN5bWJvbHMuanM/YzAyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5pbXBvcnQge3JlbmFtZUVsZW1lbnRTeW1ib2x9IGZyb20gJ3NoYXJlZC9SZWFjdEZlYXR1cmVGbGFncyc7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbmV4cG9ydCBjb25zdCBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFOiBzeW1ib2wgPSByZW5hbWVFbGVtZW50U3ltYm9sXG4gID8gU3ltYm9sLmZvcigncmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnQnKVxuICA6IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEU7XG5leHBvcnQgY29uc3QgUkVBQ1RfUE9SVEFMX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX0ZSQUdNRU5UX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG5leHBvcnQgY29uc3QgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbmV4cG9ydCBjb25zdCBSRUFDVF9QUk9GSUxFUl9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX1BST1ZJREVSX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7IC8vIFRPRE86IERlbGV0ZSB3aXRoIGVuYWJsZVJlbmRlcmFibGVDb250ZXh0XG5leHBvcnQgY29uc3QgUkVBQ1RfQ09OU1VNRVJfVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QuY29uc3VtZXInKTtcbmV4cG9ydCBjb25zdCBSRUFDVF9DT05URVhUX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX1NVU1BFTlNFX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG5leHBvcnQgY29uc3QgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKFxuICAncmVhY3Quc3VzcGVuc2VfbGlzdCcsXG4pO1xuZXhwb3J0IGNvbnN0IFJFQUNUX01FTU9fVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX0xBWllfVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX1NDT1BFX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG5leHBvcnQgY29uc3QgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoXG4gICdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyxcbik7XG5leHBvcnQgY29uc3QgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6IHN5bWJvbCA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuZXhwb3J0IGNvbnN0IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTogc3ltYm9sID0gU3ltYm9sLmZvcihcbiAgJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nLFxuKTtcbmV4cG9ydCBjb25zdCBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKFxuICAncmVhY3QudHJhY2luZ19tYXJrZXInLFxuKTtcblxuZXhwb3J0IGNvbnN0IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw6IHN5bWJvbCA9IFN5bWJvbC5mb3IoXG4gICdyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsJyxcbik7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9QT1NUUE9ORV9UWVBFOiBzeW1ib2wgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3N0cG9uZScpO1xuXG5jb25zdCBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG5jb25zdCBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZTogP2FueSk6ID8oKSA9PiA/SXRlcmF0b3I8YW55PiB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1heWJlSXRlcmF0b3IgPVxuICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgIG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IEFTWU5DX0lURVJBVE9SID0gU3ltYm9sLmFzeW5jSXRlcmF0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../shared/ReactSymbols.js\n");

/***/ }),

/***/ "../shared/isArray.js":
/*!****************************!*\
  !*** ../shared/isArray.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArray);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hhcmVkL2lzQXJyYXkuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7OztBQVdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vc2hhcmVkL2lzQXJyYXkuanM/ZDkzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqL1xuXG5kZWNsYXJlIGZ1bmN0aW9uIGlzQXJyYXkoYTogbWl4ZWQpOiBib29sZWFuICVjaGVja3MoQXJyYXkuaXNBcnJheShhKSk7XG5cbmNvbnN0IGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gaXNBcnJheShhOiBtaXhlZCk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../shared/isArray.js\n");

/***/ }),

/***/ "bufferutil":
/*!*****************************!*\
  !*** external "bufferutil" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("bufferutil");

/***/ }),

/***/ "utf-8-validate":
/*!*********************************!*\
  !*** external "utf-8-validate" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("utf-8-validate");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "../../node_modules/json5/dist/index.mjs":
/*!***********************************************!*\
  !*** ../../node_modules/json5/dist/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// This is a generated file. Do not edit.\nvar Space_Separator = /[\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\nvar ID_Start = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE83\\uDE86-\\uDE89\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\nvar ID_Continue = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF9\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE83\\uDE86-\\uDE99\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\n\nvar unicode = {\n\tSpace_Separator: Space_Separator,\n\tID_Start: ID_Start,\n\tID_Continue: ID_Continue\n};\n\nvar util = {\n    isSpaceSeparator (c) {\n        return typeof c === 'string' && unicode.Space_Separator.test(c)\n    },\n\n    isIdStartChar (c) {\n        return typeof c === 'string' && (\n            (c >= 'a' && c <= 'z') ||\n        (c >= 'A' && c <= 'Z') ||\n        (c === '$') || (c === '_') ||\n        unicode.ID_Start.test(c)\n        )\n    },\n\n    isIdContinueChar (c) {\n        return typeof c === 'string' && (\n            (c >= 'a' && c <= 'z') ||\n        (c >= 'A' && c <= 'Z') ||\n        (c >= '0' && c <= '9') ||\n        (c === '$') || (c === '_') ||\n        (c === '\\u200C') || (c === '\\u200D') ||\n        unicode.ID_Continue.test(c)\n        )\n    },\n\n    isDigit (c) {\n        return typeof c === 'string' && /[0-9]/.test(c)\n    },\n\n    isHexDigit (c) {\n        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)\n    },\n};\n\nlet source;\nlet parseState;\nlet stack;\nlet pos;\nlet line;\nlet column;\nlet token;\nlet key;\nlet root;\n\nvar parse = function parse (text, reviver) {\n    source = String(text);\n    parseState = 'start';\n    stack = [];\n    pos = 0;\n    line = 1;\n    column = 0;\n    token = undefined;\n    key = undefined;\n    root = undefined;\n\n    do {\n        token = lex();\n\n        // This code is unreachable.\n        // if (!parseStates[parseState]) {\n        //     throw invalidParseState()\n        // }\n\n        parseStates[parseState]();\n    } while (token.type !== 'eof')\n\n    if (typeof reviver === 'function') {\n        return internalize({'': root}, '', reviver)\n    }\n\n    return root\n};\n\nfunction internalize (holder, name, reviver) {\n    const value = holder[name];\n    if (value != null && typeof value === 'object') {\n        for (const key in value) {\n            const replacement = internalize(value, key, reviver);\n            if (replacement === undefined) {\n                delete value[key];\n            } else {\n                value[key] = replacement;\n            }\n        }\n    }\n\n    return reviver.call(holder, name, value)\n}\n\nlet lexState;\nlet buffer;\nlet doubleQuote;\nlet sign;\nlet c;\n\nfunction lex () {\n    lexState = 'default';\n    buffer = '';\n    doubleQuote = false;\n    sign = 1;\n\n    for (;;) {\n        c = peek();\n\n        // This code is unreachable.\n        // if (!lexStates[lexState]) {\n        //     throw invalidLexState(lexState)\n        // }\n\n        const token = lexStates[lexState]();\n        if (token) {\n            return token\n        }\n    }\n}\n\nfunction peek () {\n    if (source[pos]) {\n        return String.fromCodePoint(source.codePointAt(pos))\n    }\n}\n\nfunction read () {\n    const c = peek();\n\n    if (c === '\\n') {\n        line++;\n        column = 0;\n    } else if (c) {\n        column += c.length;\n    } else {\n        column++;\n    }\n\n    if (c) {\n        pos += c.length;\n    }\n\n    return c\n}\n\nconst lexStates = {\n    default () {\n        switch (c) {\n        case '\\t':\n        case '\\v':\n        case '\\f':\n        case ' ':\n        case '\\u00A0':\n        case '\\uFEFF':\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n            read();\n            return\n\n        case '/':\n            read();\n            lexState = 'comment';\n            return\n\n        case undefined:\n            read();\n            return newToken('eof')\n        }\n\n        if (util.isSpaceSeparator(c)) {\n            read();\n            return\n        }\n\n        // This code is unreachable.\n        // if (!lexStates[parseState]) {\n        //     throw invalidLexState(parseState)\n        // }\n\n        return lexStates[parseState]()\n    },\n\n    comment () {\n        switch (c) {\n        case '*':\n            read();\n            lexState = 'multiLineComment';\n            return\n\n        case '/':\n            read();\n            lexState = 'singleLineComment';\n            return\n        }\n\n        throw invalidChar(read())\n    },\n\n    multiLineComment () {\n        switch (c) {\n        case '*':\n            read();\n            lexState = 'multiLineCommentAsterisk';\n            return\n\n        case undefined:\n            throw invalidChar(read())\n        }\n\n        read();\n    },\n\n    multiLineCommentAsterisk () {\n        switch (c) {\n        case '*':\n            read();\n            return\n\n        case '/':\n            read();\n            lexState = 'default';\n            return\n\n        case undefined:\n            throw invalidChar(read())\n        }\n\n        read();\n        lexState = 'multiLineComment';\n    },\n\n    singleLineComment () {\n        switch (c) {\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n            read();\n            lexState = 'default';\n            return\n\n        case undefined:\n            read();\n            return newToken('eof')\n        }\n\n        read();\n    },\n\n    value () {\n        switch (c) {\n        case '{':\n        case '[':\n            return newToken('punctuator', read())\n\n        case 'n':\n            read();\n            literal('ull');\n            return newToken('null', null)\n\n        case 't':\n            read();\n            literal('rue');\n            return newToken('boolean', true)\n\n        case 'f':\n            read();\n            literal('alse');\n            return newToken('boolean', false)\n\n        case '-':\n        case '+':\n            if (read() === '-') {\n                sign = -1;\n            }\n\n            lexState = 'sign';\n            return\n\n        case '.':\n            buffer = read();\n            lexState = 'decimalPointLeading';\n            return\n\n        case '0':\n            buffer = read();\n            lexState = 'zero';\n            return\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            buffer = read();\n            lexState = 'decimalInteger';\n            return\n\n        case 'I':\n            read();\n            literal('nfinity');\n            return newToken('numeric', Infinity)\n\n        case 'N':\n            read();\n            literal('aN');\n            return newToken('numeric', NaN)\n\n        case '\"':\n        case \"'\":\n            doubleQuote = (read() === '\"');\n            buffer = '';\n            lexState = 'string';\n            return\n        }\n\n        throw invalidChar(read())\n    },\n\n    identifierNameStartEscape () {\n        if (c !== 'u') {\n            throw invalidChar(read())\n        }\n\n        read();\n        const u = unicodeEscape();\n        switch (u) {\n        case '$':\n        case '_':\n            break\n\n        default:\n            if (!util.isIdStartChar(u)) {\n                throw invalidIdentifier()\n            }\n\n            break\n        }\n\n        buffer += u;\n        lexState = 'identifierName';\n    },\n\n    identifierName () {\n        switch (c) {\n        case '$':\n        case '_':\n        case '\\u200C':\n        case '\\u200D':\n            buffer += read();\n            return\n\n        case '\\\\':\n            read();\n            lexState = 'identifierNameEscape';\n            return\n        }\n\n        if (util.isIdContinueChar(c)) {\n            buffer += read();\n            return\n        }\n\n        return newToken('identifier', buffer)\n    },\n\n    identifierNameEscape () {\n        if (c !== 'u') {\n            throw invalidChar(read())\n        }\n\n        read();\n        const u = unicodeEscape();\n        switch (u) {\n        case '$':\n        case '_':\n        case '\\u200C':\n        case '\\u200D':\n            break\n\n        default:\n            if (!util.isIdContinueChar(u)) {\n                throw invalidIdentifier()\n            }\n\n            break\n        }\n\n        buffer += u;\n        lexState = 'identifierName';\n    },\n\n    sign () {\n        switch (c) {\n        case '.':\n            buffer = read();\n            lexState = 'decimalPointLeading';\n            return\n\n        case '0':\n            buffer = read();\n            lexState = 'zero';\n            return\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            buffer = read();\n            lexState = 'decimalInteger';\n            return\n\n        case 'I':\n            read();\n            literal('nfinity');\n            return newToken('numeric', sign * Infinity)\n\n        case 'N':\n            read();\n            literal('aN');\n            return newToken('numeric', NaN)\n        }\n\n        throw invalidChar(read())\n    },\n\n    zero () {\n        switch (c) {\n        case '.':\n            buffer += read();\n            lexState = 'decimalPoint';\n            return\n\n        case 'e':\n        case 'E':\n            buffer += read();\n            lexState = 'decimalExponent';\n            return\n\n        case 'x':\n        case 'X':\n            buffer += read();\n            lexState = 'hexadecimal';\n            return\n        }\n\n        return newToken('numeric', sign * 0)\n    },\n\n    decimalInteger () {\n        switch (c) {\n        case '.':\n            buffer += read();\n            lexState = 'decimalPoint';\n            return\n\n        case 'e':\n        case 'E':\n            buffer += read();\n            lexState = 'decimalExponent';\n            return\n        }\n\n        if (util.isDigit(c)) {\n            buffer += read();\n            return\n        }\n\n        return newToken('numeric', sign * Number(buffer))\n    },\n\n    decimalPointLeading () {\n        if (util.isDigit(c)) {\n            buffer += read();\n            lexState = 'decimalFraction';\n            return\n        }\n\n        throw invalidChar(read())\n    },\n\n    decimalPoint () {\n        switch (c) {\n        case 'e':\n        case 'E':\n            buffer += read();\n            lexState = 'decimalExponent';\n            return\n        }\n\n        if (util.isDigit(c)) {\n            buffer += read();\n            lexState = 'decimalFraction';\n            return\n        }\n\n        return newToken('numeric', sign * Number(buffer))\n    },\n\n    decimalFraction () {\n        switch (c) {\n        case 'e':\n        case 'E':\n            buffer += read();\n            lexState = 'decimalExponent';\n            return\n        }\n\n        if (util.isDigit(c)) {\n            buffer += read();\n            return\n        }\n\n        return newToken('numeric', sign * Number(buffer))\n    },\n\n    decimalExponent () {\n        switch (c) {\n        case '+':\n        case '-':\n            buffer += read();\n            lexState = 'decimalExponentSign';\n            return\n        }\n\n        if (util.isDigit(c)) {\n            buffer += read();\n            lexState = 'decimalExponentInteger';\n            return\n        }\n\n        throw invalidChar(read())\n    },\n\n    decimalExponentSign () {\n        if (util.isDigit(c)) {\n            buffer += read();\n            lexState = 'decimalExponentInteger';\n            return\n        }\n\n        throw invalidChar(read())\n    },\n\n    decimalExponentInteger () {\n        if (util.isDigit(c)) {\n            buffer += read();\n            return\n        }\n\n        return newToken('numeric', sign * Number(buffer))\n    },\n\n    hexadecimal () {\n        if (util.isHexDigit(c)) {\n            buffer += read();\n            lexState = 'hexadecimalInteger';\n            return\n        }\n\n        throw invalidChar(read())\n    },\n\n    hexadecimalInteger () {\n        if (util.isHexDigit(c)) {\n            buffer += read();\n            return\n        }\n\n        return newToken('numeric', sign * Number(buffer))\n    },\n\n    string () {\n        switch (c) {\n        case '\\\\':\n            read();\n            buffer += escape();\n            return\n\n        case '\"':\n            if (doubleQuote) {\n                read();\n                return newToken('string', buffer)\n            }\n\n            buffer += read();\n            return\n\n        case \"'\":\n            if (!doubleQuote) {\n                read();\n                return newToken('string', buffer)\n            }\n\n            buffer += read();\n            return\n\n        case '\\n':\n        case '\\r':\n            throw invalidChar(read())\n\n        case '\\u2028':\n        case '\\u2029':\n            separatorChar(c);\n            break\n\n        case undefined:\n            throw invalidChar(read())\n        }\n\n        buffer += read();\n    },\n\n    start () {\n        switch (c) {\n        case '{':\n        case '[':\n            return newToken('punctuator', read())\n\n        // This code is unreachable since the default lexState handles eof.\n        // case undefined:\n        //     return newToken('eof')\n        }\n\n        lexState = 'value';\n    },\n\n    beforePropertyName () {\n        switch (c) {\n        case '$':\n        case '_':\n            buffer = read();\n            lexState = 'identifierName';\n            return\n\n        case '\\\\':\n            read();\n            lexState = 'identifierNameStartEscape';\n            return\n\n        case '}':\n            return newToken('punctuator', read())\n\n        case '\"':\n        case \"'\":\n            doubleQuote = (read() === '\"');\n            lexState = 'string';\n            return\n        }\n\n        if (util.isIdStartChar(c)) {\n            buffer += read();\n            lexState = 'identifierName';\n            return\n        }\n\n        throw invalidChar(read())\n    },\n\n    afterPropertyName () {\n        if (c === ':') {\n            return newToken('punctuator', read())\n        }\n\n        throw invalidChar(read())\n    },\n\n    beforePropertyValue () {\n        lexState = 'value';\n    },\n\n    afterPropertyValue () {\n        switch (c) {\n        case ',':\n        case '}':\n            return newToken('punctuator', read())\n        }\n\n        throw invalidChar(read())\n    },\n\n    beforeArrayValue () {\n        if (c === ']') {\n            return newToken('punctuator', read())\n        }\n\n        lexState = 'value';\n    },\n\n    afterArrayValue () {\n        switch (c) {\n        case ',':\n        case ']':\n            return newToken('punctuator', read())\n        }\n\n        throw invalidChar(read())\n    },\n\n    end () {\n        // This code is unreachable since it's handled by the default lexState.\n        // if (c === undefined) {\n        //     read()\n        //     return newToken('eof')\n        // }\n\n        throw invalidChar(read())\n    },\n};\n\nfunction newToken (type, value) {\n    return {\n        type,\n        value,\n        line,\n        column,\n    }\n}\n\nfunction literal (s) {\n    for (const c of s) {\n        const p = peek();\n\n        if (p !== c) {\n            throw invalidChar(read())\n        }\n\n        read();\n    }\n}\n\nfunction escape () {\n    const c = peek();\n    switch (c) {\n    case 'b':\n        read();\n        return '\\b'\n\n    case 'f':\n        read();\n        return '\\f'\n\n    case 'n':\n        read();\n        return '\\n'\n\n    case 'r':\n        read();\n        return '\\r'\n\n    case 't':\n        read();\n        return '\\t'\n\n    case 'v':\n        read();\n        return '\\v'\n\n    case '0':\n        read();\n        if (util.isDigit(peek())) {\n            throw invalidChar(read())\n        }\n\n        return '\\0'\n\n    case 'x':\n        read();\n        return hexEscape()\n\n    case 'u':\n        read();\n        return unicodeEscape()\n\n    case '\\n':\n    case '\\u2028':\n    case '\\u2029':\n        read();\n        return ''\n\n    case '\\r':\n        read();\n        if (peek() === '\\n') {\n            read();\n        }\n\n        return ''\n\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n        throw invalidChar(read())\n\n    case undefined:\n        throw invalidChar(read())\n    }\n\n    return read()\n}\n\nfunction hexEscape () {\n    let buffer = '';\n    let c = peek();\n\n    if (!util.isHexDigit(c)) {\n        throw invalidChar(read())\n    }\n\n    buffer += read();\n\n    c = peek();\n    if (!util.isHexDigit(c)) {\n        throw invalidChar(read())\n    }\n\n    buffer += read();\n\n    return String.fromCodePoint(parseInt(buffer, 16))\n}\n\nfunction unicodeEscape () {\n    let buffer = '';\n    let count = 4;\n\n    while (count-- > 0) {\n        const c = peek();\n        if (!util.isHexDigit(c)) {\n            throw invalidChar(read())\n        }\n\n        buffer += read();\n    }\n\n    return String.fromCodePoint(parseInt(buffer, 16))\n}\n\nconst parseStates = {\n    start () {\n        if (token.type === 'eof') {\n            throw invalidEOF()\n        }\n\n        push();\n    },\n\n    beforePropertyName () {\n        switch (token.type) {\n        case 'identifier':\n        case 'string':\n            key = token.value;\n            parseState = 'afterPropertyName';\n            return\n\n        case 'punctuator':\n            // This code is unreachable since it's handled by the lexState.\n            // if (token.value !== '}') {\n            //     throw invalidToken()\n            // }\n\n            pop();\n            return\n\n        case 'eof':\n            throw invalidEOF()\n        }\n\n        // This code is unreachable since it's handled by the lexState.\n        // throw invalidToken()\n    },\n\n    afterPropertyName () {\n        // This code is unreachable since it's handled by the lexState.\n        // if (token.type !== 'punctuator' || token.value !== ':') {\n        //     throw invalidToken()\n        // }\n\n        if (token.type === 'eof') {\n            throw invalidEOF()\n        }\n\n        parseState = 'beforePropertyValue';\n    },\n\n    beforePropertyValue () {\n        if (token.type === 'eof') {\n            throw invalidEOF()\n        }\n\n        push();\n    },\n\n    beforeArrayValue () {\n        if (token.type === 'eof') {\n            throw invalidEOF()\n        }\n\n        if (token.type === 'punctuator' && token.value === ']') {\n            pop();\n            return\n        }\n\n        push();\n    },\n\n    afterPropertyValue () {\n        // This code is unreachable since it's handled by the lexState.\n        // if (token.type !== 'punctuator') {\n        //     throw invalidToken()\n        // }\n\n        if (token.type === 'eof') {\n            throw invalidEOF()\n        }\n\n        switch (token.value) {\n        case ',':\n            parseState = 'beforePropertyName';\n            return\n\n        case '}':\n            pop();\n        }\n\n        // This code is unreachable since it's handled by the lexState.\n        // throw invalidToken()\n    },\n\n    afterArrayValue () {\n        // This code is unreachable since it's handled by the lexState.\n        // if (token.type !== 'punctuator') {\n        //     throw invalidToken()\n        // }\n\n        if (token.type === 'eof') {\n            throw invalidEOF()\n        }\n\n        switch (token.value) {\n        case ',':\n            parseState = 'beforeArrayValue';\n            return\n\n        case ']':\n            pop();\n        }\n\n        // This code is unreachable since it's handled by the lexState.\n        // throw invalidToken()\n    },\n\n    end () {\n        // This code is unreachable since it's handled by the lexState.\n        // if (token.type !== 'eof') {\n        //     throw invalidToken()\n        // }\n    },\n};\n\nfunction push () {\n    let value;\n\n    switch (token.type) {\n    case 'punctuator':\n        switch (token.value) {\n        case '{':\n            value = {};\n            break\n\n        case '[':\n            value = [];\n            break\n        }\n\n        break\n\n    case 'null':\n    case 'boolean':\n    case 'numeric':\n    case 'string':\n        value = token.value;\n        break\n\n    // This code is unreachable.\n    // default:\n    //     throw invalidToken()\n    }\n\n    if (root === undefined) {\n        root = value;\n    } else {\n        const parent = stack[stack.length - 1];\n        if (Array.isArray(parent)) {\n            parent.push(value);\n        } else {\n            parent[key] = value;\n        }\n    }\n\n    if (value !== null && typeof value === 'object') {\n        stack.push(value);\n\n        if (Array.isArray(value)) {\n            parseState = 'beforeArrayValue';\n        } else {\n            parseState = 'beforePropertyName';\n        }\n    } else {\n        const current = stack[stack.length - 1];\n        if (current == null) {\n            parseState = 'end';\n        } else if (Array.isArray(current)) {\n            parseState = 'afterArrayValue';\n        } else {\n            parseState = 'afterPropertyValue';\n        }\n    }\n}\n\nfunction pop () {\n    stack.pop();\n\n    const current = stack[stack.length - 1];\n    if (current == null) {\n        parseState = 'end';\n    } else if (Array.isArray(current)) {\n        parseState = 'afterArrayValue';\n    } else {\n        parseState = 'afterPropertyValue';\n    }\n}\n\n// This code is unreachable.\n// function invalidParseState () {\n//     return new Error(`JSON5: invalid parse state '${parseState}'`)\n// }\n\n// This code is unreachable.\n// function invalidLexState (state) {\n//     return new Error(`JSON5: invalid lex state '${state}'`)\n// }\n\nfunction invalidChar (c) {\n    if (c === undefined) {\n        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n    }\n\n    return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)\n}\n\nfunction invalidEOF () {\n    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n}\n\n// This code is unreachable.\n// function invalidToken () {\n//     if (token.type === 'eof') {\n//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)\n//     }\n\n//     const c = String.fromCodePoint(token.value.codePointAt(0))\n//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)\n// }\n\nfunction invalidIdentifier () {\n    column -= 5;\n    return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`)\n}\n\nfunction separatorChar (c) {\n    console.warn(`JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`);\n}\n\nfunction formatChar (c) {\n    const replacements = {\n        \"'\": \"\\\\'\",\n        '\"': '\\\\\"',\n        '\\\\': '\\\\\\\\',\n        '\\b': '\\\\b',\n        '\\f': '\\\\f',\n        '\\n': '\\\\n',\n        '\\r': '\\\\r',\n        '\\t': '\\\\t',\n        '\\v': '\\\\v',\n        '\\0': '\\\\0',\n        '\\u2028': '\\\\u2028',\n        '\\u2029': '\\\\u2029',\n    };\n\n    if (replacements[c]) {\n        return replacements[c]\n    }\n\n    if (c < ' ') {\n        const hexString = c.charCodeAt(0).toString(16);\n        return '\\\\x' + ('00' + hexString).substring(hexString.length)\n    }\n\n    return c\n}\n\nfunction syntaxError (message) {\n    const err = new SyntaxError(message);\n    err.lineNumber = line;\n    err.columnNumber = column;\n    return err\n}\n\nvar stringify = function stringify (value, replacer, space) {\n    const stack = [];\n    let indent = '';\n    let propertyList;\n    let replacerFunc;\n    let gap = '';\n    let quote;\n\n    if (\n        replacer != null &&\n        typeof replacer === 'object' &&\n        !Array.isArray(replacer)\n    ) {\n        space = replacer.space;\n        quote = replacer.quote;\n        replacer = replacer.replacer;\n    }\n\n    if (typeof replacer === 'function') {\n        replacerFunc = replacer;\n    } else if (Array.isArray(replacer)) {\n        propertyList = [];\n        for (const v of replacer) {\n            let item;\n\n            if (typeof v === 'string') {\n                item = v;\n            } else if (\n                typeof v === 'number' ||\n                v instanceof String ||\n                v instanceof Number\n            ) {\n                item = String(v);\n            }\n\n            if (item !== undefined && propertyList.indexOf(item) < 0) {\n                propertyList.push(item);\n            }\n        }\n    }\n\n    if (space instanceof Number) {\n        space = Number(space);\n    } else if (space instanceof String) {\n        space = String(space);\n    }\n\n    if (typeof space === 'number') {\n        if (space > 0) {\n            space = Math.min(10, Math.floor(space));\n            gap = '          '.substr(0, space);\n        }\n    } else if (typeof space === 'string') {\n        gap = space.substr(0, 10);\n    }\n\n    return serializeProperty('', {'': value})\n\n    function serializeProperty (key, holder) {\n        let value = holder[key];\n        if (value != null) {\n            if (typeof value.toJSON5 === 'function') {\n                value = value.toJSON5(key);\n            } else if (typeof value.toJSON === 'function') {\n                value = value.toJSON(key);\n            }\n        }\n\n        if (replacerFunc) {\n            value = replacerFunc.call(holder, key, value);\n        }\n\n        if (value instanceof Number) {\n            value = Number(value);\n        } else if (value instanceof String) {\n            value = String(value);\n        } else if (value instanceof Boolean) {\n            value = value.valueOf();\n        }\n\n        switch (value) {\n        case null: return 'null'\n        case true: return 'true'\n        case false: return 'false'\n        }\n\n        if (typeof value === 'string') {\n            return quoteString(value, false)\n        }\n\n        if (typeof value === 'number') {\n            return String(value)\n        }\n\n        if (typeof value === 'object') {\n            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)\n        }\n\n        return undefined\n    }\n\n    function quoteString (value) {\n        const quotes = {\n            \"'\": 0.1,\n            '\"': 0.2,\n        };\n\n        const replacements = {\n            \"'\": \"\\\\'\",\n            '\"': '\\\\\"',\n            '\\\\': '\\\\\\\\',\n            '\\b': '\\\\b',\n            '\\f': '\\\\f',\n            '\\n': '\\\\n',\n            '\\r': '\\\\r',\n            '\\t': '\\\\t',\n            '\\v': '\\\\v',\n            '\\0': '\\\\0',\n            '\\u2028': '\\\\u2028',\n            '\\u2029': '\\\\u2029',\n        };\n\n        let product = '';\n\n        for (let i = 0; i < value.length; i++) {\n            const c = value[i];\n            switch (c) {\n            case \"'\":\n            case '\"':\n                quotes[c]++;\n                product += c;\n                continue\n\n            case '\\0':\n                if (util.isDigit(value[i + 1])) {\n                    product += '\\\\x00';\n                    continue\n                }\n            }\n\n            if (replacements[c]) {\n                product += replacements[c];\n                continue\n            }\n\n            if (c < ' ') {\n                let hexString = c.charCodeAt(0).toString(16);\n                product += '\\\\x' + ('00' + hexString).substring(hexString.length);\n                continue\n            }\n\n            product += c;\n        }\n\n        const quoteChar = quote || Object.keys(quotes).reduce((a, b) => (quotes[a] < quotes[b]) ? a : b);\n\n        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);\n\n        return quoteChar + product + quoteChar\n    }\n\n    function serializeObject (value) {\n        if (stack.indexOf(value) >= 0) {\n            throw TypeError('Converting circular structure to JSON5')\n        }\n\n        stack.push(value);\n\n        let stepback = indent;\n        indent = indent + gap;\n\n        let keys = propertyList || Object.keys(value);\n        let partial = [];\n        for (const key of keys) {\n            const propertyString = serializeProperty(key, value);\n            if (propertyString !== undefined) {\n                let member = serializeKey(key) + ':';\n                if (gap !== '') {\n                    member += ' ';\n                }\n                member += propertyString;\n                partial.push(member);\n            }\n        }\n\n        let final;\n        if (partial.length === 0) {\n            final = '{}';\n        } else {\n            let properties;\n            if (gap === '') {\n                properties = partial.join(',');\n                final = '{' + properties + '}';\n            } else {\n                let separator = ',\\n' + indent;\n                properties = partial.join(separator);\n                final = '{\\n' + indent + properties + ',\\n' + stepback + '}';\n            }\n        }\n\n        stack.pop();\n        indent = stepback;\n        return final\n    }\n\n    function serializeKey (key) {\n        if (key.length === 0) {\n            return quoteString(key, true)\n        }\n\n        const firstChar = String.fromCodePoint(key.codePointAt(0));\n        if (!util.isIdStartChar(firstChar)) {\n            return quoteString(key, true)\n        }\n\n        for (let i = firstChar.length; i < key.length; i++) {\n            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {\n                return quoteString(key, true)\n            }\n        }\n\n        return key\n    }\n\n    function serializeArray (value) {\n        if (stack.indexOf(value) >= 0) {\n            throw TypeError('Converting circular structure to JSON5')\n        }\n\n        stack.push(value);\n\n        let stepback = indent;\n        indent = indent + gap;\n\n        let partial = [];\n        for (let i = 0; i < value.length; i++) {\n            const propertyString = serializeProperty(String(i), value);\n            partial.push((propertyString !== undefined) ? propertyString : 'null');\n        }\n\n        let final;\n        if (partial.length === 0) {\n            final = '[]';\n        } else {\n            if (gap === '') {\n                let properties = partial.join(',');\n                final = '[' + properties + ']';\n            } else {\n                let separator = ',\\n' + indent;\n                let properties = partial.join(separator);\n                final = '[\\n' + indent + properties + ',\\n' + stepback + ']';\n            }\n        }\n\n        stack.pop();\n        indent = stepback;\n        return final\n    }\n};\n\nconst JSON5 = {\n    parse,\n    stringify,\n};\n\nvar lib = JSON5;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lib);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2pzb241L2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NzLXJlYWN0LWRldnRvb2xzLWNvcmUvLi4vLi4vbm9kZV9tb2R1bGVzL2pzb241L2Rpc3QvaW5kZXgubWpzPzkxM2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBpcyBhIGdlbmVyYXRlZCBmaWxlLiBEbyBub3QgZWRpdC5cbnZhciBTcGFjZV9TZXBhcmF0b3IgPSAvW1xcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLztcbnZhciBJRF9TdGFydCA9IC9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NkFcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTA5RkNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJFXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkVBXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjJELVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERTAwXFx1REUwQi1cXHVERTMyXFx1REUzQVxcdURFNTBcXHVERTVDLVxcdURFODNcXHVERTg2LVxcdURFODlcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4RlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDMwXFx1REQ0Nl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3MlxcdUQ4NzQtXFx1RDg3OV1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTBcXHVERjkzLVxcdURGOUZcXHVERkUwXFx1REZFMV18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDAtXFx1REQxRVxcdURENzAtXFx1REVGQl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVERDAwLVxcdURENDNdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFcXHVERUIwLVxcdURGRkZdfFxcdUQ4N0FbXFx1REMwMC1cXHVERkUwXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0vO1xudmFyIElEX0NvbnRpbnVlID0gL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwODYwLVxcdTA4NkFcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOEQ0LVxcdTA4RTFcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTA5RkNcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOS1cXHUwQUZGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MC1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAwLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU0LVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjlcXHUxRDAwLVxcdTFERjlcXHUxREZCLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRVxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZFQVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNVxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdUREQ0EtXFx1RERDQ1xcdURERDAtXFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERTNFXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMDAtXFx1REM0QVxcdURDNTAtXFx1REM1OVxcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERTAwLVxcdURFM0VcXHVERTQ3XFx1REU1MC1cXHVERTgzXFx1REU4Ni1cXHVERTk5XFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMzNlxcdURDMzgtXFx1REM0MFxcdURDNTAtXFx1REM1OVxcdURDNzItXFx1REM4RlxcdURDOTItXFx1RENBN1xcdURDQTktXFx1RENCNlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ3XFx1REQ1MC1cXHVERDU5XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXFx1RDg3NC1cXHVEODc5XVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXFx1REZFMFxcdURGRTFdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMUVcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JcXHVERkNFLVxcdURGRkZdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1RENEMC1cXHVEQ0Q2XFx1REQwMC1cXHVERDRBXFx1REQ1MC1cXHVERDU5XXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS87XG5cbnZhciB1bmljb2RlID0ge1xuXHRTcGFjZV9TZXBhcmF0b3I6IFNwYWNlX1NlcGFyYXRvcixcblx0SURfU3RhcnQ6IElEX1N0YXJ0LFxuXHRJRF9Db250aW51ZTogSURfQ29udGludWVcbn07XG5cbnZhciB1dGlsID0ge1xuICAgIGlzU3BhY2VTZXBhcmF0b3IgKGMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyAmJiB1bmljb2RlLlNwYWNlX1NlcGFyYXRvci50ZXN0KGMpXG4gICAgfSxcblxuICAgIGlzSWRTdGFydENoYXIgKGMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyAmJiAoXG4gICAgICAgICAgICAoYyA+PSAnYScgJiYgYyA8PSAneicpIHx8XG4gICAgICAgIChjID49ICdBJyAmJiBjIDw9ICdaJykgfHxcbiAgICAgICAgKGMgPT09ICckJykgfHwgKGMgPT09ICdfJykgfHxcbiAgICAgICAgdW5pY29kZS5JRF9TdGFydC50ZXN0KGMpXG4gICAgICAgIClcbiAgICB9LFxuXG4gICAgaXNJZENvbnRpbnVlQ2hhciAoYykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnICYmIChcbiAgICAgICAgICAgIChjID49ICdhJyAmJiBjIDw9ICd6JykgfHxcbiAgICAgICAgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKSB8fFxuICAgICAgICAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHx8XG4gICAgICAgIChjID09PSAnJCcpIHx8IChjID09PSAnXycpIHx8XG4gICAgICAgIChjID09PSAnXFx1MjAwQycpIHx8IChjID09PSAnXFx1MjAwRCcpIHx8XG4gICAgICAgIHVuaWNvZGUuSURfQ29udGludWUudGVzdChjKVxuICAgICAgICApXG4gICAgfSxcblxuICAgIGlzRGlnaXQgKGMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyAmJiAvWzAtOV0vLnRlc3QoYylcbiAgICB9LFxuXG4gICAgaXNIZXhEaWdpdCAoYykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnICYmIC9bMC05QS1GYS1mXS8udGVzdChjKVxuICAgIH0sXG59O1xuXG5sZXQgc291cmNlO1xubGV0IHBhcnNlU3RhdGU7XG5sZXQgc3RhY2s7XG5sZXQgcG9zO1xubGV0IGxpbmU7XG5sZXQgY29sdW1uO1xubGV0IHRva2VuO1xubGV0IGtleTtcbmxldCByb290O1xuXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGV4dCwgcmV2aXZlcikge1xuICAgIHNvdXJjZSA9IFN0cmluZyh0ZXh0KTtcbiAgICBwYXJzZVN0YXRlID0gJ3N0YXJ0JztcbiAgICBzdGFjayA9IFtdO1xuICAgIHBvcyA9IDA7XG4gICAgbGluZSA9IDE7XG4gICAgY29sdW1uID0gMDtcbiAgICB0b2tlbiA9IHVuZGVmaW5lZDtcbiAgICBrZXkgPSB1bmRlZmluZWQ7XG4gICAgcm9vdCA9IHVuZGVmaW5lZDtcblxuICAgIGRvIHtcbiAgICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG4gICAgICAgIC8vIGlmICghcGFyc2VTdGF0ZXNbcGFyc2VTdGF0ZV0pIHtcbiAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRQYXJzZVN0YXRlKClcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHBhcnNlU3RhdGVzW3BhcnNlU3RhdGVdKCk7XG4gICAgfSB3aGlsZSAodG9rZW4udHlwZSAhPT0gJ2VvZicpXG5cbiAgICBpZiAodHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFsaXplKHsnJzogcm9vdH0sICcnLCByZXZpdmVyKVxuICAgIH1cblxuICAgIHJldHVybiByb290XG59O1xuXG5mdW5jdGlvbiBpbnRlcm5hbGl6ZSAoaG9sZGVyLCBuYW1lLCByZXZpdmVyKSB7XG4gICAgY29uc3QgdmFsdWUgPSBob2xkZXJbbmFtZV07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBpbnRlcm5hbGl6ZSh2YWx1ZSwga2V5LCByZXZpdmVyKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBuYW1lLCB2YWx1ZSlcbn1cblxubGV0IGxleFN0YXRlO1xubGV0IGJ1ZmZlcjtcbmxldCBkb3VibGVRdW90ZTtcbmxldCBzaWduO1xubGV0IGM7XG5cbmZ1bmN0aW9uIGxleCAoKSB7XG4gICAgbGV4U3RhdGUgPSAnZGVmYXVsdCc7XG4gICAgYnVmZmVyID0gJyc7XG4gICAgZG91YmxlUXVvdGUgPSBmYWxzZTtcbiAgICBzaWduID0gMTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgICAgYyA9IHBlZWsoKTtcblxuICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG4gICAgICAgIC8vIGlmICghbGV4U3RhdGVzW2xleFN0YXRlXSkge1xuICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZExleFN0YXRlKGxleFN0YXRlKVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgY29uc3QgdG9rZW4gPSBsZXhTdGF0ZXNbbGV4U3RhdGVdKCk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBlZWsgKCkge1xuICAgIGlmIChzb3VyY2VbcG9zXSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoc291cmNlLmNvZGVQb2ludEF0KHBvcykpXG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkICgpIHtcbiAgICBjb25zdCBjID0gcGVlaygpO1xuXG4gICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgIGxpbmUrKztcbiAgICAgICAgY29sdW1uID0gMDtcbiAgICB9IGVsc2UgaWYgKGMpIHtcbiAgICAgICAgY29sdW1uICs9IGMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHVtbisrO1xuICAgIH1cblxuICAgIGlmIChjKSB7XG4gICAgICAgIHBvcyArPSBjLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gY1xufVxuXG5jb25zdCBsZXhTdGF0ZXMgPSB7XG4gICAgZGVmYXVsdCAoKSB7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICBjYXNlICdcXHYnOlxuICAgICAgICBjYXNlICdcXGYnOlxuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnXFx1MDBBMCc6XG4gICAgICAgIGNhc2UgJ1xcdUZFRkYnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICBjYXNlICdcXHUyMDI4JzpcbiAgICAgICAgY2FzZSAnXFx1MjAyOSc6XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2NvbW1lbnQnO1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ2VvZicpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbC5pc1NwYWNlU2VwYXJhdG9yKGMpKSB7XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZS5cbiAgICAgICAgLy8gaWYgKCFsZXhTdGF0ZXNbcGFyc2VTdGF0ZV0pIHtcbiAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRMZXhTdGF0ZShwYXJzZVN0YXRlKVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgcmV0dXJuIGxleFN0YXRlc1twYXJzZVN0YXRlXSgpXG4gICAgfSxcblxuICAgIGNvbW1lbnQgKCkge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdtdWx0aUxpbmVDb21tZW50JztcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnc2luZ2xlTGluZUNvbW1lbnQnO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgfSxcblxuICAgIG11bHRpTGluZUNvbW1lbnQgKCkge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdtdWx0aUxpbmVDb21tZW50QXN0ZXJpc2snO1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgICAgIH1cblxuICAgICAgICByZWFkKCk7XG4gICAgfSxcblxuICAgIG11bHRpTGluZUNvbW1lbnRBc3RlcmlzayAoKSB7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJlYWQoKTtcbiAgICAgICAgbGV4U3RhdGUgPSAnbXVsdGlMaW5lQ29tbWVudCc7XG4gICAgfSxcblxuICAgIHNpbmdsZUxpbmVDb21tZW50ICgpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgIGNhc2UgJ1xcdTIwMjgnOlxuICAgICAgICBjYXNlICdcXHUyMDI5JzpcbiAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ2VvZicpXG4gICAgICAgIH1cblxuICAgICAgICByZWFkKCk7XG4gICAgfSxcblxuICAgIHZhbHVlICgpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcblxuICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgIGxpdGVyYWwoJ3VsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudWxsJywgbnVsbClcblxuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgIGxpdGVyYWwoJ3J1ZScpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdib29sZWFuJywgdHJ1ZSlcblxuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgIGxpdGVyYWwoJ2Fsc2UnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignYm9vbGVhbicsIGZhbHNlKVxuXG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgIGlmIChyZWFkKCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV4U3RhdGUgPSAnc2lnbic7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGJ1ZmZlciA9IHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxQb2ludExlYWRpbmcnO1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICd6ZXJvJztcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJzEnOlxuICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgIGNhc2UgJzQnOlxuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgY2FzZSAnNic6XG4gICAgICAgIGNhc2UgJzcnOlxuICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsSW50ZWdlcic7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICdJJzpcbiAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgIGxpdGVyYWwoJ25maW5pdHknKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIEluZmluaXR5KVxuXG4gICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgbGl0ZXJhbCgnYU4nKTtcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIE5hTilcblxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBkb3VibGVRdW90ZSA9IChyZWFkKCkgPT09ICdcIicpO1xuICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgfSxcblxuICAgIGlkZW50aWZpZXJOYW1lU3RhcnRFc2NhcGUgKCkge1xuICAgICAgICBpZiAoYyAhPT0gJ3UnKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgICAgIH1cblxuICAgICAgICByZWFkKCk7XG4gICAgICAgIGNvbnN0IHUgPSB1bmljb2RlRXNjYXBlKCk7XG4gICAgICAgIHN3aXRjaCAodSkge1xuICAgICAgICBjYXNlICckJzpcbiAgICAgICAgY2FzZSAnXyc6XG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNJZFN0YXJ0Q2hhcih1KSkge1xuICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRJZGVudGlmaWVyKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlciArPSB1O1xuICAgICAgICBsZXhTdGF0ZSA9ICdpZGVudGlmaWVyTmFtZSc7XG4gICAgfSxcblxuICAgIGlkZW50aWZpZXJOYW1lICgpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJyQnOlxuICAgICAgICBjYXNlICdfJzpcbiAgICAgICAgY2FzZSAnXFx1MjAwQyc6XG4gICAgICAgIGNhc2UgJ1xcdTIwMEQnOlxuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnaWRlbnRpZmllck5hbWVFc2NhcGUnO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbC5pc0lkQ29udGludWVDaGFyKGMpKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ2lkZW50aWZpZXInLCBidWZmZXIpXG4gICAgfSxcblxuICAgIGlkZW50aWZpZXJOYW1lRXNjYXBlICgpIHtcbiAgICAgICAgaWYgKGMgIT09ICd1Jykge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmVhZCgpO1xuICAgICAgICBjb25zdCB1ID0gdW5pY29kZUVzY2FwZSgpO1xuICAgICAgICBzd2l0Y2ggKHUpIHtcbiAgICAgICAgY2FzZSAnJCc6XG4gICAgICAgIGNhc2UgJ18nOlxuICAgICAgICBjYXNlICdcXHUyMDBDJzpcbiAgICAgICAgY2FzZSAnXFx1MjAwRCc6XG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNJZENvbnRpbnVlQ2hhcih1KSkge1xuICAgICAgICAgICAgICAgIHRocm93IGludmFsaWRJZGVudGlmaWVyKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlciArPSB1O1xuICAgICAgICBsZXhTdGF0ZSA9ICdpZGVudGlmaWVyTmFtZSc7XG4gICAgfSxcblxuICAgIHNpZ24gKCkge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBidWZmZXIgPSByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsUG9pbnRMZWFkaW5nJztcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICAgICAgYnVmZmVyID0gcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnemVybyc7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgY2FzZSAnMic6XG4gICAgICAgIGNhc2UgJzMnOlxuICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgIGNhc2UgJzYnOlxuICAgICAgICBjYXNlICc3JzpcbiAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgIGNhc2UgJzknOlxuICAgICAgICAgICAgYnVmZmVyID0gcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEludGVnZXInO1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICBsaXRlcmFsKCduZmluaXR5Jyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ251bWVyaWMnLCBzaWduICogSW5maW5pdHkpXG5cbiAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICBsaXRlcmFsKCdhTicpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgTmFOKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuICAgIH0sXG5cbiAgICB6ZXJvICgpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxQb2ludCc7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50JztcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdoZXhhZGVjaW1hbCc7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIHNpZ24gKiAwKVxuICAgIH0sXG5cbiAgICBkZWNpbWFsSW50ZWdlciAoKSB7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsUG9pbnQnO1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxFeHBvbmVudCc7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIHNpZ24gKiBOdW1iZXIoYnVmZmVyKSlcbiAgICB9LFxuXG4gICAgZGVjaW1hbFBvaW50TGVhZGluZyAoKSB7XG4gICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRnJhY3Rpb24nO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgfSxcblxuICAgIGRlY2ltYWxQb2ludCAoKSB7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50JztcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWwuaXNEaWdpdChjKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxGcmFjdGlvbic7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdUb2tlbignbnVtZXJpYycsIHNpZ24gKiBOdW1iZXIoYnVmZmVyKSlcbiAgICB9LFxuXG4gICAgZGVjaW1hbEZyYWN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRXhwb25lbnQnO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbC5pc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ251bWVyaWMnLCBzaWduICogTnVtYmVyKGJ1ZmZlcikpXG4gICAgfSxcblxuICAgIGRlY2ltYWxFeHBvbmVudCAoKSB7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnZGVjaW1hbEV4cG9uZW50U2lnbic7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlsLmlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG4gICAgICAgICAgICBsZXhTdGF0ZSA9ICdkZWNpbWFsRXhwb25lbnRJbnRlZ2VyJztcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuICAgIH0sXG5cbiAgICBkZWNpbWFsRXhwb25lbnRTaWduICgpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNEaWdpdChjKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2RlY2ltYWxFeHBvbmVudEludGVnZXInO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgfSxcblxuICAgIGRlY2ltYWxFeHBvbmVudEludGVnZXIgKCkge1xuICAgICAgICBpZiAodXRpbC5pc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ251bWVyaWMnLCBzaWduICogTnVtYmVyKGJ1ZmZlcikpXG4gICAgfSxcblxuICAgIGhleGFkZWNpbWFsICgpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNIZXhEaWdpdChjKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2hleGFkZWNpbWFsSW50ZWdlcic7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcbiAgICB9LFxuXG4gICAgaGV4YWRlY2ltYWxJbnRlZ2VyICgpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNIZXhEaWdpdChjKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdudW1lcmljJywgc2lnbiAqIE51bWJlcihidWZmZXIpKVxuICAgIH0sXG5cbiAgICBzdHJpbmcgKCkge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICBidWZmZXIgKz0gZXNjYXBlKCk7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBpZiAoZG91YmxlUXVvdGUpIHtcbiAgICAgICAgICAgICAgICByZWFkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Rva2VuKCdzdHJpbmcnLCBidWZmZXIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJ1ZmZlciArPSByZWFkKCk7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgaWYgKCFkb3VibGVRdW90ZSkge1xuICAgICAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ3N0cmluZycsIGJ1ZmZlcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cbiAgICAgICAgY2FzZSAnXFx1MjAyOCc6XG4gICAgICAgIGNhc2UgJ1xcdTIwMjknOlxuICAgICAgICAgICAgc2VwYXJhdG9yQ2hhcihjKTtcbiAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuICAgIH0sXG5cbiAgICBzdGFydCAoKSB7XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3VG9rZW4oJ3B1bmN0dWF0b3InLCByZWFkKCkpXG5cbiAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIHRoZSBkZWZhdWx0IGxleFN0YXRlIGhhbmRsZXMgZW9mLlxuICAgICAgICAvLyBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgLy8gICAgIHJldHVybiBuZXdUb2tlbignZW9mJylcbiAgICAgICAgfVxuXG4gICAgICAgIGxleFN0YXRlID0gJ3ZhbHVlJztcbiAgICB9LFxuXG4gICAgYmVmb3JlUHJvcGVydHlOYW1lICgpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJyQnOlxuICAgICAgICBjYXNlICdfJzpcbiAgICAgICAgICAgIGJ1ZmZlciA9IHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2lkZW50aWZpZXJOYW1lJztcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnaWRlbnRpZmllck5hbWVTdGFydEVzY2FwZSc7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcblxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBkb3VibGVRdW90ZSA9IChyZWFkKCkgPT09ICdcIicpO1xuICAgICAgICAgICAgbGV4U3RhdGUgPSAnc3RyaW5nJztcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWwuaXNJZFN0YXJ0Q2hhcihjKSkge1xuICAgICAgICAgICAgYnVmZmVyICs9IHJlYWQoKTtcbiAgICAgICAgICAgIGxleFN0YXRlID0gJ2lkZW50aWZpZXJOYW1lJztcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuICAgIH0sXG5cbiAgICBhZnRlclByb3BlcnR5TmFtZSAoKSB7XG4gICAgICAgIGlmIChjID09PSAnOicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcbiAgICB9LFxuXG4gICAgYmVmb3JlUHJvcGVydHlWYWx1ZSAoKSB7XG4gICAgICAgIGxleFN0YXRlID0gJ3ZhbHVlJztcbiAgICB9LFxuXG4gICAgYWZ0ZXJQcm9wZXJ0eVZhbHVlICgpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcbiAgICB9LFxuXG4gICAgYmVmb3JlQXJyYXlWYWx1ZSAoKSB7XG4gICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxleFN0YXRlID0gJ3ZhbHVlJztcbiAgICB9LFxuXG4gICAgYWZ0ZXJBcnJheVZhbHVlICgpIHtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbigncHVuY3R1YXRvcicsIHJlYWQoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGludmFsaWRDaGFyKHJlYWQoKSlcbiAgICB9LFxuXG4gICAgZW5kICgpIHtcbiAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgZGVmYXVsdCBsZXhTdGF0ZS5cbiAgICAgICAgLy8gaWYgKGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyAgICAgcmVhZCgpXG4gICAgICAgIC8vICAgICByZXR1cm4gbmV3VG9rZW4oJ2VvZicpXG4gICAgICAgIC8vIH1cblxuICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIG5ld1Rva2VuICh0eXBlLCB2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBsaW5lLFxuICAgICAgICBjb2x1bW4sXG4gICAgfVxufVxuXG5mdW5jdGlvbiBsaXRlcmFsIChzKSB7XG4gICAgZm9yIChjb25zdCBjIG9mIHMpIHtcbiAgICAgICAgY29uc3QgcCA9IHBlZWsoKTtcblxuICAgICAgICBpZiAocCAhPT0gYykge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmVhZCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXNjYXBlICgpIHtcbiAgICBjb25zdCBjID0gcGVlaygpO1xuICAgIHN3aXRjaCAoYykge1xuICAgIGNhc2UgJ2InOlxuICAgICAgICByZWFkKCk7XG4gICAgICAgIHJldHVybiAnXFxiJ1xuXG4gICAgY2FzZSAnZic6XG4gICAgICAgIHJlYWQoKTtcbiAgICAgICAgcmV0dXJuICdcXGYnXG5cbiAgICBjYXNlICduJzpcbiAgICAgICAgcmVhZCgpO1xuICAgICAgICByZXR1cm4gJ1xcbidcblxuICAgIGNhc2UgJ3InOlxuICAgICAgICByZWFkKCk7XG4gICAgICAgIHJldHVybiAnXFxyJ1xuXG4gICAgY2FzZSAndCc6XG4gICAgICAgIHJlYWQoKTtcbiAgICAgICAgcmV0dXJuICdcXHQnXG5cbiAgICBjYXNlICd2JzpcbiAgICAgICAgcmVhZCgpO1xuICAgICAgICByZXR1cm4gJ1xcdidcblxuICAgIGNhc2UgJzAnOlxuICAgICAgICByZWFkKCk7XG4gICAgICAgIGlmICh1dGlsLmlzRGlnaXQocGVlaygpKSkge1xuICAgICAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdcXDAnXG5cbiAgICBjYXNlICd4JzpcbiAgICAgICAgcmVhZCgpO1xuICAgICAgICByZXR1cm4gaGV4RXNjYXBlKClcblxuICAgIGNhc2UgJ3UnOlxuICAgICAgICByZWFkKCk7XG4gICAgICAgIHJldHVybiB1bmljb2RlRXNjYXBlKClcblxuICAgIGNhc2UgJ1xcbic6XG4gICAgY2FzZSAnXFx1MjAyOCc6XG4gICAgY2FzZSAnXFx1MjAyOSc6XG4gICAgICAgIHJlYWQoKTtcbiAgICAgICAgcmV0dXJuICcnXG5cbiAgICBjYXNlICdcXHInOlxuICAgICAgICByZWFkKCk7XG4gICAgICAgIGlmIChwZWVrKCkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICByZWFkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJydcblxuICAgIGNhc2UgJzEnOlxuICAgIGNhc2UgJzInOlxuICAgIGNhc2UgJzMnOlxuICAgIGNhc2UgJzQnOlxuICAgIGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOlxuICAgIGNhc2UgJzcnOlxuICAgIGNhc2UgJzgnOlxuICAgIGNhc2UgJzknOlxuICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG5cbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuICAgIH1cblxuICAgIHJldHVybiByZWFkKClcbn1cblxuZnVuY3Rpb24gaGV4RXNjYXBlICgpIHtcbiAgICBsZXQgYnVmZmVyID0gJyc7XG4gICAgbGV0IGMgPSBwZWVrKCk7XG5cbiAgICBpZiAoIXV0aWwuaXNIZXhEaWdpdChjKSkge1xuICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgfVxuXG4gICAgYnVmZmVyICs9IHJlYWQoKTtcblxuICAgIGMgPSBwZWVrKCk7XG4gICAgaWYgKCF1dGlsLmlzSGV4RGlnaXQoYykpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZENoYXIocmVhZCgpKVxuICAgIH1cblxuICAgIGJ1ZmZlciArPSByZWFkKCk7XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoYnVmZmVyLCAxNikpXG59XG5cbmZ1bmN0aW9uIHVuaWNvZGVFc2NhcGUgKCkge1xuICAgIGxldCBidWZmZXIgPSAnJztcbiAgICBsZXQgY291bnQgPSA0O1xuXG4gICAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwZWVrKCk7XG4gICAgICAgIGlmICghdXRpbC5pc0hleERpZ2l0KGMpKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkQ2hhcihyZWFkKCkpXG4gICAgICAgIH1cblxuICAgICAgICBidWZmZXIgKz0gcmVhZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChidWZmZXIsIDE2KSlcbn1cblxuY29uc3QgcGFyc2VTdGF0ZXMgPSB7XG4gICAgc3RhcnQgKCkge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRFT0YoKVxuICAgICAgICB9XG5cbiAgICAgICAgcHVzaCgpO1xuICAgIH0sXG5cbiAgICBiZWZvcmVQcm9wZXJ0eU5hbWUgKCkge1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaWRlbnRpZmllcic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBrZXkgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYWZ0ZXJQcm9wZXJ0eU5hbWUnO1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgY2FzZSAncHVuY3R1YXRvcic6XG4gICAgICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cbiAgICAgICAgICAgIC8vIGlmICh0b2tlbi52YWx1ZSAhPT0gJ30nKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhyb3cgaW52YWxpZFRva2VuKClcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgcG9wKCk7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICdlb2YnOlxuICAgICAgICAgICAgdGhyb3cgaW52YWxpZEVPRigpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cbiAgICAgICAgLy8gdGhyb3cgaW52YWxpZFRva2VuKClcbiAgICB9LFxuXG4gICAgYWZ0ZXJQcm9wZXJ0eU5hbWUgKCkge1xuICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cbiAgICAgICAgLy8gaWYgKHRva2VuLnR5cGUgIT09ICdwdW5jdHVhdG9yJyB8fCB0b2tlbi52YWx1ZSAhPT0gJzonKSB7XG4gICAgICAgIC8vICAgICB0aHJvdyBpbnZhbGlkVG9rZW4oKVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdlb2YnKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkRU9GKClcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlU3RhdGUgPSAnYmVmb3JlUHJvcGVydHlWYWx1ZSc7XG4gICAgfSxcblxuICAgIGJlZm9yZVByb3BlcnR5VmFsdWUgKCkge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRFT0YoKVxuICAgICAgICB9XG5cbiAgICAgICAgcHVzaCgpO1xuICAgIH0sXG5cbiAgICBiZWZvcmVBcnJheVZhbHVlICgpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdlb2YnKSB7XG4gICAgICAgICAgICB0aHJvdyBpbnZhbGlkRU9GKClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAncHVuY3R1YXRvcicgJiYgdG9rZW4udmFsdWUgPT09ICddJykge1xuICAgICAgICAgICAgcG9wKCk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2goKTtcbiAgICB9LFxuXG4gICAgYWZ0ZXJQcm9wZXJ0eVZhbHVlICgpIHtcbiAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG4gICAgICAgIC8vIGlmICh0b2tlbi50eXBlICE9PSAncHVuY3R1YXRvcicpIHtcbiAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRUb2tlbigpXG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRFT0YoKVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYmVmb3JlUHJvcGVydHlOYW1lJztcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgcG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUgc2luY2UgaXQncyBoYW5kbGVkIGJ5IHRoZSBsZXhTdGF0ZS5cbiAgICAgICAgLy8gdGhyb3cgaW52YWxpZFRva2VuKClcbiAgICB9LFxuXG4gICAgYWZ0ZXJBcnJheVZhbHVlICgpIHtcbiAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG4gICAgICAgIC8vIGlmICh0b2tlbi50eXBlICE9PSAncHVuY3R1YXRvcicpIHtcbiAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRUb2tlbigpXG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcbiAgICAgICAgICAgIHRocm93IGludmFsaWRFT0YoKVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYmVmb3JlQXJyYXlWYWx1ZSc7XG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgbGV4U3RhdGUuXG4gICAgICAgIC8vIHRocm93IGludmFsaWRUb2tlbigpXG4gICAgfSxcblxuICAgIGVuZCAoKSB7XG4gICAgICAgIC8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZSBzaW5jZSBpdCdzIGhhbmRsZWQgYnkgdGhlIGxleFN0YXRlLlxuICAgICAgICAvLyBpZiAodG9rZW4udHlwZSAhPT0gJ2VvZicpIHtcbiAgICAgICAgLy8gICAgIHRocm93IGludmFsaWRUb2tlbigpXG4gICAgICAgIC8vIH1cbiAgICB9LFxufTtcblxuZnVuY3Rpb24gcHVzaCAoKSB7XG4gICAgbGV0IHZhbHVlO1xuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgY2FzZSAncHVuY3R1YXRvcic6XG4gICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ251bGwnOlxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWVyaWMnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgIGJyZWFrXG5cbiAgICAvLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG4gICAgLy8gZGVmYXVsdDpcbiAgICAvLyAgICAgdGhyb3cgaW52YWxpZFRva2VuKClcbiAgICB9XG5cbiAgICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvb3QgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgICAgICAgcGFyZW50LnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcGFyc2VTdGF0ZSA9ICdiZWZvcmVBcnJheVZhbHVlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYmVmb3JlUHJvcGVydHlOYW1lJztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyc2VTdGF0ZSA9ICdlbmQnO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYWZ0ZXJBcnJheVZhbHVlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlU3RhdGUgPSAnYWZ0ZXJQcm9wZXJ0eVZhbHVlJztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9wICgpIHtcbiAgICBzdGFjay5wb3AoKTtcblxuICAgIGNvbnN0IGN1cnJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgIHBhcnNlU3RhdGUgPSAnZW5kJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgcGFyc2VTdGF0ZSA9ICdhZnRlckFycmF5VmFsdWUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlU3RhdGUgPSAnYWZ0ZXJQcm9wZXJ0eVZhbHVlJztcbiAgICB9XG59XG5cbi8vIFRoaXMgY29kZSBpcyB1bnJlYWNoYWJsZS5cbi8vIGZ1bmN0aW9uIGludmFsaWRQYXJzZVN0YXRlICgpIHtcbi8vICAgICByZXR1cm4gbmV3IEVycm9yKGBKU09ONTogaW52YWxpZCBwYXJzZSBzdGF0ZSAnJHtwYXJzZVN0YXRlfSdgKVxuLy8gfVxuXG4vLyBUaGlzIGNvZGUgaXMgdW5yZWFjaGFibGUuXG4vLyBmdW5jdGlvbiBpbnZhbGlkTGV4U3RhdGUgKHN0YXRlKSB7XG4vLyAgICAgcmV0dXJuIG5ldyBFcnJvcihgSlNPTjU6IGludmFsaWQgbGV4IHN0YXRlICcke3N0YXRlfSdgKVxuLy8gfVxuXG5mdW5jdGlvbiBpbnZhbGlkQ2hhciAoYykge1xuICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN5bnRheEVycm9yKGBKU09ONTogaW52YWxpZCBlbmQgb2YgaW5wdXQgYXQgJHtsaW5lfToke2NvbHVtbn1gKVxuICAgIH1cblxuICAgIHJldHVybiBzeW50YXhFcnJvcihgSlNPTjU6IGludmFsaWQgY2hhcmFjdGVyICcke2Zvcm1hdENoYXIoYyl9JyBhdCAke2xpbmV9OiR7Y29sdW1ufWApXG59XG5cbmZ1bmN0aW9uIGludmFsaWRFT0YgKCkge1xuICAgIHJldHVybiBzeW50YXhFcnJvcihgSlNPTjU6IGludmFsaWQgZW5kIG9mIGlucHV0IGF0ICR7bGluZX06JHtjb2x1bW59YClcbn1cblxuLy8gVGhpcyBjb2RlIGlzIHVucmVhY2hhYmxlLlxuLy8gZnVuY3Rpb24gaW52YWxpZFRva2VuICgpIHtcbi8vICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2VvZicpIHtcbi8vICAgICAgICAgcmV0dXJuIHN5bnRheEVycm9yKGBKU09ONTogaW52YWxpZCBlbmQgb2YgaW5wdXQgYXQgJHtsaW5lfToke2NvbHVtbn1gKVxuLy8gICAgIH1cblxuLy8gICAgIGNvbnN0IGMgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0b2tlbi52YWx1ZS5jb2RlUG9pbnRBdCgwKSlcbi8vICAgICByZXR1cm4gc3ludGF4RXJyb3IoYEpTT041OiBpbnZhbGlkIGNoYXJhY3RlciAnJHtmb3JtYXRDaGFyKGMpfScgYXQgJHtsaW5lfToke2NvbHVtbn1gKVxuLy8gfVxuXG5mdW5jdGlvbiBpbnZhbGlkSWRlbnRpZmllciAoKSB7XG4gICAgY29sdW1uIC09IDU7XG4gICAgcmV0dXJuIHN5bnRheEVycm9yKGBKU09ONTogaW52YWxpZCBpZGVudGlmaWVyIGNoYXJhY3RlciBhdCAke2xpbmV9OiR7Y29sdW1ufWApXG59XG5cbmZ1bmN0aW9uIHNlcGFyYXRvckNoYXIgKGMpIHtcbiAgICBjb25zb2xlLndhcm4oYEpTT041OiAnJHtmb3JtYXRDaGFyKGMpfScgaW4gc3RyaW5ncyBpcyBub3QgdmFsaWQgRUNNQVNjcmlwdDsgY29uc2lkZXIgZXNjYXBpbmdgKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Q2hhciAoYykge1xuICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IHtcbiAgICAgICAgXCInXCI6IFwiXFxcXCdcIixcbiAgICAgICAgJ1wiJzogJ1xcXFxcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJyxcbiAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAnXFx2JzogJ1xcXFx2JyxcbiAgICAgICAgJ1xcMCc6ICdcXFxcMCcsXG4gICAgICAgICdcXHUyMDI4JzogJ1xcXFx1MjAyOCcsXG4gICAgICAgICdcXHUyMDI5JzogJ1xcXFx1MjAyOScsXG4gICAgfTtcblxuICAgIGlmIChyZXBsYWNlbWVudHNbY10pIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50c1tjXVxuICAgIH1cblxuICAgIGlmIChjIDwgJyAnKSB7XG4gICAgICAgIGNvbnN0IGhleFN0cmluZyA9IGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBoZXhTdHJpbmcpLnN1YnN0cmluZyhoZXhTdHJpbmcubGVuZ3RoKVxuICAgIH1cblxuICAgIHJldHVybiBjXG59XG5cbmZ1bmN0aW9uIHN5bnRheEVycm9yIChtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgIGVyci5saW5lTnVtYmVyID0gbGluZTtcbiAgICBlcnIuY29sdW1uTnVtYmVyID0gY29sdW1uO1xuICAgIHJldHVybiBlcnJcbn1cblxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeSAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgbGV0IGluZGVudCA9ICcnO1xuICAgIGxldCBwcm9wZXJ0eUxpc3Q7XG4gICAgbGV0IHJlcGxhY2VyRnVuYztcbiAgICBsZXQgZ2FwID0gJyc7XG4gICAgbGV0IHF1b3RlO1xuXG4gICAgaWYgKFxuICAgICAgICByZXBsYWNlciAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiByZXBsYWNlciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkocmVwbGFjZXIpXG4gICAgKSB7XG4gICAgICAgIHNwYWNlID0gcmVwbGFjZXIuc3BhY2U7XG4gICAgICAgIHF1b3RlID0gcmVwbGFjZXIucXVvdGU7XG4gICAgICAgIHJlcGxhY2VyID0gcmVwbGFjZXIucmVwbGFjZXI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXBsYWNlckZ1bmMgPSByZXBsYWNlcjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgIHByb3BlcnR5TGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgcmVwbGFjZXIpIHtcbiAgICAgICAgICAgIGxldCBpdGVtO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgICAgICAgICB2IGluc3RhbmNlb2YgTnVtYmVyXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gU3RyaW5nKHYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnR5TGlzdC5pbmRleE9mKGl0ZW0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5TGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwYWNlIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHNwYWNlID0gTnVtYmVyKHNwYWNlKTtcbiAgICB9IGVsc2UgaWYgKHNwYWNlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIHNwYWNlID0gU3RyaW5nKHNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoc3BhY2UgPiAwKSB7XG4gICAgICAgICAgICBzcGFjZSA9IE1hdGgubWluKDEwLCBNYXRoLmZsb29yKHNwYWNlKSk7XG4gICAgICAgICAgICBnYXAgPSAnICAgICAgICAgICcuc3Vic3RyKDAsIHNwYWNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBnYXAgPSBzcGFjZS5zdWJzdHIoMCwgMTApO1xuICAgIH1cblxuICAgIHJldHVybiBzZXJpYWxpemVQcm9wZXJ0eSgnJywgeycnOiB2YWx1ZX0pXG5cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVQcm9wZXJ0eSAoa2V5LCBob2xkZXIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTjUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTjUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVwbGFjZXJGdW5jKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyRnVuYy5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgbnVsbDogcmV0dXJuICdudWxsJ1xuICAgICAgICBjYXNlIHRydWU6IHJldHVybiAndHJ1ZSdcbiAgICAgICAgY2FzZSBmYWxzZTogcmV0dXJuICdmYWxzZSdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGVTdHJpbmcodmFsdWUsIGZhbHNlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gc2VyaWFsaXplQXJyYXkodmFsdWUpIDogc2VyaWFsaXplT2JqZWN0KHZhbHVlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHF1b3RlU3RyaW5nICh2YWx1ZSkge1xuICAgICAgICBjb25zdCBxdW90ZXMgPSB7XG4gICAgICAgICAgICBcIidcIjogMC4xLFxuICAgICAgICAgICAgJ1wiJzogMC4yLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IHtcbiAgICAgICAgICAgIFwiJ1wiOiBcIlxcXFwnXCIsXG4gICAgICAgICAgICAnXCInOiAnXFxcXFwiJyxcbiAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJyxcbiAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAnXFx2JzogJ1xcXFx2JyxcbiAgICAgICAgICAgICdcXDAnOiAnXFxcXDAnLFxuICAgICAgICAgICAgJ1xcdTIwMjgnOiAnXFxcXHUyMDI4JyxcbiAgICAgICAgICAgICdcXHUyMDI5JzogJ1xcXFx1MjAyOScsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHByb2R1Y3QgPSAnJztcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gdmFsdWVbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgcXVvdGVzW2NdKys7XG4gICAgICAgICAgICAgICAgcHJvZHVjdCArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGNhc2UgJ1xcMCc6XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNEaWdpdCh2YWx1ZVtpICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3QgKz0gJ1xcXFx4MDAnO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50c1tjXSkge1xuICAgICAgICAgICAgICAgIHByb2R1Y3QgKz0gcmVwbGFjZW1lbnRzW2NdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjIDwgJyAnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhleFN0cmluZyA9IGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgcHJvZHVjdCArPSAnXFxcXHgnICsgKCcwMCcgKyBoZXhTdHJpbmcpLnN1YnN0cmluZyhoZXhTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9kdWN0ICs9IGM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBxdW90ZUNoYXIgPSBxdW90ZSB8fCBPYmplY3Qua2V5cyhxdW90ZXMpLnJlZHVjZSgoYSwgYikgPT4gKHF1b3Rlc1thXSA8IHF1b3Rlc1tiXSkgPyBhIDogYik7XG5cbiAgICAgICAgcHJvZHVjdCA9IHByb2R1Y3QucmVwbGFjZShuZXcgUmVnRXhwKHF1b3RlQ2hhciwgJ2cnKSwgcmVwbGFjZW1lbnRzW3F1b3RlQ2hhcl0pO1xuXG4gICAgICAgIHJldHVybiBxdW90ZUNoYXIgKyBwcm9kdWN0ICsgcXVvdGVDaGFyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0ICh2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09ONScpXG4gICAgICAgIH1cblxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuICAgICAgICBsZXQgc3RlcGJhY2sgPSBpbmRlbnQ7XG4gICAgICAgIGluZGVudCA9IGluZGVudCArIGdhcDtcblxuICAgICAgICBsZXQga2V5cyA9IHByb3BlcnR5TGlzdCB8fCBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGxldCBwYXJ0aWFsID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U3RyaW5nID0gc2VyaWFsaXplUHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocHJvcGVydHlTdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBtZW1iZXIgPSBzZXJpYWxpemVLZXkoa2V5KSArICc6JztcbiAgICAgICAgICAgICAgICBpZiAoZ2FwICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXIgKz0gJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZW1iZXIgKz0gcHJvcGVydHlTdHJpbmc7XG4gICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKG1lbWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmluYWw7XG4gICAgICAgIGlmIChwYXJ0aWFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZmluYWwgPSAne30nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAoZ2FwID09PSAnJykge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgPSBwYXJ0aWFsLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICBmaW5hbCA9ICd7JyArIHByb3BlcnRpZXMgKyAnfSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzZXBhcmF0b3IgPSAnLFxcbicgKyBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHBhcnRpYWwuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGZpbmFsID0gJ3tcXG4nICsgaW5kZW50ICsgcHJvcGVydGllcyArICcsXFxuJyArIHN0ZXBiYWNrICsgJ30nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGluZGVudCA9IHN0ZXBiYWNrO1xuICAgICAgICByZXR1cm4gZmluYWxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVLZXkgKGtleSkge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlU3RyaW5nKGtleSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpcnN0Q2hhciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGtleS5jb2RlUG9pbnRBdCgwKSk7XG4gICAgICAgIGlmICghdXRpbC5pc0lkU3RhcnRDaGFyKGZpcnN0Q2hhcikpIHtcbiAgICAgICAgICAgIHJldHVybiBxdW90ZVN0cmluZyhrZXksIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gZmlyc3RDaGFyLmxlbmd0aDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzSWRDb250aW51ZUNoYXIoU3RyaW5nLmZyb21Db2RlUG9pbnQoa2V5LmNvZGVQb2ludEF0KGkpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGVTdHJpbmcoa2V5LCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGtleVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5ICh2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09ONScpXG4gICAgICAgIH1cblxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuICAgICAgICBsZXQgc3RlcGJhY2sgPSBpbmRlbnQ7XG4gICAgICAgIGluZGVudCA9IGluZGVudCArIGdhcDtcblxuICAgICAgICBsZXQgcGFydGlhbCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVN0cmluZyA9IHNlcmlhbGl6ZVByb3BlcnR5KFN0cmluZyhpKSwgdmFsdWUpO1xuICAgICAgICAgICAgcGFydGlhbC5wdXNoKChwcm9wZXJ0eVN0cmluZyAhPT0gdW5kZWZpbmVkKSA/IHByb3BlcnR5U3RyaW5nIDogJ251bGwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaW5hbDtcbiAgICAgICAgaWYgKHBhcnRpYWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaW5hbCA9ICdbXSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZ2FwID09PSAnJykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0aWVzID0gcGFydGlhbC5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgZmluYWwgPSAnWycgKyBwcm9wZXJ0aWVzICsgJ10nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VwYXJhdG9yID0gJyxcXG4nICsgaW5kZW50O1xuICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0aWVzID0gcGFydGlhbC5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgZmluYWwgPSAnW1xcbicgKyBpbmRlbnQgKyBwcm9wZXJ0aWVzICsgJyxcXG4nICsgc3RlcGJhY2sgKyAnXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgaW5kZW50ID0gc3RlcGJhY2s7XG4gICAgICAgIHJldHVybiBmaW5hbFxuICAgIH1cbn07XG5cbmNvbnN0IEpTT041ID0ge1xuICAgIHBhcnNlLFxuICAgIHN0cmluZ2lmeSxcbn07XG5cbnZhciBsaWIgPSBKU09ONTtcblxuZXhwb3J0IGRlZmF1bHQgbGliO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/json5/dist/index.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/standalone.js");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;